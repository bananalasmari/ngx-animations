{"hash":"6ffbd0785f1d6435a6c04c932bc10699c30ff77048f2a096e409a2b2f802e3b6","types":[{"exports":["BounceDirection","BounceInDirective","ConfettiComponent","CountUpDirective","EasingFunction","FadeDirection","FadeInDirective","FlipAxis","FlipInDirective","GlassCardComponent","GlitchDirective","HoverLiftDirective","MagneticDirective","MarqueeComponent","MarqueeDirection","MorphDirective","MouseFollowerComponent","OrbitAnimationComponent","OrbitDirection","ParallaxScrollDirective","ProfileCardComponent","ProfileCardData","ProfileGridComponent","PulseDirective","RevealAnimation","RippleClickDirective","RotateAxis","RotateInDirective","RtlLanguageService","ScaleInDirective","ScaleOrigin","ScrollProgressDirective","ScrollRevealComponent","ShakeDirective","ShakeIntensity","SlideDirection","SlideInDirective","StaggerAnimation","StaggerListComponent","TextScrambleComponent","Tilt3dDirective","Timeline","TimelineOptions","TimelineService","TimelineStep","TypewriterComponent","ZoomInDirective","ZoomStyle"],"facadeModuleId":"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/elm-ngx-animations.d.ts","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/fade-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/slide-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/scale-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/rotate-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/parallax-scroll.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/ripple-click.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/bounce-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/flip-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/shake.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/pulse.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/glitch.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/zoom-in.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/hover-lift.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/count-up.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/magnetic.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/tilt-3d.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/scroll-progress.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/morph.directive.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/scroll-reveal/scroll-reveal.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/stagger-list/stagger-list.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/typewriter/typewriter.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/marquee/marquee.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/orbit-animation/orbit-animation.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/confetti/confetti.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/text-scramble/text-scramble.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/mouse-follower/mouse-follower.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/profile-card/profile-card.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/profile-grid/profile-grid.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/glass-card/glass-card.component.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/services/timeline.service.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/services/rtl-language.service.d.ts","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/elm-ngx-animations.d.ts"],"name":"elm-ngx-animations.d","type":"chunk","dynamicImports":[],"fileName":"elm-ngx-animations.d.ts","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["OnInit","OnDestroy","EventEmitter","ElementRef","*","AfterContentInit"]},"imports":["@angular/core"],"modules":{"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/fade-in.directive.d.ts":{"code":"type FadeDirection = 'in' | 'out' | 'in-out';\ntype EasingFunction$3 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Fade In/Out Directive\n * Applies smooth fade animations to any element\n *\n * @example\n * <div ngxFadeIn [duration]=\"500\" [delay]=\"100\">Content</div>\n */\ndeclare class FadeInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$3;\n    direction: FadeDirection;\n    triggerOnScroll: boolean;\n    threshold: number;\n    startOpacity: number;\n    endOpacity: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startOpacity when the element leaves the viewport\n     * so the animation can replay on the next entry.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<FadeInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<FadeInDirective, \"[ngxFadeIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"startOpacity\": { \"alias\": \"startOpacity\"; \"required\": false; }; \"endOpacity\": { \"alias\": \"endOpacity\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":2072,"removedExports":[],"renderedExports":["FadeDirection","EasingFunction","FadeInDirective"],"renderedLength":1940},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/slide-in.directive.d.ts":{"code":"type SlideDirection = 'left' | 'right' | 'top' | 'bottom';\ntype EasingFunction$2 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Slide In Directive\n * Slides element from specified direction with RTL support\n *\n * @example\n * <div ngxSlideIn direction=\"left\" [duration]=\"500\">Content</div>\n */\ndeclare class SlideInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$2;\n    direction: SlideDirection;\n    distance: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    rtl: boolean;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial offset + opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    private initialTransform;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<SlideInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<SlideInDirective, \"[ngxSlideIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":2126,"removedExports":[],"renderedExports":["SlideDirection","SlideInDirective"],"renderedLength":1990},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/scale-in.directive.d.ts":{"code":"type ScaleOrigin = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\ntype EasingFunction$1 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Scale In Directive\n * Scales element from specified origin point\n *\n * @example\n * <div ngxScaleIn [startScale]=\"0.5\" [duration]=\"500\">Content</div>\n */\ndeclare class ScaleInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$1;\n    startScale: number;\n    endScale: number;\n    origin: ScaleOrigin;\n    triggerOnScroll: boolean;\n    threshold: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startScale and opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getTransformOrigin;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScaleInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ScaleInDirective, \"[ngxScaleIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"startScale\": { \"alias\": \"startScale\"; \"required\": false; }; \"endScale\": { \"alias\": \"endScale\"; \"required\": false; }; \"origin\": { \"alias\": \"origin\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":2164,"removedExports":[],"renderedExports":["ScaleOrigin","ScaleInDirective"],"renderedLength":2028},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/rotate-in.directive.d.ts":{"code":"type RotateAxis = 'x' | 'y' | 'z';\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Rotate In Directive\n * Rotates element on specified axis\n *\n * @example\n * <div ngxRotateIn axis=\"y\" [degrees]=\"90\">Content</div>\n */\ndeclare class RotateInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction;\n    axis: RotateAxis;\n    degrees: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial rotated state with opacity 0 when the\n     * element leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    private initialTransform;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getRotateTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<RotateInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<RotateInDirective, \"[ngxRotateIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"axis\": { \"alias\": \"axis\"; \"required\": false; }; \"degrees\": { \"alias\": \"degrees\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":2004,"removedExports":[],"renderedExports":["RotateAxis","RotateInDirective"],"renderedLength":1864},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/parallax-scroll.directive.d.ts":{"code":"/**\n * Parallax Scroll Directive\n * Creates smooth parallax effect on scroll\n *\n * @example\n * <div ngxParallaxScroll [speed]=\"0.5\">Content</div>\n */\ndeclare class ParallaxScrollDirective implements OnInit, OnDestroy {\n    private el;\n    speed: number;\n    direction: 'vertical' | 'horizontal';\n    reverse: boolean;\n    private platformId;\n    private scrollHandler?;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private updateParallax;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ParallaxScrollDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ParallaxScrollDirective, \"[ngxParallaxScroll]\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"reverse\": { \"alias\": \"reverse\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":994,"removedExports":[],"renderedExports":["ParallaxScrollDirective"],"renderedLength":886},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/ripple-click.directive.d.ts":{"code":"/**\n * Ripple Click Directive\n * Creates Material Design-style ripple effect on click\n * Modern and performant implementation\n *\n * @example\n * <button ngxRippleClick [rippleColor]=\"'rgba(255, 255, 255, 0.5)'\">Click me</button>\n */\ndeclare class RippleClickDirective {\n    private el;\n    rippleColor: string;\n    rippleDuration: number;\n    rippleRadius: number;\n    centered: boolean;\n    private platformId;\n    private renderer;\n    constructor(el: ElementRef<HTMLElement>);\n    private setupHostElement;\n    onClick(event: MouseEvent): void;\n    private createRipple;\n    static …µfac: i0.…µ…µFactoryDeclaration<RippleClickDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<RippleClickDirective, \"[ngxRippleClick]\", never, { \"rippleColor\": { \"alias\": \"rippleColor\"; \"required\": false; }; \"rippleDuration\": { \"alias\": \"rippleDuration\"; \"required\": false; }; \"rippleRadius\": { \"alias\": \"rippleRadius\"; \"required\": false; }; \"centered\": { \"alias\": \"centered\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1117,"removedExports":[],"renderedExports":["RippleClickDirective"],"renderedLength":1028},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/bounce-in.directive.d.ts":{"code":"type BounceDirection = 'up' | 'down' | 'left' | 'right' | 'center';\n/**\n * Bounce In Directive\n * Creates a playful bounce effect when element appears\n *\n * @example\n * <div ngxBounceIn direction=\"up\" [duration]=\"800\">Bouncy content!</div>\n */\ndeclare class BounceInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    direction: BounceDirection;\n    distance: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setInitialState;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<BounceInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<BounceInDirective, \"[ngxBounceIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":1580,"removedExports":[],"renderedExports":["BounceDirection","BounceInDirective"],"renderedLength":1451},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/flip-in.directive.d.ts":{"code":"type FlipAxis = 'horizontal' | 'vertical' | 'diagonal';\n/**\n * Flip In Directive\n * Creates a 3D flip animation effect\n *\n * @example\n * <div ngxFlipIn axis=\"horizontal\" [duration]=\"600\">Flip me!</div>\n */\ndeclare class FlipInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    axis: FlipAxis;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<FlipInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<FlipInDirective, \"[ngxFlipIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"axis\": { \"alias\": \"axis\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":1404,"removedExports":[],"renderedExports":["FlipAxis","FlipInDirective"],"renderedLength":1275},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/shake.directive.d.ts":{"code":"type ShakeIntensity = 'soft' | 'medium' | 'hard';\n/**\n * Shake Directive\n * Creates a shake/wobble effect on interaction or programmatically\n *\n * @example\n * <div ngxShake [shakeOnHover]=\"true\" intensity=\"medium\">Shake on hover!</div>\n */\ndeclare class ShakeDirective {\n    private el;\n    intensity: ShakeIntensity;\n    duration: number;\n    shakeOnHover: boolean;\n    shakeOnClick: boolean;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onClick(): void;\n    private getShakeDistance;\n    shake(): void;\n    private startContinuousShake;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ShakeDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ShakeDirective, \"[ngxShake]\", never, { \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"shakeOnHover\": { \"alias\": \"shakeOnHover\"; \"required\": false; }; \"shakeOnClick\": { \"alias\": \"shakeOnClick\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1277,"removedExports":[],"renderedExports":["ShakeIntensity","ShakeDirective"],"renderedLength":1181},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/pulse.directive.d.ts":{"code":"/**\n * Pulse Directive\n * Creates a continuous pulsing/heartbeat effect\n *\n * @example\n * <div ngxPulse [speed]=\"1000\" [scale]=\"1.1\">Pulsing content!</div>\n */\ndeclare class PulseDirective implements OnInit, OnDestroy {\n    private el;\n    speed: number;\n    scale: number;\n    continuous: boolean;\n    pauseOnHover: boolean;\n    private platformId;\n    private animation?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private startPulse;\n    private pause;\n    private resume;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<PulseDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<PulseDirective, \"[ngxPulse]\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"scale\": { \"alias\": \"scale\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1049,"removedExports":[],"renderedExports":["PulseDirective"],"renderedLength":941},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/glitch.directive.d.ts":{"code":"/**\n * Glitch Directive\n * Creates a cool glitch/distortion effect\n *\n * @example\n * <div ngxGlitch [intensity]=\"5\" [speed]=\"3000\">Glitchy text!</div>\n */\ndeclare class GlitchDirective implements OnInit, OnDestroy {\n    private el;\n    intensity: number;\n    speed: number;\n    duration: number;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private startGlitching;\n    private glitch;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<GlitchDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<GlitchDirective, \"[ngxGlitch]\", never, { \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1033,"removedExports":[],"renderedExports":["GlitchDirective"],"renderedLength":925},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/zoom-in.directive.d.ts":{"code":"type ZoomStyle = 'smooth' | 'bounce' | 'elastic';\n/**\n * Zoom In Directive\n * Creates various zoom-in effects with different styles\n *\n * @example\n * <div ngxZoomIn style=\"bounce\" [intensity]=\"1.5\">Zoom content!</div>\n */\ndeclare class ZoomInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    style: ZoomStyle;\n    intensity: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupIntersectionObserver;\n    private animate;\n    private getKeyframes;\n    private getEasing;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ZoomInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ZoomInDirective, \"[ngxZoomIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"style\": { \"alias\": \"style\"; \"required\": false; }; \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}","originalLength":1522,"removedExports":[],"renderedExports":["ZoomStyle","ZoomInDirective"],"renderedLength":1393},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/hover-lift.directive.d.ts":{"code":"/**\n * Hover Lift Directive\n * Adds a subtle scale + shadow effect on hover.\n *\n * Useful for cards, buttons, and tiles.\n *\n * @example\n * <div ngxHoverLift [liftScale]=\"1.03\" [shadowStrength]=\"0.25\">Card</div>\n */\ndeclare class HoverLiftDirective implements OnInit {\n    private el;\n    /** Scale factor on hover (1 = no scale) */\n    liftScale: number;\n    /** Shadow strength 0‚Äì1 */\n    shadowStrength: number;\n    /** Transition duration in ms */\n    hoverDuration: number;\n    private platformId;\n    private originalTransform;\n    private originalBoxShadow;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onEnter(): void;\n    onLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<HoverLiftDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<HoverLiftDirective, \"[ngxHoverLift]\", never, { \"liftScale\": { \"alias\": \"liftScale\"; \"required\": false; }; \"shadowStrength\": { \"alias\": \"shadowStrength\"; \"required\": false; }; \"hoverDuration\": { \"alias\": \"hoverDuration\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1161,"removedExports":[],"renderedExports":["HoverLiftDirective"],"renderedLength":1064},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/count-up.directive.d.ts":{"code":"/**\n * Count Up Directive\n * Animates numbers from a start value to an end value.\n *\n * @example\n * <span ngxCountUp [end]=\"2500\" [duration]=\"1200\"></span>\n */\ndeclare class CountUpDirective implements OnInit, OnDestroy {\n    private el;\n    /** Starting value */\n    start: number;\n    /** Final value */\n    end: number;\n    /** Duration in ms */\n    duration: number;\n    /** Decimal places */\n    decimals: number;\n    /** Optional prefix (e.g. '$') */\n    prefix: string;\n    /** Optional suffix (e.g. '%') */\n    suffix: string;\n    /** Whether to animate on scroll into view */\n    triggerOnScroll: boolean;\n    /** Intersection threshold */\n    threshold: number;\n    private platformId;\n    private observer?;\n    private startTime;\n    private rafId?;\n    private hasAnimated;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupObserver;\n    private startAnimation;\n    private animate;\n    private render;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<CountUpDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<CountUpDirective, \"[ngxCountUp]\", never, { \"start\": { \"alias\": \"start\"; \"required\": false; }; \"end\": { \"alias\": \"end\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"decimals\": { \"alias\": \"decimals\"; \"required\": false; }; \"prefix\": { \"alias\": \"prefix\"; \"required\": false; }; \"suffix\": { \"alias\": \"suffix\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1721,"removedExports":[],"renderedExports":["CountUpDirective"],"renderedLength":1613},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/magnetic.directive.d.ts":{"code":"/**\n * Magnetic Directive\n * Creates a magnetic pull effect on hover (GSAP-inspired)\n * Elements follow the mouse cursor when hovering\n *\n * @example\n * <button ngxMagnetic [strength]=\"0.5\">Magnetic Button</button>\n */\ndeclare class MagneticDirective implements OnInit {\n    private el;\n    strength: number;\n    speed: number;\n    private platformId;\n    private rect?;\n    private isHovering;\n    private currentX;\n    private currentY;\n    private targetX;\n    private targetY;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onMouseLeave(): void;\n    onMouseMove(event: MouseEvent): void;\n    private animate;\n    static …µfac: i0.…µ…µFactoryDeclaration<MagneticDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<MagneticDirective, \"[ngxMagnetic]\", never, { \"strength\": { \"alias\": \"strength\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1081,"removedExports":[],"renderedExports":["MagneticDirective"],"renderedLength":984},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/tilt-3d.directive.d.ts":{"code":"/**\n * 3D Tilt Directive\n * Creates a 3D tilt effect following mouse movement (GSAP-inspired)\n * Perfect for cards and interactive elements\n *\n * @example\n * <div ngxTilt3d [maxTilt]=\"15\" [perspective]=\"1000\">3D Card</div>\n */\ndeclare class Tilt3dDirective implements OnInit {\n    private el;\n    maxTilt: number;\n    perspective: number;\n    scale: number;\n    speed: number;\n    glare: boolean;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private addGlareEffect;\n    onMouseEnter(): void;\n    onMouseMove(event: MouseEvent): void;\n    onMouseLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<Tilt3dDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<Tilt3dDirective, \"[ngxTilt3d]\", never, { \"maxTilt\": { \"alias\": \"maxTilt\"; \"required\": false; }; \"perspective\": { \"alias\": \"perspective\"; \"required\": false; }; \"scale\": { \"alias\": \"scale\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"glare\": { \"alias\": \"glare\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1165,"removedExports":[],"renderedExports":["Tilt3dDirective"],"renderedLength":1068},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/scroll-progress.directive.d.ts":{"code":"/**\n * Scroll Progress Directive\n * Animates elements based on scroll progress (GSAP ScrollTrigger-inspired)\n * Perfect for parallax and scroll-driven animations\n *\n * @example\n * <div ngxScrollProgress [startProgress]=\"0\" [endProgress]=\"100\">Content</div>\n */\ndeclare class ScrollProgressDirective implements OnInit, OnDestroy {\n    private el;\n    startProgress: number;\n    endProgress: number;\n    animateOpacity: boolean;\n    animateScale: boolean;\n    animateX: number;\n    animateY: number;\n    animateRotate: number;\n    progressChange: EventEmitter<number>;\n    private platformId;\n    private scrollHandler?;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private updateProgress;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScrollProgressDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ScrollProgressDirective, \"[ngxScrollProgress]\", never, { \"startProgress\": { \"alias\": \"startProgress\"; \"required\": false; }; \"endProgress\": { \"alias\": \"endProgress\"; \"required\": false; }; \"animateOpacity\": { \"alias\": \"animateOpacity\"; \"required\": false; }; \"animateScale\": { \"alias\": \"animateScale\"; \"required\": false; }; \"animateX\": { \"alias\": \"animateX\"; \"required\": false; }; \"animateY\": { \"alias\": \"animateY\"; \"required\": false; }; \"animateRotate\": { \"alias\": \"animateRotate\"; \"required\": false; }; }, { \"progressChange\": \"progressChange\"; }, never, never, true, never>;\n}","originalLength":1574,"removedExports":[],"renderedExports":["ScrollProgressDirective"],"renderedLength":1452},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/directives/morph.directive.d.ts":{"code":"/**\n * Morph Directive\n * Creates smooth morphing transitions between shapes (GSAP MorphSVG-inspired)\n * Works with border-radius to create organic shape changes\n *\n * @example\n * <div ngxMorph [morphOnHover]=\"true\">Morphing element</div>\n */\ndeclare class MorphDirective {\n    private el;\n    morphOnHover: boolean;\n    morphOnClick: boolean;\n    duration: number;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    private originalBorderRadius?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onMouseLeave(): void;\n    onClick(): void;\n    private morph;\n    private reset;\n    private getRandomShape;\n    private startContinuousMorph;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<MorphDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<MorphDirective, \"[ngxMorph]\", never, { \"morphOnHover\": { \"alias\": \"morphOnHover\"; \"required\": false; }; \"morphOnClick\": { \"alias\": \"morphOnClick\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1261,"removedExports":[],"renderedExports":["MorphDirective"],"renderedLength":1172},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/scroll-reveal/scroll-reveal.component.d.ts":{"code":"type RevealAnimation = 'fade' | 'slide-up' | 'slide-down' | 'slide-left' | 'slide-right' | 'scale' | 'rotate';\n/**\n * Scroll Reveal Component\n * Reveals content when it comes into viewport\n *\n * @example\n * <ngx-scroll-reveal animation=\"slide-up\">\n *   <h1>Content to reveal</h1>\n * </ngx-scroll-reveal>\n */\ndeclare class ScrollRevealComponent implements OnInit, OnDestroy {\n    private el;\n    animation: RevealAnimation;\n    duration: number;\n    delay: number;\n    threshold: number;\n    once: boolean;\n    distance: number;\n    revealed: EventEmitter<void>;\n    hidden: EventEmitter<void>;\n    container: ElementRef<HTMLElement>;\n    protected isRevealed: i0.WritableSignal<boolean>;\n    private observer?;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScrollRevealComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ScrollRevealComponent, \"ngx-scroll-reveal\", never, { \"animation\": { \"alias\": \"animation\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"once\": { \"alias\": \"once\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; }, { \"revealed\": \"revealed\"; \"hidden\": \"hidden\"; }, never, [\"*\"], true, never>;\n}","originalLength":1671,"removedExports":[],"renderedExports":["RevealAnimation","ScrollRevealComponent"],"renderedLength":1521},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/stagger-list/stagger-list.component.d.ts":{"code":"type StaggerAnimation = 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate';\n/**\n * Stagger List Component\n * Animates child elements with staggered delays\n *\n * @example\n * <ngx-stagger-list animation=\"slide-up\" [staggerDelay]=\"100\">\n *   <div class=\"item\">Item 1</div>\n *   <div class=\"item\">Item 2</div>\n *   <div class=\"item\">Item 3</div>\n * </ngx-stagger-list>\n */\ndeclare class StaggerListComponent implements OnInit, AfterContentInit {\n    private el;\n    animation: StaggerAnimation;\n    duration: number;\n    staggerDelay: number;\n    initialDelay: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    reverse: boolean;\n    animationStart: EventEmitter<number>;\n    animationComplete: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    private setupIntersectionObserver;\n    private animateChildren;\n    private setInitialState;\n    private animateElement;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<StaggerListComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<StaggerListComponent, \"ngx-stagger-list\", never, { \"animation\": { \"alias\": \"animation\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"staggerDelay\": { \"alias\": \"staggerDelay\"; \"required\": false; }; \"initialDelay\": { \"alias\": \"initialDelay\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"reverse\": { \"alias\": \"reverse\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationComplete\": \"animationComplete\"; }, never, [\"*\"], true, never>;\n}","originalLength":1899,"removedExports":[],"renderedExports":["StaggerAnimation","StaggerListComponent"],"renderedLength":1763},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/typewriter/typewriter.component.d.ts":{"code":"/**\n * Typewriter Component\n * Types out text character by character with RTL support\n *\n * @example\n * <ngx-typewriter [text]=\"'Hello World!'\" [speed]=\"50\"></ngx-typewriter>\n */\ndeclare class TypewriterComponent implements OnInit, OnDestroy {\n    text: string;\n    speed: number;\n    delay: number;\n    showCursor: boolean;\n    loop: boolean;\n    deleteSpeed: number;\n    pauseBeforeDelete: number;\n    rtl: boolean;\n    typingStart: EventEmitter<void>;\n    typingComplete: EventEmitter<void>;\n    deletingStart: EventEmitter<void>;\n    deletingComplete: EventEmitter<void>;\n    protected displayedText: i0.WritableSignal<string>;\n    private currentIndex;\n    private isDeleting;\n    private timeoutId?;\n    private platformId;\n    constructor();\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    private start;\n    private type;\n    private restart;\n    private stop;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<TypewriterComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<TypewriterComponent, \"ngx-typewriter\", never, { \"text\": { \"alias\": \"text\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"showCursor\": { \"alias\": \"showCursor\"; \"required\": false; }; \"loop\": { \"alias\": \"loop\"; \"required\": false; }; \"deleteSpeed\": { \"alias\": \"deleteSpeed\"; \"required\": false; }; \"pauseBeforeDelete\": { \"alias\": \"pauseBeforeDelete\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; }, { \"typingStart\": \"typingStart\"; \"typingComplete\": \"typingComplete\"; \"deletingStart\": \"deletingStart\"; \"deletingComplete\": \"deletingComplete\"; }, never, never, true, never>;\n}","originalLength":1827,"removedExports":[],"renderedExports":["TypewriterComponent"],"renderedLength":1696},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/marquee/marquee.component.d.ts":{"code":"type MarqueeDirection = 'left' | 'right' | 'up' | 'down';\n/**\n * Marquee Component\n * Continuous scrolling text/content with RTL support\n *\n * @example\n * <ngx-marquee [speed]=\"50\" direction=\"left\">\n *   Scrolling text content here...\n * </ngx-marquee>\n */\ndeclare class MarqueeComponent implements OnInit {\n    speed: number;\n    direction: MarqueeDirection;\n    pauseOnHover: boolean;\n    rtl: boolean;\n    gap: number;\n    protected isVertical: i0.WritableSignal<boolean>;\n    private platformId;\n    ngOnInit(): void;\n    protected animationStyle(): string;\n    private calculateDuration;\n    private getAnimationName;\n    static …µfac: i0.…µ…µFactoryDeclaration<MarqueeComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<MarqueeComponent, \"ngx-marquee\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; \"gap\": { \"alias\": \"gap\"; \"required\": false; }; }, {}, never, [\"*\", \"*\"], true, never>;\n}","originalLength":1198,"removedExports":[],"renderedExports":["MarqueeDirection","MarqueeComponent"],"renderedLength":1085},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/orbit-animation/orbit-animation.component.d.ts":{"code":"type OrbitDirection = 'clockwise' | 'counterclockwise';\n/**\n * Orbit Animation Component\n * Rotates content in circular orbit around center point\n *\n * @example\n * <ngx-orbit-animation [radius]=\"100\" [speed]=\"5\">\n *   <div class=\"planet\">üåç</div>\n * </ngx-orbit-animation>\n */\ndeclare class OrbitAnimationComponent implements OnInit {\n    radius: number;\n    speed: number;\n    direction: OrbitDirection;\n    startAngle: number;\n    pauseOnHover: boolean;\n    showPath: boolean;\n    private platformId;\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    protected orbitPathStyle(): string;\n    protected orbitItemStyle(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<OrbitAnimationComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<OrbitAnimationComponent, \"ngx-orbit-animation\", never, { \"radius\": { \"alias\": \"radius\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"startAngle\": { \"alias\": \"startAngle\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; \"showPath\": { \"alias\": \"showPath\"; \"required\": false; }; }, {}, never, [\"*\"], true, never>;\n}","originalLength":1293,"removedExports":[],"renderedExports":["OrbitDirection","OrbitAnimationComponent"],"renderedLength":1201},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/confetti/confetti.component.d.ts":{"code":"/**\n * Confetti Component\n * Creates a celebratory confetti explosion effect\n *\n * @example\n * <ngx-confetti [particleCount]=\"100\" [duration]=\"3000\"></ngx-confetti>\n */\ndeclare class ConfettiComponent implements OnInit, OnDestroy {\n    particleCount: number;\n    duration: number;\n    colors: string[];\n    autoStart: boolean;\n    canvas: ElementRef<HTMLCanvasElement>;\n    protected width: i0.WritableSignal<number>;\n    protected height: i0.WritableSignal<number>;\n    private platformId;\n    private ctx?;\n    private particles;\n    private animationId?;\n    private startTime?;\n    ngOnInit(): void;\n    private onResize;\n    start(): void;\n    private createParticles;\n    private animate;\n    stop(): void;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ConfettiComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ConfettiComponent, \"ngx-confetti\", never, { \"particleCount\": { \"alias\": \"particleCount\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"colors\": { \"alias\": \"colors\"; \"required\": false; }; \"autoStart\": { \"alias\": \"autoStart\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1315,"removedExports":[],"renderedExports":["ConfettiComponent"],"renderedLength":1165},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/text-scramble/text-scramble.component.d.ts":{"code":"/**\n * Text Scramble Component\n * Creates a cool text scrambling effect (GSAP/Matrix-inspired)\n * Text appears to decode/unscramble character by character\n *\n * @example\n * <ngx-text-scramble [text]=\"'Hello World'\" [speed]=\"50\"></ngx-text-scramble>\n */\ndeclare class TextScrambleComponent implements OnInit {\n    text: string;\n    speed: number;\n    scrambleChars: string;\n    delay: number;\n    customClass: string;\n    complete: EventEmitter<void>;\n    protected displayedText: i0.WritableSignal<string>;\n    private platformId;\n    private frame;\n    private queue;\n    private rafId?;\n    ngOnInit(): void;\n    private scramble;\n    private update;\n    private randomChar;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<TextScrambleComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<TextScrambleComponent, \"ngx-text-scramble\", never, { \"text\": { \"alias\": \"text\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"scrambleChars\": { \"alias\": \"scrambleChars\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"customClass\": { \"alias\": \"customClass\"; \"required\": false; }; }, { \"complete\": \"complete\"; }, never, never, true, never>;\n}","originalLength":1332,"removedExports":[],"renderedExports":["TextScrambleComponent"],"renderedLength":1212},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/mouse-follower/mouse-follower.component.d.ts":{"code":"/**\n * Mouse Follower Component\n * Creates a custom cursor that follows the mouse (GSAP-inspired)\n * Adds a premium feel to any website\n *\n * @example\n * <ngx-mouse-follower [size]=\"20\" [color]=\"'#667eea'\"></ngx-mouse-follower>\n */\ndeclare class MouseFollowerComponent implements OnInit, OnDestroy {\n    size: number;\n    dotSize: number;\n    color: string;\n    dotColor: string;\n    speed: number;\n    protected transform: i0.WritableSignal<string>;\n    protected dotTransform: i0.WritableSignal<string>;\n    protected opacity: i0.WritableSignal<number>;\n    private platformId;\n    private mouseX;\n    private mouseY;\n    private currentX;\n    private currentY;\n    private dotX;\n    private dotY;\n    private rafId?;\n    private mouseMoveHandler?;\n    ngOnInit(): void;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<MouseFollowerComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<MouseFollowerComponent, \"ngx-mouse-follower\", never, { \"size\": { \"alias\": \"size\"; \"required\": false; }; \"dotSize\": { \"alias\": \"dotSize\"; \"required\": false; }; \"color\": { \"alias\": \"color\"; \"required\": false; }; \"dotColor\": { \"alias\": \"dotColor\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1448,"removedExports":[],"renderedExports":["MouseFollowerComponent"],"renderedLength":1289},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/profile-card/profile-card.component.d.ts":{"code":"interface ProfileCardData {\n    id?: string | number;\n    name: string;\n    username: string;\n    jobTitle: string;\n    gradient: string;\n    icon?: string;\n    iconSvg?: string;\n    stats?: {\n        documents?: number;\n        views?: number;\n        links?: number;\n    };\n}\n/**\n * Profile Card Component\n * Creates an interactive profile card with gradient background and hover effects\n * Perfect for team showcases, portfolios, and user grids\n *\n * @example\n * <ngx-profile-card\n *   [name]=\"'ÿ≥ÿßÿ±ÿ© ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä'\"\n *   [username]=\"'sara_zahrani@'\"\n *   [jobTitle]=\"'ÿπÿßŸÑŸÖÿ© ÿ®ŸäÿßŸÜÿßÿ™'\"\n *   [gradient]=\"'linear-gradient(135deg, #FF5D36, #763CBC)'\"\n *   icon=\"üìä\">\n * </ngx-profile-card>\n */\ndeclare class ProfileCardComponent implements OnInit {\n    name: string;\n    username: string;\n    jobTitle: string;\n    gradient: string;\n    icon: string;\n    iconSvg?: string;\n    stats?: {\n        documents?: number;\n        views?: number;\n        links?: number;\n    };\n    showStats: boolean;\n    enableTilt: boolean;\n    enableMagnetic: boolean;\n    magneticStrength: number;\n    tiltMax: number;\n    tiltGlare: boolean;\n    private platformId;\n    ngOnInit(): void;\n    get cardClasses(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<ProfileCardComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ProfileCardComponent, \"ngx-profile-card\", never, { \"name\": { \"alias\": \"name\"; \"required\": false; }; \"username\": { \"alias\": \"username\"; \"required\": false; }; \"jobTitle\": { \"alias\": \"jobTitle\"; \"required\": false; }; \"gradient\": { \"alias\": \"gradient\"; \"required\": false; }; \"icon\": { \"alias\": \"icon\"; \"required\": false; }; \"iconSvg\": { \"alias\": \"iconSvg\"; \"required\": false; }; \"stats\": { \"alias\": \"stats\"; \"required\": false; }; \"showStats\": { \"alias\": \"showStats\"; \"required\": false; }; \"enableTilt\": { \"alias\": \"enableTilt\"; \"required\": false; }; \"enableMagnetic\": { \"alias\": \"enableMagnetic\"; \"required\": false; }; \"magneticStrength\": { \"alias\": \"magneticStrength\"; \"required\": false; }; \"tiltMax\": { \"alias\": \"tiltMax\"; \"required\": false; }; \"tiltGlare\": { \"alias\": \"tiltGlare\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":2236,"removedExports":[],"renderedExports":["ProfileCardData","ProfileCardComponent"],"renderedLength":2144},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/profile-grid/profile-grid.component.d.ts":{"code":"/**\n * Profile Grid Component\n * Displays a grid of profile cards with stagger animations\n * Perfect for team showcases, user directories, and portfolio grids\n *\n * @example\n * <ngx-profile-grid\n *   [profiles]=\"profileData\"\n *   [columns]=\"4\"\n *   [staggerDelay]=\"100\">\n * </ngx-profile-grid>\n */\ndeclare class ProfileGridComponent implements OnInit {\n    profiles: ProfileCardData[];\n    columns: number;\n    staggerDelay: number;\n    staggerAnimation: 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate';\n    enableStagger: boolean;\n    enableScrollReveal: boolean;\n    gap: number;\n    cardHeight: string;\n    private platformId;\n    ngOnInit(): void;\n    get gridStyle(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<ProfileGridComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ProfileGridComponent, \"ngx-profile-grid\", never, { \"profiles\": { \"alias\": \"profiles\"; \"required\": false; }; \"columns\": { \"alias\": \"columns\"; \"required\": false; }; \"staggerDelay\": { \"alias\": \"staggerDelay\"; \"required\": false; }; \"staggerAnimation\": { \"alias\": \"staggerAnimation\"; \"required\": false; }; \"enableStagger\": { \"alias\": \"enableStagger\"; \"required\": false; }; \"enableScrollReveal\": { \"alias\": \"enableScrollReveal\"; \"required\": false; }; \"gap\": { \"alias\": \"gap\"; \"required\": false; }; \"cardHeight\": { \"alias\": \"cardHeight\"; \"required\": false; }; }, {}, never, never, true, never>;\n}","originalLength":1551,"removedExports":[],"renderedExports":["ProfileGridComponent"],"renderedLength":1392},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/components/glass-card/glass-card.component.d.ts":{"code":"declare class GlassCardComponent {\n    /** Slightly larger radius for very rounded cards */\n    borderRadius: string;\n    /** Hover lift effect */\n    hover: boolean;\n    /** Stronger shadow preset */\n    elevated: boolean;\n    /** Accent border using the primary color */\n    accent: boolean;\n    get hostRadius(): string;\n    get hoverClass(): boolean;\n    get elevatedClass(): boolean;\n    get accentClass(): boolean;\n    transform: string | null;\n    onMouseMove(event: MouseEvent): void;\n    onMouseLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<GlassCardComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<GlassCardComponent, \"ngx-glass-card\", never, { \"borderRadius\": { \"alias\": \"borderRadius\"; \"required\": false; }; \"hover\": { \"alias\": \"hover\"; \"required\": false; }; \"elevated\": { \"alias\": \"elevated\"; \"required\": false; }; \"accent\": { \"alias\": \"accent\"; \"required\": false; }; }, {}, never, [\"*\"], true, never>;\n}","originalLength":985,"removedExports":[],"renderedExports":["GlassCardComponent"],"renderedLength":940},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/services/timeline.service.d.ts":{"code":"interface TimelineStep {\n    element: HTMLElement | ElementRef<HTMLElement>;\n    properties: Partial<CSSStyleDeclaration>;\n    duration: number;\n    delay?: number;\n    easing?: string;\n}\ninterface TimelineOptions {\n    repeat?: boolean;\n    repeatDelay?: number;\n    onComplete?: () => void;\n    onStart?: () => void;\n    onRepeat?: () => void;\n}\n/**\n * Timeline Service\n * Chain multiple animations in sequence or parallel\n * Similar to GSAP Timeline but Angular-friendly\n *\n * @example\n * const timeline = this.timelineService.create();\n * timeline\n *   .to(element1, { opacity: '1', transform: 'translateX(0)' }, 500)\n *   .to(element2, { opacity: '1' }, 300, 100)\n *   .play();\n */\ndeclare class TimelineService {\n    createTimeline(options?: TimelineOptions): Timeline;\n    create(options?: TimelineOptions): Timeline;\n    static …µfac: i0.…µ…µFactoryDeclaration<TimelineService, never>;\n    static …µprov: i0.…µ…µInjectableDeclaration<TimelineService>;\n}\ndeclare class Timeline {\n    private steps;\n    private parallelSteps;\n    private currentStep;\n    private isPlaying;\n    private isPaused;\n    private options;\n    private currentTimeouts;\n    constructor(options?: TimelineOptions);\n    /**\n     * Add animation step to timeline\n     */\n    to(element: HTMLElement | ElementRef<HTMLElement>, properties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add animation step that starts from current properties\n     */\n    from(element: HTMLElement | ElementRef<HTMLElement>, properties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add animation step relative to current state\n     */\n    fromTo(element: HTMLElement | ElementRef<HTMLElement>, fromProperties: Partial<CSSStyleDeclaration>, toProperties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add multiple animations to run in parallel\n     */\n    parallel(callback: (timeline: Timeline) => void): this;\n    /**\n     * Add a delay in the timeline\n     */\n    wait(duration: number): this;\n    /**\n     * Add a label for positioning\n     */\n    addLabel(label: string): this;\n    /**\n     * Play the timeline\n     */\n    play(): Promise<void>;\n    /**\n     * Pause the timeline\n     */\n    pause(): this;\n    /**\n     * Resume the timeline\n     */\n    resume(): this;\n    /**\n     * Stop and reset the timeline\n     */\n    stop(): this;\n    /**\n     * Restart the timeline from beginning\n     */\n    restart(): Promise<void>;\n    /**\n     * Reverse the timeline\n     */\n    reverse(): this;\n    private playSteps;\n    private playParallelSteps;\n    private animateStep;\n    private onComplete;\n    private clearTimeouts;\n}","originalLength":2863,"removedExports":[],"renderedExports":["TimelineStep","TimelineOptions","TimelineService","Timeline"],"renderedLength":2753},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/lib/services/rtl-language.service.d.ts":{"code":"/**\n * RTL & Language Service\n * Provides runtime toggle between LTR/RTL and EN/AR.\n *\n * This is intentionally simple ‚Äì you can use it or plug it into your own i18n layer.\n */\ndeclare class RtlLanguageService {\n    private platformId;\n    /** Current locale: 'en' or 'ar'. Default 'en'. */\n    readonly locale: i0.WritableSignal<\"en\" | \"ar\">;\n    /** Text direction derived from locale. */\n    readonly direction: i0.Signal<\"rtl\" | \"ltr\">;\n    /** True when current direction is RTL. */\n    readonly isRtl: i0.Signal<boolean>;\n    constructor();\n    setLocale(locale: 'en' | 'ar'): void;\n    toggleLocale(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<RtlLanguageService, never>;\n    static …µprov: i0.…µ…µInjectableDeclaration<RtlLanguageService>;\n}","originalLength":859,"removedExports":[],"renderedExports":["RtlLanguageService"],"renderedLength":751},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-typings/elm-ngx-animations.d.ts":{"code":null,"originalLength":123,"removedExports":[],"renderedExports":[],"renderedLength":0}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { OnInit, OnDestroy, EventEmitter, ElementRef, AfterContentInit } from '@angular/core';\n\ntype FadeDirection = 'in' | 'out' | 'in-out';\ntype EasingFunction$3 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Fade In/Out Directive\n * Applies smooth fade animations to any element\n *\n * @example\n * <div ngxFadeIn [duration]=\"500\" [delay]=\"100\">Content</div>\n */\ndeclare class FadeInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$3;\n    direction: FadeDirection;\n    triggerOnScroll: boolean;\n    threshold: number;\n    startOpacity: number;\n    endOpacity: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startOpacity when the element leaves the viewport\n     * so the animation can replay on the next entry.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<FadeInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<FadeInDirective, \"[ngxFadeIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"startOpacity\": { \"alias\": \"startOpacity\"; \"required\": false; }; \"endOpacity\": { \"alias\": \"endOpacity\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\ntype SlideDirection = 'left' | 'right' | 'top' | 'bottom';\ntype EasingFunction$2 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Slide In Directive\n * Slides element from specified direction with RTL support\n *\n * @example\n * <div ngxSlideIn direction=\"left\" [duration]=\"500\">Content</div>\n */\ndeclare class SlideInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$2;\n    direction: SlideDirection;\n    distance: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    rtl: boolean;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial offset + opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    private initialTransform;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<SlideInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<SlideInDirective, \"[ngxSlideIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\ntype ScaleOrigin = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\ntype EasingFunction$1 = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Scale In Directive\n * Scales element from specified origin point\n *\n * @example\n * <div ngxScaleIn [startScale]=\"0.5\" [duration]=\"500\">Content</div>\n */\ndeclare class ScaleInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction$1;\n    startScale: number;\n    endScale: number;\n    origin: ScaleOrigin;\n    triggerOnScroll: boolean;\n    threshold: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startScale and opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getTransformOrigin;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScaleInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ScaleInDirective, \"[ngxScaleIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"startScale\": { \"alias\": \"startScale\"; \"required\": false; }; \"endScale\": { \"alias\": \"endScale\"; \"required\": false; }; \"origin\": { \"alias\": \"origin\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\ntype RotateAxis = 'x' | 'y' | 'z';\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\n/**\n * Rotate In Directive\n * Rotates element on specified axis\n *\n * @example\n * <div ngxRotateIn axis=\"y\" [degrees]=\"90\">Content</div>\n */\ndeclare class RotateInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    easing: EasingFunction;\n    axis: RotateAxis;\n    degrees: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial rotated state with opacity 0 when the\n     * element leaves the viewport so the animation can replay.\n     */\n    resetOnExit: boolean;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    private initialTransform;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getRotateTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<RotateInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<RotateInDirective, \"[ngxRotateIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"easing\": { \"alias\": \"easing\"; \"required\": false; }; \"axis\": { \"alias\": \"axis\"; \"required\": false; }; \"degrees\": { \"alias\": \"degrees\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"resetOnExit\": { \"alias\": \"resetOnExit\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\n/**\n * Parallax Scroll Directive\n * Creates smooth parallax effect on scroll\n *\n * @example\n * <div ngxParallaxScroll [speed]=\"0.5\">Content</div>\n */\ndeclare class ParallaxScrollDirective implements OnInit, OnDestroy {\n    private el;\n    speed: number;\n    direction: 'vertical' | 'horizontal';\n    reverse: boolean;\n    private platformId;\n    private scrollHandler?;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private updateParallax;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ParallaxScrollDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ParallaxScrollDirective, \"[ngxParallaxScroll]\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"reverse\": { \"alias\": \"reverse\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Ripple Click Directive\n * Creates Material Design-style ripple effect on click\n * Modern and performant implementation\n *\n * @example\n * <button ngxRippleClick [rippleColor]=\"'rgba(255, 255, 255, 0.5)'\">Click me</button>\n */\ndeclare class RippleClickDirective {\n    private el;\n    rippleColor: string;\n    rippleDuration: number;\n    rippleRadius: number;\n    centered: boolean;\n    private platformId;\n    private renderer;\n    constructor(el: ElementRef<HTMLElement>);\n    private setupHostElement;\n    onClick(event: MouseEvent): void;\n    private createRipple;\n    static …µfac: i0.…µ…µFactoryDeclaration<RippleClickDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<RippleClickDirective, \"[ngxRippleClick]\", never, { \"rippleColor\": { \"alias\": \"rippleColor\"; \"required\": false; }; \"rippleDuration\": { \"alias\": \"rippleDuration\"; \"required\": false; }; \"rippleRadius\": { \"alias\": \"rippleRadius\"; \"required\": false; }; \"centered\": { \"alias\": \"centered\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\ntype BounceDirection = 'up' | 'down' | 'left' | 'right' | 'center';\n/**\n * Bounce In Directive\n * Creates a playful bounce effect when element appears\n *\n * @example\n * <div ngxBounceIn direction=\"up\" [duration]=\"800\">Bouncy content!</div>\n */\ndeclare class BounceInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    direction: BounceDirection;\n    distance: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setInitialState;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<BounceInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<BounceInDirective, \"[ngxBounceIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\ntype FlipAxis = 'horizontal' | 'vertical' | 'diagonal';\n/**\n * Flip In Directive\n * Creates a 3D flip animation effect\n *\n * @example\n * <div ngxFlipIn axis=\"horizontal\" [duration]=\"600\">Flip me!</div>\n */\ndeclare class FlipInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    axis: FlipAxis;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<FlipInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<FlipInDirective, \"[ngxFlipIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"axis\": { \"alias\": \"axis\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\ntype ShakeIntensity = 'soft' | 'medium' | 'hard';\n/**\n * Shake Directive\n * Creates a shake/wobble effect on interaction or programmatically\n *\n * @example\n * <div ngxShake [shakeOnHover]=\"true\" intensity=\"medium\">Shake on hover!</div>\n */\ndeclare class ShakeDirective {\n    private el;\n    intensity: ShakeIntensity;\n    duration: number;\n    shakeOnHover: boolean;\n    shakeOnClick: boolean;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onClick(): void;\n    private getShakeDistance;\n    shake(): void;\n    private startContinuousShake;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ShakeDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ShakeDirective, \"[ngxShake]\", never, { \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"shakeOnHover\": { \"alias\": \"shakeOnHover\"; \"required\": false; }; \"shakeOnClick\": { \"alias\": \"shakeOnClick\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Pulse Directive\n * Creates a continuous pulsing/heartbeat effect\n *\n * @example\n * <div ngxPulse [speed]=\"1000\" [scale]=\"1.1\">Pulsing content!</div>\n */\ndeclare class PulseDirective implements OnInit, OnDestroy {\n    private el;\n    speed: number;\n    scale: number;\n    continuous: boolean;\n    pauseOnHover: boolean;\n    private platformId;\n    private animation?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private startPulse;\n    private pause;\n    private resume;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<PulseDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<PulseDirective, \"[ngxPulse]\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"scale\": { \"alias\": \"scale\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Glitch Directive\n * Creates a cool glitch/distortion effect\n *\n * @example\n * <div ngxGlitch [intensity]=\"5\" [speed]=\"3000\">Glitchy text!</div>\n */\ndeclare class GlitchDirective implements OnInit, OnDestroy {\n    private el;\n    intensity: number;\n    speed: number;\n    duration: number;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private startGlitching;\n    private glitch;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<GlitchDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<GlitchDirective, \"[ngxGlitch]\", never, { \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\ntype ZoomStyle = 'smooth' | 'bounce' | 'elastic';\n/**\n * Zoom In Directive\n * Creates various zoom-in effects with different styles\n *\n * @example\n * <div ngxZoomIn style=\"bounce\" [intensity]=\"1.5\">Zoom content!</div>\n */\ndeclare class ZoomInDirective implements OnInit, OnDestroy {\n    private el;\n    duration: number;\n    delay: number;\n    style: ZoomStyle;\n    intensity: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    animationStart: EventEmitter<void>;\n    animationEnd: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupIntersectionObserver;\n    private animate;\n    private getKeyframes;\n    private getEasing;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ZoomInDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ZoomInDirective, \"[ngxZoomIn]\", never, { \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"style\": { \"alias\": \"style\"; \"required\": false; }; \"intensity\": { \"alias\": \"intensity\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationEnd\": \"animationEnd\"; }, never, never, true, never>;\n}\n\n/**\n * Hover Lift Directive\n * Adds a subtle scale + shadow effect on hover.\n *\n * Useful for cards, buttons, and tiles.\n *\n * @example\n * <div ngxHoverLift [liftScale]=\"1.03\" [shadowStrength]=\"0.25\">Card</div>\n */\ndeclare class HoverLiftDirective implements OnInit {\n    private el;\n    /** Scale factor on hover (1 = no scale) */\n    liftScale: number;\n    /** Shadow strength 0‚Äì1 */\n    shadowStrength: number;\n    /** Transition duration in ms */\n    hoverDuration: number;\n    private platformId;\n    private originalTransform;\n    private originalBoxShadow;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onEnter(): void;\n    onLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<HoverLiftDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<HoverLiftDirective, \"[ngxHoverLift]\", never, { \"liftScale\": { \"alias\": \"liftScale\"; \"required\": false; }; \"shadowStrength\": { \"alias\": \"shadowStrength\"; \"required\": false; }; \"hoverDuration\": { \"alias\": \"hoverDuration\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Count Up Directive\n * Animates numbers from a start value to an end value.\n *\n * @example\n * <span ngxCountUp [end]=\"2500\" [duration]=\"1200\"></span>\n */\ndeclare class CountUpDirective implements OnInit, OnDestroy {\n    private el;\n    /** Starting value */\n    start: number;\n    /** Final value */\n    end: number;\n    /** Duration in ms */\n    duration: number;\n    /** Decimal places */\n    decimals: number;\n    /** Optional prefix (e.g. '$') */\n    prefix: string;\n    /** Optional suffix (e.g. '%') */\n    suffix: string;\n    /** Whether to animate on scroll into view */\n    triggerOnScroll: boolean;\n    /** Intersection threshold */\n    threshold: number;\n    private platformId;\n    private observer?;\n    private startTime;\n    private rafId?;\n    private hasAnimated;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private setupObserver;\n    private startAnimation;\n    private animate;\n    private render;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<CountUpDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<CountUpDirective, \"[ngxCountUp]\", never, { \"start\": { \"alias\": \"start\"; \"required\": false; }; \"end\": { \"alias\": \"end\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"decimals\": { \"alias\": \"decimals\"; \"required\": false; }; \"prefix\": { \"alias\": \"prefix\"; \"required\": false; }; \"suffix\": { \"alias\": \"suffix\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Magnetic Directive\n * Creates a magnetic pull effect on hover (GSAP-inspired)\n * Elements follow the mouse cursor when hovering\n *\n * @example\n * <button ngxMagnetic [strength]=\"0.5\">Magnetic Button</button>\n */\ndeclare class MagneticDirective implements OnInit {\n    private el;\n    strength: number;\n    speed: number;\n    private platformId;\n    private rect?;\n    private isHovering;\n    private currentX;\n    private currentY;\n    private targetX;\n    private targetY;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onMouseLeave(): void;\n    onMouseMove(event: MouseEvent): void;\n    private animate;\n    static …µfac: i0.…µ…µFactoryDeclaration<MagneticDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<MagneticDirective, \"[ngxMagnetic]\", never, { \"strength\": { \"alias\": \"strength\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * 3D Tilt Directive\n * Creates a 3D tilt effect following mouse movement (GSAP-inspired)\n * Perfect for cards and interactive elements\n *\n * @example\n * <div ngxTilt3d [maxTilt]=\"15\" [perspective]=\"1000\">3D Card</div>\n */\ndeclare class Tilt3dDirective implements OnInit {\n    private el;\n    maxTilt: number;\n    perspective: number;\n    scale: number;\n    speed: number;\n    glare: boolean;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private addGlareEffect;\n    onMouseEnter(): void;\n    onMouseMove(event: MouseEvent): void;\n    onMouseLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<Tilt3dDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<Tilt3dDirective, \"[ngxTilt3d]\", never, { \"maxTilt\": { \"alias\": \"maxTilt\"; \"required\": false; }; \"perspective\": { \"alias\": \"perspective\"; \"required\": false; }; \"scale\": { \"alias\": \"scale\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"glare\": { \"alias\": \"glare\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Scroll Progress Directive\n * Animates elements based on scroll progress (GSAP ScrollTrigger-inspired)\n * Perfect for parallax and scroll-driven animations\n *\n * @example\n * <div ngxScrollProgress [startProgress]=\"0\" [endProgress]=\"100\">Content</div>\n */\ndeclare class ScrollProgressDirective implements OnInit, OnDestroy {\n    private el;\n    startProgress: number;\n    endProgress: number;\n    animateOpacity: boolean;\n    animateScale: boolean;\n    animateX: number;\n    animateY: number;\n    animateRotate: number;\n    progressChange: EventEmitter<number>;\n    private platformId;\n    private scrollHandler?;\n    private rafId?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    private updateProgress;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScrollProgressDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<ScrollProgressDirective, \"[ngxScrollProgress]\", never, { \"startProgress\": { \"alias\": \"startProgress\"; \"required\": false; }; \"endProgress\": { \"alias\": \"endProgress\"; \"required\": false; }; \"animateOpacity\": { \"alias\": \"animateOpacity\"; \"required\": false; }; \"animateScale\": { \"alias\": \"animateScale\"; \"required\": false; }; \"animateX\": { \"alias\": \"animateX\"; \"required\": false; }; \"animateY\": { \"alias\": \"animateY\"; \"required\": false; }; \"animateRotate\": { \"alias\": \"animateRotate\"; \"required\": false; }; }, { \"progressChange\": \"progressChange\"; }, never, never, true, never>;\n}\n\n/**\n * Morph Directive\n * Creates smooth morphing transitions between shapes (GSAP MorphSVG-inspired)\n * Works with border-radius to create organic shape changes\n *\n * @example\n * <div ngxMorph [morphOnHover]=\"true\">Morphing element</div>\n */\ndeclare class MorphDirective {\n    private el;\n    morphOnHover: boolean;\n    morphOnClick: boolean;\n    duration: number;\n    continuous: boolean;\n    private platformId;\n    private intervalId?;\n    private originalBorderRadius?;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    onMouseEnter(): void;\n    onMouseLeave(): void;\n    onClick(): void;\n    private morph;\n    private reset;\n    private getRandomShape;\n    private startContinuousMorph;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<MorphDirective, never>;\n    static …µdir: i0.…µ…µDirectiveDeclaration<MorphDirective, \"[ngxMorph]\", never, { \"morphOnHover\": { \"alias\": \"morphOnHover\"; \"required\": false; }; \"morphOnClick\": { \"alias\": \"morphOnClick\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"continuous\": { \"alias\": \"continuous\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\ntype RevealAnimation = 'fade' | 'slide-up' | 'slide-down' | 'slide-left' | 'slide-right' | 'scale' | 'rotate';\n/**\n * Scroll Reveal Component\n * Reveals content when it comes into viewport\n *\n * @example\n * <ngx-scroll-reveal animation=\"slide-up\">\n *   <h1>Content to reveal</h1>\n * </ngx-scroll-reveal>\n */\ndeclare class ScrollRevealComponent implements OnInit, OnDestroy {\n    private el;\n    animation: RevealAnimation;\n    duration: number;\n    delay: number;\n    threshold: number;\n    once: boolean;\n    distance: number;\n    revealed: EventEmitter<void>;\n    hidden: EventEmitter<void>;\n    container: ElementRef<HTMLElement>;\n    protected isRevealed: i0.WritableSignal<boolean>;\n    private observer?;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    private getInitialTransform;\n    private setupIntersectionObserver;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ScrollRevealComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ScrollRevealComponent, \"ngx-scroll-reveal\", never, { \"animation\": { \"alias\": \"animation\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"once\": { \"alias\": \"once\"; \"required\": false; }; \"distance\": { \"alias\": \"distance\"; \"required\": false; }; }, { \"revealed\": \"revealed\"; \"hidden\": \"hidden\"; }, never, [\"*\"], true, never>;\n}\n\ntype StaggerAnimation = 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate';\n/**\n * Stagger List Component\n * Animates child elements with staggered delays\n *\n * @example\n * <ngx-stagger-list animation=\"slide-up\" [staggerDelay]=\"100\">\n *   <div class=\"item\">Item 1</div>\n *   <div class=\"item\">Item 2</div>\n *   <div class=\"item\">Item 3</div>\n * </ngx-stagger-list>\n */\ndeclare class StaggerListComponent implements OnInit, AfterContentInit {\n    private el;\n    animation: StaggerAnimation;\n    duration: number;\n    staggerDelay: number;\n    initialDelay: number;\n    triggerOnScroll: boolean;\n    threshold: number;\n    reverse: boolean;\n    animationStart: EventEmitter<number>;\n    animationComplete: EventEmitter<void>;\n    private observer?;\n    private hasAnimated;\n    private platformId;\n    constructor(el: ElementRef<HTMLElement>);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    private setupIntersectionObserver;\n    private animateChildren;\n    private setInitialState;\n    private animateElement;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<StaggerListComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<StaggerListComponent, \"ngx-stagger-list\", never, { \"animation\": { \"alias\": \"animation\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"staggerDelay\": { \"alias\": \"staggerDelay\"; \"required\": false; }; \"initialDelay\": { \"alias\": \"initialDelay\"; \"required\": false; }; \"triggerOnScroll\": { \"alias\": \"triggerOnScroll\"; \"required\": false; }; \"threshold\": { \"alias\": \"threshold\"; \"required\": false; }; \"reverse\": { \"alias\": \"reverse\"; \"required\": false; }; }, { \"animationStart\": \"animationStart\"; \"animationComplete\": \"animationComplete\"; }, never, [\"*\"], true, never>;\n}\n\n/**\n * Typewriter Component\n * Types out text character by character with RTL support\n *\n * @example\n * <ngx-typewriter [text]=\"'Hello World!'\" [speed]=\"50\"></ngx-typewriter>\n */\ndeclare class TypewriterComponent implements OnInit, OnDestroy {\n    text: string;\n    speed: number;\n    delay: number;\n    showCursor: boolean;\n    loop: boolean;\n    deleteSpeed: number;\n    pauseBeforeDelete: number;\n    rtl: boolean;\n    typingStart: EventEmitter<void>;\n    typingComplete: EventEmitter<void>;\n    deletingStart: EventEmitter<void>;\n    deletingComplete: EventEmitter<void>;\n    protected displayedText: i0.WritableSignal<string>;\n    private currentIndex;\n    private isDeleting;\n    private timeoutId?;\n    private platformId;\n    constructor();\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    private start;\n    private type;\n    private restart;\n    private stop;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<TypewriterComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<TypewriterComponent, \"ngx-typewriter\", never, { \"text\": { \"alias\": \"text\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"showCursor\": { \"alias\": \"showCursor\"; \"required\": false; }; \"loop\": { \"alias\": \"loop\"; \"required\": false; }; \"deleteSpeed\": { \"alias\": \"deleteSpeed\"; \"required\": false; }; \"pauseBeforeDelete\": { \"alias\": \"pauseBeforeDelete\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; }, { \"typingStart\": \"typingStart\"; \"typingComplete\": \"typingComplete\"; \"deletingStart\": \"deletingStart\"; \"deletingComplete\": \"deletingComplete\"; }, never, never, true, never>;\n}\n\ntype MarqueeDirection = 'left' | 'right' | 'up' | 'down';\n/**\n * Marquee Component\n * Continuous scrolling text/content with RTL support\n *\n * @example\n * <ngx-marquee [speed]=\"50\" direction=\"left\">\n *   Scrolling text content here...\n * </ngx-marquee>\n */\ndeclare class MarqueeComponent implements OnInit {\n    speed: number;\n    direction: MarqueeDirection;\n    pauseOnHover: boolean;\n    rtl: boolean;\n    gap: number;\n    protected isVertical: i0.WritableSignal<boolean>;\n    private platformId;\n    ngOnInit(): void;\n    protected animationStyle(): string;\n    private calculateDuration;\n    private getAnimationName;\n    static …µfac: i0.…µ…µFactoryDeclaration<MarqueeComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<MarqueeComponent, \"ngx-marquee\", never, { \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; \"rtl\": { \"alias\": \"rtl\"; \"required\": false; }; \"gap\": { \"alias\": \"gap\"; \"required\": false; }; }, {}, never, [\"*\", \"*\"], true, never>;\n}\n\ntype OrbitDirection = 'clockwise' | 'counterclockwise';\n/**\n * Orbit Animation Component\n * Rotates content in circular orbit around center point\n *\n * @example\n * <ngx-orbit-animation [radius]=\"100\" [speed]=\"5\">\n *   <div class=\"planet\">üåç</div>\n * </ngx-orbit-animation>\n */\ndeclare class OrbitAnimationComponent implements OnInit {\n    radius: number;\n    speed: number;\n    direction: OrbitDirection;\n    startAngle: number;\n    pauseOnHover: boolean;\n    showPath: boolean;\n    private platformId;\n    ngOnInit(): void;\n    protected containerStyle(): string;\n    protected orbitPathStyle(): string;\n    protected orbitItemStyle(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<OrbitAnimationComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<OrbitAnimationComponent, \"ngx-orbit-animation\", never, { \"radius\": { \"alias\": \"radius\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"direction\": { \"alias\": \"direction\"; \"required\": false; }; \"startAngle\": { \"alias\": \"startAngle\"; \"required\": false; }; \"pauseOnHover\": { \"alias\": \"pauseOnHover\"; \"required\": false; }; \"showPath\": { \"alias\": \"showPath\"; \"required\": false; }; }, {}, never, [\"*\"], true, never>;\n}\n\n/**\n * Confetti Component\n * Creates a celebratory confetti explosion effect\n *\n * @example\n * <ngx-confetti [particleCount]=\"100\" [duration]=\"3000\"></ngx-confetti>\n */\ndeclare class ConfettiComponent implements OnInit, OnDestroy {\n    particleCount: number;\n    duration: number;\n    colors: string[];\n    autoStart: boolean;\n    canvas: ElementRef<HTMLCanvasElement>;\n    protected width: i0.WritableSignal<number>;\n    protected height: i0.WritableSignal<number>;\n    private platformId;\n    private ctx?;\n    private particles;\n    private animationId?;\n    private startTime?;\n    ngOnInit(): void;\n    private onResize;\n    start(): void;\n    private createParticles;\n    private animate;\n    stop(): void;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<ConfettiComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ConfettiComponent, \"ngx-confetti\", never, { \"particleCount\": { \"alias\": \"particleCount\"; \"required\": false; }; \"duration\": { \"alias\": \"duration\"; \"required\": false; }; \"colors\": { \"alias\": \"colors\"; \"required\": false; }; \"autoStart\": { \"alias\": \"autoStart\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Text Scramble Component\n * Creates a cool text scrambling effect (GSAP/Matrix-inspired)\n * Text appears to decode/unscramble character by character\n *\n * @example\n * <ngx-text-scramble [text]=\"'Hello World'\" [speed]=\"50\"></ngx-text-scramble>\n */\ndeclare class TextScrambleComponent implements OnInit {\n    text: string;\n    speed: number;\n    scrambleChars: string;\n    delay: number;\n    customClass: string;\n    complete: EventEmitter<void>;\n    protected displayedText: i0.WritableSignal<string>;\n    private platformId;\n    private frame;\n    private queue;\n    private rafId?;\n    ngOnInit(): void;\n    private scramble;\n    private update;\n    private randomChar;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<TextScrambleComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<TextScrambleComponent, \"ngx-text-scramble\", never, { \"text\": { \"alias\": \"text\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; \"scrambleChars\": { \"alias\": \"scrambleChars\"; \"required\": false; }; \"delay\": { \"alias\": \"delay\"; \"required\": false; }; \"customClass\": { \"alias\": \"customClass\"; \"required\": false; }; }, { \"complete\": \"complete\"; }, never, never, true, never>;\n}\n\n/**\n * Mouse Follower Component\n * Creates a custom cursor that follows the mouse (GSAP-inspired)\n * Adds a premium feel to any website\n *\n * @example\n * <ngx-mouse-follower [size]=\"20\" [color]=\"'#667eea'\"></ngx-mouse-follower>\n */\ndeclare class MouseFollowerComponent implements OnInit, OnDestroy {\n    size: number;\n    dotSize: number;\n    color: string;\n    dotColor: string;\n    speed: number;\n    protected transform: i0.WritableSignal<string>;\n    protected dotTransform: i0.WritableSignal<string>;\n    protected opacity: i0.WritableSignal<number>;\n    private platformId;\n    private mouseX;\n    private mouseY;\n    private currentX;\n    private currentY;\n    private dotX;\n    private dotY;\n    private rafId?;\n    private mouseMoveHandler?;\n    ngOnInit(): void;\n    private animate;\n    ngOnDestroy(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<MouseFollowerComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<MouseFollowerComponent, \"ngx-mouse-follower\", never, { \"size\": { \"alias\": \"size\"; \"required\": false; }; \"dotSize\": { \"alias\": \"dotSize\"; \"required\": false; }; \"color\": { \"alias\": \"color\"; \"required\": false; }; \"dotColor\": { \"alias\": \"dotColor\"; \"required\": false; }; \"speed\": { \"alias\": \"speed\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\ninterface ProfileCardData {\n    id?: string | number;\n    name: string;\n    username: string;\n    jobTitle: string;\n    gradient: string;\n    icon?: string;\n    iconSvg?: string;\n    stats?: {\n        documents?: number;\n        views?: number;\n        links?: number;\n    };\n}\n/**\n * Profile Card Component\n * Creates an interactive profile card with gradient background and hover effects\n * Perfect for team showcases, portfolios, and user grids\n *\n * @example\n * <ngx-profile-card\n *   [name]=\"'ÿ≥ÿßÿ±ÿ© ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä'\"\n *   [username]=\"'sara_zahrani@'\"\n *   [jobTitle]=\"'ÿπÿßŸÑŸÖÿ© ÿ®ŸäÿßŸÜÿßÿ™'\"\n *   [gradient]=\"'linear-gradient(135deg, #FF5D36, #763CBC)'\"\n *   icon=\"üìä\">\n * </ngx-profile-card>\n */\ndeclare class ProfileCardComponent implements OnInit {\n    name: string;\n    username: string;\n    jobTitle: string;\n    gradient: string;\n    icon: string;\n    iconSvg?: string;\n    stats?: {\n        documents?: number;\n        views?: number;\n        links?: number;\n    };\n    showStats: boolean;\n    enableTilt: boolean;\n    enableMagnetic: boolean;\n    magneticStrength: number;\n    tiltMax: number;\n    tiltGlare: boolean;\n    private platformId;\n    ngOnInit(): void;\n    get cardClasses(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<ProfileCardComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ProfileCardComponent, \"ngx-profile-card\", never, { \"name\": { \"alias\": \"name\"; \"required\": false; }; \"username\": { \"alias\": \"username\"; \"required\": false; }; \"jobTitle\": { \"alias\": \"jobTitle\"; \"required\": false; }; \"gradient\": { \"alias\": \"gradient\"; \"required\": false; }; \"icon\": { \"alias\": \"icon\"; \"required\": false; }; \"iconSvg\": { \"alias\": \"iconSvg\"; \"required\": false; }; \"stats\": { \"alias\": \"stats\"; \"required\": false; }; \"showStats\": { \"alias\": \"showStats\"; \"required\": false; }; \"enableTilt\": { \"alias\": \"enableTilt\"; \"required\": false; }; \"enableMagnetic\": { \"alias\": \"enableMagnetic\"; \"required\": false; }; \"magneticStrength\": { \"alias\": \"magneticStrength\"; \"required\": false; }; \"tiltMax\": { \"alias\": \"tiltMax\"; \"required\": false; }; \"tiltGlare\": { \"alias\": \"tiltGlare\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\n/**\n * Profile Grid Component\n * Displays a grid of profile cards with stagger animations\n * Perfect for team showcases, user directories, and portfolio grids\n *\n * @example\n * <ngx-profile-grid\n *   [profiles]=\"profileData\"\n *   [columns]=\"4\"\n *   [staggerDelay]=\"100\">\n * </ngx-profile-grid>\n */\ndeclare class ProfileGridComponent implements OnInit {\n    profiles: ProfileCardData[];\n    columns: number;\n    staggerDelay: number;\n    staggerAnimation: 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate';\n    enableStagger: boolean;\n    enableScrollReveal: boolean;\n    gap: number;\n    cardHeight: string;\n    private platformId;\n    ngOnInit(): void;\n    get gridStyle(): string;\n    static …µfac: i0.…µ…µFactoryDeclaration<ProfileGridComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<ProfileGridComponent, \"ngx-profile-grid\", never, { \"profiles\": { \"alias\": \"profiles\"; \"required\": false; }; \"columns\": { \"alias\": \"columns\"; \"required\": false; }; \"staggerDelay\": { \"alias\": \"staggerDelay\"; \"required\": false; }; \"staggerAnimation\": { \"alias\": \"staggerAnimation\"; \"required\": false; }; \"enableStagger\": { \"alias\": \"enableStagger\"; \"required\": false; }; \"enableScrollReveal\": { \"alias\": \"enableScrollReveal\"; \"required\": false; }; \"gap\": { \"alias\": \"gap\"; \"required\": false; }; \"cardHeight\": { \"alias\": \"cardHeight\"; \"required\": false; }; }, {}, never, never, true, never>;\n}\n\ndeclare class GlassCardComponent {\n    /** Slightly larger radius for very rounded cards */\n    borderRadius: string;\n    /** Hover lift effect */\n    hover: boolean;\n    /** Stronger shadow preset */\n    elevated: boolean;\n    /** Accent border using the primary color */\n    accent: boolean;\n    get hostRadius(): string;\n    get hoverClass(): boolean;\n    get elevatedClass(): boolean;\n    get accentClass(): boolean;\n    transform: string | null;\n    onMouseMove(event: MouseEvent): void;\n    onMouseLeave(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<GlassCardComponent, never>;\n    static …µcmp: i0.…µ…µComponentDeclaration<GlassCardComponent, \"ngx-glass-card\", never, { \"borderRadius\": { \"alias\": \"borderRadius\"; \"required\": false; }; \"hover\": { \"alias\": \"hover\"; \"required\": false; }; \"elevated\": { \"alias\": \"elevated\"; \"required\": false; }; \"accent\": { \"alias\": \"accent\"; \"required\": false; }; }, {}, never, [\"*\"], true, never>;\n}\n\ninterface TimelineStep {\n    element: HTMLElement | ElementRef<HTMLElement>;\n    properties: Partial<CSSStyleDeclaration>;\n    duration: number;\n    delay?: number;\n    easing?: string;\n}\ninterface TimelineOptions {\n    repeat?: boolean;\n    repeatDelay?: number;\n    onComplete?: () => void;\n    onStart?: () => void;\n    onRepeat?: () => void;\n}\n/**\n * Timeline Service\n * Chain multiple animations in sequence or parallel\n * Similar to GSAP Timeline but Angular-friendly\n *\n * @example\n * const timeline = this.timelineService.create();\n * timeline\n *   .to(element1, { opacity: '1', transform: 'translateX(0)' }, 500)\n *   .to(element2, { opacity: '1' }, 300, 100)\n *   .play();\n */\ndeclare class TimelineService {\n    createTimeline(options?: TimelineOptions): Timeline;\n    create(options?: TimelineOptions): Timeline;\n    static …µfac: i0.…µ…µFactoryDeclaration<TimelineService, never>;\n    static …µprov: i0.…µ…µInjectableDeclaration<TimelineService>;\n}\ndeclare class Timeline {\n    private steps;\n    private parallelSteps;\n    private currentStep;\n    private isPlaying;\n    private isPaused;\n    private options;\n    private currentTimeouts;\n    constructor(options?: TimelineOptions);\n    /**\n     * Add animation step to timeline\n     */\n    to(element: HTMLElement | ElementRef<HTMLElement>, properties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add animation step that starts from current properties\n     */\n    from(element: HTMLElement | ElementRef<HTMLElement>, properties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add animation step relative to current state\n     */\n    fromTo(element: HTMLElement | ElementRef<HTMLElement>, fromProperties: Partial<CSSStyleDeclaration>, toProperties: Partial<CSSStyleDeclaration>, duration: number, delay?: number, easing?: string): this;\n    /**\n     * Add multiple animations to run in parallel\n     */\n    parallel(callback: (timeline: Timeline) => void): this;\n    /**\n     * Add a delay in the timeline\n     */\n    wait(duration: number): this;\n    /**\n     * Add a label for positioning\n     */\n    addLabel(label: string): this;\n    /**\n     * Play the timeline\n     */\n    play(): Promise<void>;\n    /**\n     * Pause the timeline\n     */\n    pause(): this;\n    /**\n     * Resume the timeline\n     */\n    resume(): this;\n    /**\n     * Stop and reset the timeline\n     */\n    stop(): this;\n    /**\n     * Restart the timeline from beginning\n     */\n    restart(): Promise<void>;\n    /**\n     * Reverse the timeline\n     */\n    reverse(): this;\n    private playSteps;\n    private playParallelSteps;\n    private animateStep;\n    private onComplete;\n    private clearTimeouts;\n}\n\n/**\n * RTL & Language Service\n * Provides runtime toggle between LTR/RTL and EN/AR.\n *\n * This is intentionally simple ‚Äì you can use it or plug it into your own i18n layer.\n */\ndeclare class RtlLanguageService {\n    private platformId;\n    /** Current locale: 'en' or 'ar'. Default 'en'. */\n    readonly locale: i0.WritableSignal<\"en\" | \"ar\">;\n    /** Text direction derived from locale. */\n    readonly direction: i0.Signal<\"rtl\" | \"ltr\">;\n    /** True when current direction is RTL. */\n    readonly isRtl: i0.Signal<boolean>;\n    constructor();\n    setLocale(locale: 'en' | 'ar'): void;\n    toggleLocale(): void;\n    static …µfac: i0.…µ…µFactoryDeclaration<RtlLanguageService, never>;\n    static …µprov: i0.…µ…µInjectableDeclaration<RtlLanguageService>;\n}\n\nexport { BounceInDirective, ConfettiComponent, CountUpDirective, FadeInDirective, FlipInDirective, GlassCardComponent, GlitchDirective, HoverLiftDirective, MagneticDirective, MarqueeComponent, MorphDirective, MouseFollowerComponent, OrbitAnimationComponent, ParallaxScrollDirective, ProfileCardComponent, ProfileGridComponent, PulseDirective, RippleClickDirective, RotateInDirective, RtlLanguageService, ScaleInDirective, ScrollProgressDirective, ScrollRevealComponent, ShakeDirective, SlideInDirective, StaggerListComponent, TextScrambleComponent, Tilt3dDirective, Timeline, TimelineService, TypewriterComponent, ZoomInDirective };\nexport type { BounceDirection, EasingFunction$3 as EasingFunction, FadeDirection, FlipAxis, MarqueeDirection, OrbitDirection, ProfileCardData, RevealAnimation, RotateAxis, ScaleOrigin, ShakeIntensity, SlideDirection, StaggerAnimation, TimelineOptions, TimelineStep, ZoomStyle };\n","map":null,"preliminaryFileName":"elm-ngx-animations.d.ts","sourcemapFileName":null}],"fesm2022":[{"exports":["BounceInDirective","ConfettiComponent","CountUpDirective","FadeInDirective","FlipInDirective","GlassCardComponent","GlitchDirective","HoverLiftDirective","MagneticDirective","MarqueeComponent","MorphDirective","MouseFollowerComponent","OrbitAnimationComponent","ParallaxScrollDirective","ProfileCardComponent","ProfileGridComponent","PulseDirective","RippleClickDirective","RotateInDirective","RtlLanguageService","ScaleInDirective","ScrollProgressDirective","ScrollRevealComponent","ShakeDirective","SlideInDirective","StaggerListComponent","TextScrambleComponent","Tilt3dDirective","Timeline","TimelineService","TypewriterComponent","ZoomInDirective"],"facadeModuleId":"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/elm-ngx-animations.js","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/fade-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/slide-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/scale-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/rotate-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/parallax-scroll.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/ripple-click.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/bounce-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/flip-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/shake.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/pulse.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/glitch.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/zoom-in.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/hover-lift.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/count-up.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/magnetic.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/tilt-3d.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/scroll-progress.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/morph.directive.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/scroll-reveal/scroll-reveal.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/stagger-list/stagger-list.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/typewriter/typewriter.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/marquee/marquee.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/orbit-animation/orbit-animation.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/confetti/confetti.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/text-scramble/text-scramble.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/mouse-follower/mouse-follower.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/profile-card/profile-card.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/profile-grid/profile-grid.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/glass-card/glass-card.component.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/services/timeline.service.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/services/rtl-language.service.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/public-api.js","/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/elm-ngx-animations.js"],"name":"elm-ngx-animations","type":"chunk","dynamicImports":[],"fileName":"elm-ngx-animations.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["EventEmitter","signal","inject","PLATFORM_ID","*","Output","Input","Directive","Renderer2","HostListener","ViewChild","Component","effect","HostBinding","Injectable","ElementRef","computed"],"@angular/common":["isPlatformBrowser","CommonModule","*"]},"imports":["@angular/core","@angular/common"],"modules":{"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/fade-in.directive.js":{"code":"/**\n * Fade In/Out Directive\n * Applies smooth fade animations to any element\n *\n * @example\n * <div ngxFadeIn [duration]=\"500\" [delay]=\"100\">Content</div>\n */\nclass FadeInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'ease-out';\n    direction = 'in';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    startOpacity = 0;\n    endOpacity = 1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startOpacity when the element leaves the viewport\n     * so the animation can replay on the next entry.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // SSR: Set final state\n            const element = this.el.nativeElement;\n            element.style.opacity = this.endOpacity.toString();\n            return;\n        }\n        const element = this.el.nativeElement;\n        // Set initial state\n        element.style.opacity = this.startOpacity.toString();\n        element.style.transition = `opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit) {\n                        const element = this.el.nativeElement;\n                        element.style.opacity = this.startOpacity.toString();\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // SSR: Set final state immediately\n            const element = this.el.nativeElement;\n            element.style.opacity = this.endOpacity.toString();\n            return;\n        }\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        // Trigger animation on next frame\n        requestAnimationFrame(() => {\n            if (this.direction === 'in' || this.direction === 'in-out') {\n                element.style.opacity = this.endOpacity.toString();\n            }\n            else {\n                element.style.opacity = this.startOpacity.toString();\n            }\n        });\n        // Emit end event after animation completes\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FadeInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: FadeInDirective, isStandalone: true, selector: \"[ngxFadeIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", direction: \"direction\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", startOpacity: \"startOpacity\", endOpacity: \"endOpacity\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FadeInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxFadeIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], startOpacity: [{\n                type: Input\n            }], endOpacity: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":5143,"removedExports":[],"renderedExports":["FadeInDirective"],"renderedLength":4899},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/slide-in.directive.js":{"code":"/**\n * Slide In Directive\n * Slides element from specified direction with RTL support\n *\n * @example\n * <div ngxSlideIn direction=\"left\" [duration]=\"500\">Content</div>\n */\nclass SlideInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    direction = 'left';\n    distance = 50;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    rtl = false;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial offset + opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    initialTransform = null;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Detect RTL from element or input\n        const isRTL = this.rtl || getComputedStyle(element).direction === 'rtl';\n        // Adjust direction for RTL\n        let actualDirection = this.direction;\n        if (isRTL) {\n            if (this.direction === 'left')\n                actualDirection = 'right';\n            else if (this.direction === 'right')\n                actualDirection = 'left';\n        }\n        // Set initial transform\n        const transform = this.getTransform(actualDirection, this.distance);\n        this.initialTransform = transform;\n        element.style.transform = transform;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getTransform(direction, distance) {\n        switch (direction) {\n            case 'left':\n                return `translateX(-${distance}px)`;\n            case 'right':\n                return `translateX(${distance}px)`;\n            case 'top':\n                return `translateY(-${distance}px)`;\n            case 'bottom':\n                return `translateY(${distance}px)`;\n            default:\n                return 'translateX(0)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit && this.initialTransform !== null) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = this.initialTransform;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = 'translate(0, 0)';\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: SlideInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: SlideInDirective, isStandalone: true, selector: \"[ngxSlideIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", direction: \"direction\", distance: \"distance\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", rtl: \"rtl\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: SlideInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxSlideIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":5667,"removedExports":[],"renderedExports":["SlideInDirective"],"renderedLength":5422},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/scale-in.directive.js":{"code":"/**\n * Scale In Directive\n * Scales element from specified origin point\n *\n * @example\n * <div ngxScaleIn [startScale]=\"0.5\" [duration]=\"500\">Content</div>\n */\nclass ScaleInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    startScale = 0.5;\n    endScale = 1;\n    origin = 'center';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startScale and opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set transform origin\n        element.style.transformOrigin = this.getTransformOrigin();\n        element.style.transform = `scale(${this.startScale})`;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getTransformOrigin() {\n        return this.origin.replace('-', ' ');\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = `scale(${this.startScale})`;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = `scale(${this.endScale})`;\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScaleInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScaleInDirective, isStandalone: true, selector: \"[ngxScaleIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", startScale: \"startScale\", endScale: \"endScale\", origin: \"origin\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScaleInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxScaleIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], startScale: [{\n                type: Input\n            }], endScale: [{\n                type: Input\n            }], origin: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":4789,"removedExports":[],"renderedExports":["ScaleInDirective"],"renderedLength":4544},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/rotate-in.directive.js":{"code":"/**\n * Rotate In Directive\n * Rotates element on specified axis\n *\n * @example\n * <div ngxRotateIn axis=\"y\" [degrees]=\"90\">Content</div>\n */\nclass RotateInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    axis = 'z';\n    degrees = 180;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial rotated state with opacity 0 when the\n     * element leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    initialTransform = null;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial rotation\n        const initial = this.getRotateTransform(this.degrees);\n        this.initialTransform = initial;\n        element.style.transform = initial;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getRotateTransform(degrees) {\n        switch (this.axis) {\n            case 'x':\n                return `rotateX(${degrees}deg)`;\n            case 'y':\n                return `rotateY(${degrees}deg)`;\n            case 'z':\n                return `rotateZ(${degrees}deg)`;\n            default:\n                return `rotate(${degrees}deg)`;\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit && this.initialTransform !== null) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = this.initialTransform;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = this.getRotateTransform(0);\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RotateInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: RotateInDirective, isStandalone: true, selector: \"[ngxRotateIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", axis: \"axis\", degrees: \"degrees\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RotateInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxRotateIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], axis: [{\n                type: Input\n            }], degrees: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":5024,"removedExports":[],"renderedExports":["RotateInDirective"],"renderedLength":4778},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/parallax-scroll.directive.js":{"code":"/**\n * Parallax Scroll Directive\n * Creates smooth parallax effect on scroll\n *\n * @example\n * <div ngxParallaxScroll [speed]=\"0.5\">Content</div>\n */\nclass ParallaxScrollDirective {\n    el;\n    speed = 0.5; // 0 to 1, where 1 is normal scroll speed\n    direction = 'vertical';\n    reverse = false;\n    platformId = inject(PLATFORM_ID);\n    scrollHandler;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform';\n        element.style.transition = 'transform 0.1s ease-out';\n        this.scrollHandler = () => {\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n            }\n            this.rafId = requestAnimationFrame(() => {\n                this.updateParallax();\n            });\n        };\n        window.addEventListener('scroll', this.scrollHandler, { passive: true });\n        this.updateParallax();\n    }\n    updateParallax() {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const windowHeight = window.innerHeight;\n        // Calculate how much the element is in view (0 to 1)\n        const elementMiddle = rect.top + rect.height / 2;\n        const scrollProgress = 1 - (elementMiddle / windowHeight);\n        // Apply parallax effect\n        const multiplier = this.reverse ? -1 : 1;\n        const offset = scrollProgress * 100 * this.speed * multiplier;\n        if (this.direction === 'vertical') {\n            element.style.transform = `translateY(${offset}px)`;\n        }\n        else {\n            element.style.transform = `translateX(${offset}px)`;\n        }\n    }\n    ngOnDestroy() {\n        if (this.scrollHandler) {\n            window.removeEventListener('scroll', this.scrollHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ParallaxScrollDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ParallaxScrollDirective, isStandalone: true, selector: \"[ngxParallaxScroll]\", inputs: { speed: \"speed\", direction: \"direction\", reverse: \"reverse\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ParallaxScrollDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxParallaxScroll]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], reverse: [{\n                type: Input\n            }] } });","originalLength":3208,"removedExports":[],"renderedExports":["ParallaxScrollDirective"],"renderedLength":2986},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/ripple-click.directive.js":{"code":"/**\n * Ripple Click Directive\n * Creates Material Design-style ripple effect on click\n * Modern and performant implementation\n *\n * @example\n * <button ngxRippleClick [rippleColor]=\"'rgba(255, 255, 255, 0.5)'\">Click me</button>\n */\nclass RippleClickDirective {\n    el;\n    rippleColor = 'rgba(255, 255, 255, 0.5)';\n    rippleDuration = 600;\n    rippleRadius = 0; // 0 means auto-calculate\n    centered = false;\n    platformId = inject(PLATFORM_ID);\n    renderer = inject(Renderer2);\n    constructor(el) {\n        this.el = el;\n        this.setupHostElement();\n    }\n    setupHostElement() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const position = getComputedStyle(element).position;\n        if (position === 'static') {\n            this.renderer.setStyle(element, 'position', 'relative');\n        }\n        this.renderer.setStyle(element, 'overflow', 'hidden');\n        this.renderer.setStyle(element, 'user-select', 'none');\n        this.renderer.setStyle(element, '-webkit-tap-highlight-color', 'transparent');\n    }\n    onClick(event) {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.createRipple(event);\n    }\n    createRipple(event) {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        // Calculate ripple position\n        let x, y;\n        if (this.centered) {\n            x = rect.width / 2;\n            y = rect.height / 2;\n        }\n        else {\n            x = event.clientX - rect.left;\n            y = event.clientY - rect.top;\n        }\n        // Calculate ripple size\n        const radius = this.rippleRadius || Math.max(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(y, 2)), Math.sqrt(Math.pow(x, 2) + Math.pow(rect.height - y, 2)), Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(rect.height - y, 2)));\n        // Create ripple element\n        const ripple = this.renderer.createElement('span');\n        this.renderer.addClass(ripple, 'ngx-ripple');\n        // Apply styles\n        const styles = {\n            'position': 'absolute',\n            'border-radius': '50%',\n            'background-color': this.rippleColor,\n            'width': `${radius * 2}px`,\n            'height': `${radius * 2}px`,\n            'left': `${x - radius}px`,\n            'top': `${y - radius}px`,\n            'transform': 'scale(0)',\n            'opacity': '1',\n            'pointer-events': 'none',\n            'transition': `transform ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1), opacity ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`\n        };\n        Object.entries(styles).forEach(([key, value]) => {\n            this.renderer.setStyle(ripple, key, value);\n        });\n        // Add to DOM\n        this.renderer.appendChild(element, ripple);\n        // Trigger animation\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                this.renderer.setStyle(ripple, 'transform', 'scale(1)');\n                this.renderer.setStyle(ripple, 'opacity', '0');\n            });\n        });\n        // Remove after animation\n        setTimeout(() => {\n            this.renderer.removeChild(element, ripple);\n        }, this.rippleDuration);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RippleClickDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: RippleClickDirective, isStandalone: true, selector: \"[ngxRippleClick]\", inputs: { rippleColor: \"rippleColor\", rippleDuration: \"rippleDuration\", rippleRadius: \"rippleRadius\", centered: \"centered\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RippleClickDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxRippleClick]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { rippleColor: [{\n                type: Input\n            }], rippleDuration: [{\n                type: Input\n            }], rippleRadius: [{\n                type: Input\n            }], centered: [{\n                type: Input\n            }], onClick: [{\n                type: HostListener,\n                args: ['click', ['$event']]\n            }] } });","originalLength":4844,"removedExports":[],"renderedExports":["RippleClickDirective"],"renderedLength":4600},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/bounce-in.directive.js":{"code":"/**\n * Bounce In Directive\n * Creates a playful bounce effect when element appears\n *\n * @example\n * <div ngxBounceIn direction=\"up\" [duration]=\"800\">Bouncy content!</div>\n */\nclass BounceInDirective {\n    el;\n    duration = 800;\n    delay = 0;\n    direction = 'up';\n    distance = 50;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial state\n        this.setInitialState(element);\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setInitialState(element) {\n        element.style.opacity = '0';\n        element.style.transform = this.getInitialTransform();\n    }\n    getInitialTransform() {\n        switch (this.direction) {\n            case 'up':\n                return `translateY(${this.distance}px) scale(0.3)`;\n            case 'down':\n                return `translateY(-${this.distance}px) scale(0.3)`;\n            case 'left':\n                return `translateX(${this.distance}px) scale(0.3)`;\n            case 'right':\n                return `translateX(-${this.distance}px) scale(0.3)`;\n            case 'center':\n                return 'scale(0.3)';\n            default:\n                return 'scale(0.3)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            // Create bounce keyframes animation\n            const keyframes = [\n                { transform: this.getInitialTransform(), opacity: '0', offset: 0 },\n                { transform: 'translate(0, 0) scale(1.1)', opacity: '1', offset: 0.6 },\n                { transform: 'translate(0, 0) scale(0.95)', opacity: '1', offset: 0.8 },\n                { transform: 'translate(0, 0) scale(1.02)', opacity: '1', offset: 0.9 },\n                { transform: 'translate(0, 0) scale(1)', opacity: '1', offset: 1 }\n            ];\n            element.animate(keyframes, {\n                duration: this.duration,\n                easing: 'ease-out',\n                fill: 'forwards'\n            });\n            setTimeout(() => {\n                element.style.opacity = '1';\n                element.style.transform = 'translate(0, 0) scale(1)';\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: BounceInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: BounceInDirective, isStandalone: true, selector: \"[ngxBounceIn]\", inputs: { duration: \"duration\", delay: \"delay\", direction: \"direction\", distance: \"distance\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: BounceInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxBounceIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":4981,"removedExports":[],"renderedExports":["BounceInDirective"],"renderedLength":4735},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/flip-in.directive.js":{"code":"/**\n * Flip In Directive\n * Creates a 3D flip animation effect\n *\n * @example\n * <div ngxFlipIn axis=\"horizontal\" [duration]=\"600\">Flip me!</div>\n */\nclass FlipInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    axis = 'horizontal';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Add perspective to parent for 3D effect\n        const parent = element.parentElement;\n        if (parent) {\n            parent.style.perspective = '1000px';\n        }\n        // Set initial state\n        element.style.opacity = '0';\n        element.style.transform = this.getInitialTransform();\n        element.style.backfaceVisibility = 'visible';\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getInitialTransform() {\n        switch (this.axis) {\n            case 'horizontal':\n                return 'rotateY(-90deg)';\n            case 'vertical':\n                return 'rotateX(-90deg)';\n            case 'diagonal':\n                return 'rotate3d(1, 1, 0, -90deg)';\n            default:\n                return 'rotateY(-90deg)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n            element.style.opacity = '1';\n            element.style.transform = 'rotate3d(0, 0, 0, 0deg)';\n            setTimeout(() => {\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FlipInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: FlipInDirective, isStandalone: true, selector: \"[ngxFlipIn]\", inputs: { duration: \"duration\", delay: \"delay\", axis: \"axis\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FlipInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxFlipIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], axis: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":4164,"removedExports":[],"renderedExports":["FlipInDirective"],"renderedLength":3920},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/shake.directive.js":{"code":"/**\n * Shake Directive\n * Creates a shake/wobble effect on interaction or programmatically\n *\n * @example\n * <div ngxShake [shakeOnHover]=\"true\" intensity=\"medium\">Shake on hover!</div>\n */\nclass ShakeDirective {\n    el;\n    intensity = 'medium';\n    duration = 500;\n    shakeOnHover = false;\n    shakeOnClick = false;\n    continuous = false;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        if (this.continuous) {\n            this.startContinuousShake();\n        }\n    }\n    onMouseEnter() {\n        if (this.shakeOnHover) {\n            this.shake();\n        }\n    }\n    onClick() {\n        if (this.shakeOnClick) {\n            this.shake();\n        }\n    }\n    getShakeDistance() {\n        switch (this.intensity) {\n            case 'soft':\n                return 5;\n            case 'medium':\n                return 10;\n            case 'hard':\n                return 15;\n            default:\n                return 10;\n        }\n    }\n    shake() {\n        const element = this.el.nativeElement;\n        const distance = this.getShakeDistance();\n        const keyframes = [\n            { transform: 'translateX(0)' },\n            { transform: `translateX(-${distance}px)` },\n            { transform: `translateX(${distance}px)` },\n            { transform: `translateX(-${distance}px)` },\n            { transform: `translateX(${distance}px)` },\n            { transform: `translateX(-${distance / 2}px)` },\n            { transform: `translateX(${distance / 2}px)` },\n            { transform: 'translateX(0)' }\n        ];\n        element.animate(keyframes, {\n            duration: this.duration,\n            easing: 'ease-in-out'\n        });\n    }\n    startContinuousShake() {\n        this.shake();\n        this.intervalId = setInterval(() => {\n            this.shake();\n        }, this.duration + 2000);\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ShakeDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ShakeDirective, isStandalone: true, selector: \"[ngxShake]\", inputs: { intensity: \"intensity\", duration: \"duration\", shakeOnHover: \"shakeOnHover\", shakeOnClick: \"shakeOnClick\", continuous: \"continuous\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"click\": \"onClick()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ShakeDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxShake]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { intensity: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], shakeOnHover: [{\n                type: Input\n            }], shakeOnClick: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });","originalLength":3738,"removedExports":[],"renderedExports":["ShakeDirective"],"renderedLength":3512},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/pulse.directive.js":{"code":"/**\n * Pulse Directive\n * Creates a continuous pulsing/heartbeat effect\n *\n * @example\n * <div ngxPulse [speed]=\"1000\" [scale]=\"1.1\">Pulsing content!</div>\n */\nclass PulseDirective {\n    el;\n    speed = 1000; // duration of one pulse cycle\n    scale = 1.05; // how much to scale (1.0 = no scale, 1.1 = 10% larger)\n    continuous = true;\n    pauseOnHover = false;\n    platformId = inject(PLATFORM_ID);\n    animation;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform';\n        if (this.continuous) {\n            this.startPulse();\n        }\n        if (this.pauseOnHover) {\n            element.addEventListener('mouseenter', () => this.pause());\n            element.addEventListener('mouseleave', () => this.resume());\n        }\n    }\n    startPulse() {\n        const element = this.el.nativeElement;\n        const keyframes = [\n            { transform: 'scale(1)', offset: 0 },\n            { transform: `scale(${this.scale})`, offset: 0.5 },\n            { transform: 'scale(1)', offset: 1 }\n        ];\n        this.animation = element.animate(keyframes, {\n            duration: this.speed,\n            iterations: Infinity,\n            easing: 'ease-in-out'\n        });\n    }\n    pause() {\n        if (this.animation) {\n            this.animation.pause();\n        }\n    }\n    resume() {\n        if (this.animation) {\n            this.animation.play();\n        }\n    }\n    ngOnDestroy() {\n        if (this.animation) {\n            this.animation.cancel();\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: PulseDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: PulseDirective, isStandalone: true, selector: \"[ngxPulse]\", inputs: { speed: \"speed\", scale: \"scale\", continuous: \"continuous\", pauseOnHover: \"pauseOnHover\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: PulseDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPulse]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { speed: [{\n                type: Input\n            }], scale: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }] } });","originalLength":2909,"removedExports":[],"renderedExports":["PulseDirective"],"renderedLength":2697},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/glitch.directive.js":{"code":"/**\n * Glitch Directive\n * Creates a cool glitch/distortion effect\n *\n * @example\n * <div ngxGlitch [intensity]=\"5\" [speed]=\"3000\">Glitchy text!</div>\n */\nclass GlitchDirective {\n    el;\n    intensity = 3; // 1-10, higher = more glitch\n    speed = 3000; // how often glitch occurs (ms)\n    duration = 200; // how long each glitch lasts\n    continuous = true;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.position = 'relative';\n        element.style.display = 'inline-block';\n        if (this.continuous) {\n            this.startGlitching();\n        }\n    }\n    startGlitching() {\n        this.intervalId = setInterval(() => {\n            this.glitch();\n        }, this.speed);\n    }\n    glitch() {\n        const element = this.el.nativeElement;\n        const originalText = element.textContent || '';\n        // Create glitch effect with text-shadow and transform\n        const glitchKeyframes = [\n            {\n                transform: 'translate(0, 0)',\n                textShadow: `${this.intensity}px 0 red, -${this.intensity}px 0 blue`,\n                offset: 0\n            },\n            {\n                transform: `translate(${this.intensity}px, ${this.intensity}px)`,\n                textShadow: `-${this.intensity}px 0 red, ${this.intensity}px 0 cyan`,\n                offset: 0.25\n            },\n            {\n                transform: `translate(-${this.intensity}px, -${this.intensity}px)`,\n                textShadow: `${this.intensity}px 0 green, -${this.intensity}px 0 magenta`,\n                offset: 0.5\n            },\n            {\n                transform: `translate(${this.intensity}px, -${this.intensity}px)`,\n                textShadow: `-${this.intensity}px 0 yellow, ${this.intensity}px 0 blue`,\n                offset: 0.75\n            },\n            {\n                transform: 'translate(0, 0)',\n                textShadow: 'none',\n                offset: 1\n            }\n        ];\n        element.animate(glitchKeyframes, {\n            duration: this.duration,\n            easing: 'steps(4)'\n        });\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlitchDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: GlitchDirective, isStandalone: true, selector: \"[ngxGlitch]\", inputs: { intensity: \"intensity\", speed: \"speed\", duration: \"duration\", continuous: \"continuous\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlitchDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxGlitch]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { intensity: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }] } });","originalLength":3639,"removedExports":[],"renderedExports":["GlitchDirective"],"renderedLength":3426},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/zoom-in.directive.js":{"code":"/**\n * Zoom In Directive\n * Creates various zoom-in effects with different styles\n *\n * @example\n * <div ngxZoomIn style=\"bounce\" [intensity]=\"1.5\">Zoom content!</div>\n */\nclass ZoomInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    style = 'smooth';\n    intensity = 1.2; // peak zoom scale\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial state\n        element.style.opacity = '0';\n        element.style.transform = 'scale(0)';\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            const keyframes = this.getKeyframes();\n            element.animate(keyframes, {\n                duration: this.duration,\n                easing: this.getEasing(),\n                fill: 'forwards'\n            });\n            setTimeout(() => {\n                element.style.opacity = '1';\n                element.style.transform = 'scale(1)';\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    getKeyframes() {\n        switch (this.style) {\n            case 'smooth':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            case 'bounce':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.6 },\n                    { transform: 'scale(0.9)', opacity: '1', offset: 0.8 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            case 'elastic':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.5 },\n                    { transform: 'scale(0.85)', opacity: '1', offset: 0.7 },\n                    { transform: 'scale(1.05)', opacity: '1', offset: 0.85 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            default:\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n        }\n    }\n    getEasing() {\n        switch (this.style) {\n            case 'smooth':\n                return 'cubic-bezier(0.4, 0, 0.2, 1)';\n            case 'bounce':\n                return 'ease-out';\n            case 'elastic':\n                return 'ease-out';\n            default:\n                return 'ease-out';\n        }\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ZoomInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ZoomInDirective, isStandalone: true, selector: \"[ngxZoomIn]\", inputs: { duration: \"duration\", delay: \"delay\", style: \"style\", intensity: \"intensity\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ZoomInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxZoomIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], style: [{\n                type: Input\n            }], intensity: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });","originalLength":5478,"removedExports":[],"renderedExports":["ZoomInDirective"],"renderedLength":5234},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/hover-lift.directive.js":{"code":"/**\n * Hover Lift Directive\n * Adds a subtle scale + shadow effect on hover.\n *\n * Useful for cards, buttons, and tiles.\n *\n * @example\n * <div ngxHoverLift [liftScale]=\"1.03\" [shadowStrength]=\"0.25\">Card</div>\n */\nclass HoverLiftDirective {\n    el;\n    /** Scale factor on hover (1 = no scale) */\n    liftScale = 1.03;\n    /** Shadow strength 0‚Äì1 */\n    shadowStrength = 0.25;\n    /** Transition duration in ms */\n    hoverDuration = 200;\n    platformId = inject(PLATFORM_ID);\n    originalTransform = '';\n    originalBoxShadow = '';\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const style = getComputedStyle(element);\n        this.originalTransform = style.transform === 'none' ? '' : style.transform;\n        this.originalBoxShadow = style.boxShadow || 'none';\n        element.style.transition =\n            element.style.transition ||\n                `transform ${this.hoverDuration}ms ease-out, box-shadow ${this.hoverDuration}ms ease-out`;\n        element.style.willChange = 'transform, box-shadow';\n    }\n    onEnter() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const shadowAlpha = this.shadowStrength;\n        const shadow = `0 12px 25px rgba(0, 0, 0, ${shadowAlpha})`;\n        element.style.transform = `${this.originalTransform} scale(${this.liftScale})`.trim();\n        element.style.boxShadow = shadow;\n    }\n    onLeave() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transform = this.originalTransform || 'none';\n        element.style.boxShadow = this.originalBoxShadow;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: HoverLiftDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: HoverLiftDirective, isStandalone: true, selector: \"[ngxHoverLift]\", inputs: { liftScale: \"liftScale\", shadowStrength: \"shadowStrength\", hoverDuration: \"hoverDuration\" }, host: { listeners: { \"mouseenter\": \"onEnter()\", \"mouseleave\": \"onLeave()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: HoverLiftDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxHoverLift]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { liftScale: [{\n                type: Input\n            }], shadowStrength: [{\n                type: Input\n            }], hoverDuration: [{\n                type: Input\n            }], onEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });","originalLength":3350,"removedExports":[],"renderedExports":["HoverLiftDirective"],"renderedLength":3119},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/count-up.directive.js":{"code":"/**\n * Count Up Directive\n * Animates numbers from a start value to an end value.\n *\n * @example\n * <span ngxCountUp [end]=\"2500\" [duration]=\"1200\"></span>\n */\nclass CountUpDirective {\n    el;\n    /** Starting value */\n    start = 0;\n    /** Final value */\n    end = 100;\n    /** Duration in ms */\n    duration = 1000;\n    /** Decimal places */\n    decimals = 0;\n    /** Optional prefix (e.g. '$') */\n    prefix = '';\n    /** Optional suffix (e.g. '%') */\n    suffix = '';\n    /** Whether to animate on scroll into view */\n    triggerOnScroll = true;\n    /** Intersection threshold */\n    threshold = 0.2;\n    platformId = inject(PLATFORM_ID);\n    observer;\n    startTime = 0;\n    rafId;\n    hasAnimated = false;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.render(this.end);\n            return;\n        }\n        if (this.triggerOnScroll) {\n            this.setupObserver();\n        }\n        else {\n            this.startAnimation();\n        }\n    }\n    setupObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    if (!this.hasAnimated) {\n                        this.startAnimation();\n                        this.hasAnimated = true;\n                    }\n                }\n                else {\n                    // Reset so animation can play again on next scroll into view\n                    this.hasAnimated = false;\n                    this.render(this.start);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    startAnimation() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.startTime = performance.now();\n        this.animate();\n    }\n    animate = () => {\n        const now = performance.now();\n        const elapsed = now - this.startTime;\n        const progress = Math.min(elapsed / this.duration, 1);\n        const currentValue = this.start + (this.end - this.start) * progress;\n        this.render(currentValue);\n        if (progress < 1) {\n            this.rafId = requestAnimationFrame(this.animate);\n        }\n    };\n    render(value) {\n        const formatted = this.prefix +\n            value.toFixed(this.decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') +\n            this.suffix;\n        this.el.nativeElement.textContent = formatted;\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n        if (this.rafId)\n            cancelAnimationFrame(this.rafId);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: CountUpDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: CountUpDirective, isStandalone: true, selector: \"[ngxCountUp]\", inputs: { start: \"start\", end: \"end\", duration: \"duration\", decimals: \"decimals\", prefix: \"prefix\", suffix: \"suffix\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: CountUpDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxCountUp]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { start: [{\n                type: Input\n            }], end: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], decimals: [{\n                type: Input\n            }], prefix: [{\n                type: Input\n            }], suffix: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }] } });","originalLength":4219,"removedExports":[],"renderedExports":["CountUpDirective"],"renderedLength":4004},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/magnetic.directive.js":{"code":"/**\n * Magnetic Directive\n * Creates a magnetic pull effect on hover (GSAP-inspired)\n * Elements follow the mouse cursor when hovering\n *\n * @example\n * <button ngxMagnetic [strength]=\"0.5\">Magnetic Button</button>\n */\nclass MagneticDirective {\n    el;\n    strength = 0.4; // 0-1, how strong the magnetic effect is\n    speed = 0.3; // 0-1, how fast it follows\n    platformId = inject(PLATFORM_ID);\n    rect;\n    isHovering = false;\n    currentX = 0;\n    currentY = 0;\n    targetX = 0;\n    targetY = 0;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transition = 'transform 0.1s ease-out';\n        element.style.willChange = 'transform';\n    }\n    onMouseEnter() {\n        this.isHovering = true;\n        this.rect = this.el.nativeElement.getBoundingClientRect();\n        this.animate();\n    }\n    onMouseLeave() {\n        this.isHovering = false;\n        this.targetX = 0;\n        this.targetY = 0;\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n        // Reset to center\n        this.el.nativeElement.style.transform = 'translate(0px, 0px)';\n    }\n    onMouseMove(event) {\n        if (!this.isHovering || !this.rect)\n            return;\n        const x = event.clientX - this.rect.left - this.rect.width / 2;\n        const y = event.clientY - this.rect.top - this.rect.height / 2;\n        this.targetX = x * this.strength;\n        this.targetY = y * this.strength;\n    }\n    animate() {\n        if (!this.isHovering)\n            return;\n        // Smooth lerp (linear interpolation)\n        this.currentX += (this.targetX - this.currentX) * this.speed;\n        this.currentY += (this.targetY - this.currentY) * this.speed;\n        this.el.nativeElement.style.transform =\n            `translate(${this.currentX}px, ${this.currentY}px)`;\n        this.rafId = requestAnimationFrame(() => this.animate());\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MagneticDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MagneticDirective, isStandalone: true, selector: \"[ngxMagnetic]\", inputs: { strength: \"strength\", speed: \"speed\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mouseleave\": \"onMouseLeave()\", \"mousemove\": \"onMouseMove($event)\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MagneticDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxMagnetic]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { strength: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }] } });","originalLength":3591,"removedExports":[],"renderedExports":["MagneticDirective"],"renderedLength":3362},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/tilt-3d.directive.js":{"code":"/**\n * 3D Tilt Directive\n * Creates a 3D tilt effect following mouse movement (GSAP-inspired)\n * Perfect for cards and interactive elements\n *\n * @example\n * <div ngxTilt3d [maxTilt]=\"15\" [perspective]=\"1000\">3D Card</div>\n */\nclass Tilt3dDirective {\n    el;\n    maxTilt = 20; // Maximum tilt angle in degrees\n    perspective = 1000; // Perspective value\n    scale = 1.05; // Scale on hover\n    speed = 400; // Transition speed in ms\n    glare = false; // Add glare effect\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transformStyle = 'preserve-3d';\n        element.style.transition = `transform ${this.speed}ms cubic-bezier(0.03, 0.98, 0.52, 0.99)`;\n        element.style.willChange = 'transform';\n        if (this.glare) {\n            this.addGlareEffect();\n        }\n    }\n    addGlareEffect() {\n        const glare = document.createElement('div');\n        glare.className = 'tilt-glare';\n        glare.style.cssText = `\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: linear-gradient(135deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%);\n      opacity: 0;\n      pointer-events: none;\n      transition: opacity ${this.speed}ms;\n      border-radius: inherit;\n    `;\n        this.el.nativeElement.appendChild(glare);\n        this.el.nativeElement.style.position = 'relative';\n        this.el.nativeElement.style.overflow = 'hidden';\n    }\n    onMouseEnter() {\n        const element = this.el.nativeElement;\n        element.style.transform = `perspective(${this.perspective}px) scale(${this.scale})`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare)\n                glare.style.opacity = '1';\n        }\n    }\n    onMouseMove(event) {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const rotateX = ((y - centerY) / centerY) * this.maxTilt;\n        const rotateY = ((centerX - x) / centerX) * this.maxTilt;\n        element.style.transform =\n            `perspective(${this.perspective}px) scale(${this.scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare) {\n                const angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);\n                glare.style.background =\n                    `linear-gradient(${angle}deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%)`;\n            }\n        }\n    }\n    onMouseLeave() {\n        const element = this.el.nativeElement;\n        element.style.transform = `perspective(${this.perspective}px) rotateX(0deg) rotateY(0deg) scale(1)`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare)\n                glare.style.opacity = '0';\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: Tilt3dDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: Tilt3dDirective, isStandalone: true, selector: \"[ngxTilt3d]\", inputs: { maxTilt: \"maxTilt\", perspective: \"perspective\", scale: \"scale\", speed: \"speed\", glare: \"glare\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mousemove\": \"onMouseMove($event)\", \"mouseleave\": \"onMouseLeave()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: Tilt3dDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxTilt3d]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { maxTilt: [{\n                type: Input\n            }], perspective: [{\n                type: Input\n            }], scale: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], glare: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });","originalLength":5037,"removedExports":[],"renderedExports":["Tilt3dDirective"],"renderedLength":4809},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/scroll-progress.directive.js":{"code":"/**\n * Scroll Progress Directive\n * Animates elements based on scroll progress (GSAP ScrollTrigger-inspired)\n * Perfect for parallax and scroll-driven animations\n *\n * @example\n * <div ngxScrollProgress [startProgress]=\"0\" [endProgress]=\"100\">Content</div>\n */\nclass ScrollProgressDirective {\n    el;\n    startProgress = 0; // Start at this scroll percentage\n    endProgress = 100; // End at this scroll percentage\n    animateOpacity = true;\n    animateScale = false;\n    animateX = 0; // Translate X distance\n    animateY = 0; // Translate Y distance\n    animateRotate = 0; // Rotation degrees\n    progressChange = new EventEmitter();\n    platformId = inject(PLATFORM_ID);\n    scrollHandler;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform, opacity';\n        this.scrollHandler = () => {\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n            }\n            this.rafId = requestAnimationFrame(() => this.updateProgress());\n        };\n        window.addEventListener('scroll', this.scrollHandler, { passive: true });\n        this.updateProgress();\n    }\n    updateProgress() {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const windowHeight = window.innerHeight;\n        // Calculate progress (0 to 1)\n        const elementTop = rect.top;\n        const elementHeight = rect.height;\n        const scrollProgress = (windowHeight - elementTop) / (windowHeight + elementHeight);\n        const clampedProgress = Math.max(0, Math.min(1, scrollProgress));\n        // Map to start/end range\n        const rangeStart = this.startProgress / 100;\n        const rangeEnd = this.endProgress / 100;\n        const normalizedProgress = (clampedProgress - rangeStart) / (rangeEnd - rangeStart);\n        const progress = Math.max(0, Math.min(1, normalizedProgress));\n        this.progressChange.emit(progress);\n        // Apply transformations\n        const transforms = [];\n        if (this.animateX !== 0) {\n            const x = this.animateX * (1 - progress);\n            transforms.push(`translateX(${x}px)`);\n        }\n        if (this.animateY !== 0) {\n            const y = this.animateY * (1 - progress);\n            transforms.push(`translateY(${y}px)`);\n        }\n        if (this.animateScale) {\n            const scale = 0.5 + (progress * 0.5);\n            transforms.push(`scale(${scale})`);\n        }\n        if (this.animateRotate !== 0) {\n            const rotate = this.animateRotate * progress;\n            transforms.push(`rotate(${rotate}deg)`);\n        }\n        element.style.transform = transforms.join(' ');\n        if (this.animateOpacity) {\n            element.style.opacity = progress.toString();\n        }\n    }\n    ngOnDestroy() {\n        if (this.scrollHandler) {\n            window.removeEventListener('scroll', this.scrollHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollProgressDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScrollProgressDirective, isStandalone: true, selector: \"[ngxScrollProgress]\", inputs: { startProgress: \"startProgress\", endProgress: \"endProgress\", animateOpacity: \"animateOpacity\", animateScale: \"animateScale\", animateX: \"animateX\", animateY: \"animateY\", animateRotate: \"animateRotate\" }, outputs: { progressChange: \"progressChange\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollProgressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxScrollProgress]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { startProgress: [{\n                type: Input\n            }], endProgress: [{\n                type: Input\n            }], animateOpacity: [{\n                type: Input\n            }], animateScale: [{\n                type: Input\n            }], animateX: [{\n                type: Input\n            }], animateY: [{\n                type: Input\n            }], animateRotate: [{\n                type: Input\n            }], progressChange: [{\n                type: Output\n            }] } });","originalLength":4890,"removedExports":[],"renderedExports":["ScrollProgressDirective"],"renderedLength":4646},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/directives/morph.directive.js":{"code":"/**\n * Morph Directive\n * Creates smooth morphing transitions between shapes (GSAP MorphSVG-inspired)\n * Works with border-radius to create organic shape changes\n *\n * @example\n * <div ngxMorph [morphOnHover]=\"true\">Morphing element</div>\n */\nclass MorphDirective {\n    el;\n    morphOnHover = true;\n    morphOnClick = false;\n    duration = 600;\n    continuous = false;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    originalBorderRadius;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        this.originalBorderRadius = getComputedStyle(element).borderRadius || '0px';\n        element.style.transition = `border-radius ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n        if (this.continuous) {\n            this.startContinuousMorph();\n        }\n    }\n    onMouseEnter() {\n        if (this.morphOnHover && !this.continuous) {\n            this.morph();\n        }\n    }\n    onMouseLeave() {\n        if (this.morphOnHover && !this.continuous) {\n            this.reset();\n        }\n    }\n    onClick() {\n        if (this.morphOnClick) {\n            this.morph();\n            setTimeout(() => this.reset(), this.duration);\n        }\n    }\n    morph() {\n        const element = this.el.nativeElement;\n        const shapes = this.getRandomShape();\n        element.style.borderRadius = shapes;\n    }\n    reset() {\n        const element = this.el.nativeElement;\n        element.style.borderRadius = this.originalBorderRadius || '0px';\n    }\n    getRandomShape() {\n        const shapes = [\n            '60% 40% 30% 70% / 60% 30% 70% 40%',\n            '30% 60% 70% 40% / 50% 60% 30% 60%',\n            '60% 40% 60% 40% / 70% 50% 50% 60%',\n            '40% 60% 70% 30% / 40% 50% 60% 50%',\n            '80% 20% 50% 50% / 60% 70% 30% 40%',\n            '50% 50% 30% 70% / 30% 60% 40% 60%'\n        ];\n        return shapes[Math.floor(Math.random() * shapes.length)];\n    }\n    startContinuousMorph() {\n        this.morph();\n        this.intervalId = setInterval(() => {\n            this.morph();\n        }, this.duration + 500);\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MorphDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MorphDirective, isStandalone: true, selector: \"[ngxMorph]\", inputs: { morphOnHover: \"morphOnHover\", morphOnClick: \"morphOnClick\", duration: \"duration\", continuous: \"continuous\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mouseleave\": \"onMouseLeave()\", \"click\": \"onClick()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MorphDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxMorph]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { morphOnHover: [{\n                type: Input\n            }], morphOnClick: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });","originalLength":4004,"removedExports":[],"renderedExports":["MorphDirective"],"renderedLength":3778},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/scroll-reveal/scroll-reveal.component.js":{"code":"/**\n * Scroll Reveal Component\n * Reveals content when it comes into viewport\n *\n * @example\n * <ngx-scroll-reveal animation=\"slide-up\">\n *   <h1>Content to reveal</h1>\n * </ngx-scroll-reveal>\n */\nclass ScrollRevealComponent {\n    el;\n    animation = 'fade';\n    duration = 600;\n    delay = 0;\n    threshold = 0.1;\n    once = true;\n    distance = 50;\n    revealed = new EventEmitter();\n    hidden = new EventEmitter();\n    container;\n    isRevealed = signal(false, ...(ngDevMode ? [{ debugName: \"isRevealed\" }] : []));\n    observer;\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.isRevealed.set(true);\n            return;\n        }\n        this.setupIntersectionObserver();\n    }\n    containerStyle() {\n        const styles = [\n            `transition-duration: ${this.duration}ms`,\n            `transition-delay: ${this.delay}ms`\n        ];\n        if (!this.isRevealed()) {\n            styles.push('opacity: 0');\n            styles.push(this.getInitialTransform());\n        }\n        return styles.join('; ');\n    }\n    getInitialTransform() {\n        switch (this.animation) {\n            case 'fade':\n                return 'transform: none';\n            case 'slide-up':\n                return `transform: translateY(${this.distance}px)`;\n            case 'slide-down':\n                return `transform: translateY(-${this.distance}px)`;\n            case 'slide-left':\n                return `transform: translateX(${this.distance}px)`;\n            case 'slide-right':\n                return `transform: translateX(-${this.distance}px)`;\n            case 'scale':\n                return 'transform: scale(0.8)';\n            case 'rotate':\n                return 'transform: rotate(10deg)';\n            default:\n                return 'transform: none';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.isRevealed.set(true);\n                    this.revealed.emit();\n                    if (this.once) {\n                        this.observer?.unobserve(entry.target);\n                    }\n                }\n                else if (!this.once) {\n                    this.isRevealed.set(false);\n                    this.hidden.emit();\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollRevealComponent, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScrollRevealComponent, isStandalone: true, selector: \"ngx-scroll-reveal\", inputs: { animation: \"animation\", duration: \"duration\", delay: \"delay\", threshold: \"threshold\", once: \"once\", distance: \"distance\" }, outputs: { revealed: \"revealed\", hidden: \"hidden\" }, viewQueries: [{ propertyName: \"container\", first: true, predicate: [\"container\"], descendants: true, static: true }], ngImport: i0, template: `\n    <div #container [class.revealed]=\"isRevealed()\" [style]=\"containerStyle()\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block}div{transition-property:opacity,transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.revealed{opacity:1!important;transform:translate(0) scale(1) rotate(0)!important}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollRevealComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-scroll-reveal', standalone: true, template: `\n    <div #container [class.revealed]=\"isRevealed()\" [style]=\"containerStyle()\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block}div{transition-property:opacity,transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.revealed{opacity:1!important;transform:translate(0) scale(1) rotate(0)!important}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { animation: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], once: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], revealed: [{\n                type: Output\n            }], hidden: [{\n                type: Output\n            }], container: [{\n                type: ViewChild,\n                args: ['container', { static: true }]\n            }] } });","originalLength":5191,"removedExports":[],"renderedExports":["ScrollRevealComponent"],"renderedLength":4930},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/stagger-list/stagger-list.component.js":{"code":"/**\n * Stagger List Component\n * Animates child elements with staggered delays\n *\n * @example\n * <ngx-stagger-list animation=\"slide-up\" [staggerDelay]=\"100\">\n *   <div class=\"item\">Item 1</div>\n *   <div class=\"item\">Item 2</div>\n *   <div class=\"item\">Item 3</div>\n * </ngx-stagger-list>\n */\nclass StaggerListComponent {\n    el;\n    animation = 'fade';\n    duration = 600;\n    staggerDelay = 100;\n    initialDelay = 0;\n    triggerOnScroll = true;\n    threshold = 0.1;\n    reverse = false;\n    animationStart = new EventEmitter();\n    animationComplete = new EventEmitter();\n    observer;\n    hasAnimated = false;\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            setTimeout(() => this.animateChildren(), this.initialDelay);\n        }\n    }\n    ngAfterContentInit() {\n        // Animation will be triggered by intersection observer or immediately\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animateChildren();\n                    this.hasAnimated = true;\n                }\n                else {\n                    this.hasAnimated = false;\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animateChildren() {\n        const container = this.el.nativeElement.querySelector('.stagger-container');\n        if (!container)\n            return;\n        const children = Array.from(container.children);\n        const itemsToAnimate = this.reverse ? children.reverse() : children;\n        itemsToAnimate.forEach((child, index) => {\n            // Set initial state\n            this.setInitialState(child);\n            // Animate with stagger\n            const delay = this.initialDelay + (index * this.staggerDelay);\n            setTimeout(() => {\n                this.animationStart.emit(index);\n                this.animateElement(child);\n            }, delay);\n            // Emit complete event after last animation\n            if (index === itemsToAnimate.length - 1) {\n                setTimeout(() => {\n                    this.animationComplete.emit();\n                }, delay + this.duration);\n            }\n        });\n    }\n    setInitialState(element) {\n        element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n        switch (this.animation) {\n            case 'fade':\n                element.style.opacity = '0';\n                break;\n            case 'slide-up':\n                element.style.opacity = '0';\n                element.style.transform = 'translateY(30px)';\n                break;\n            case 'slide-down':\n                element.style.opacity = '0';\n                element.style.transform = 'translateY(-30px)';\n                break;\n            case 'scale':\n                element.style.opacity = '0';\n                element.style.transform = 'scale(0.8)';\n                break;\n            case 'rotate':\n                element.style.opacity = '0';\n                element.style.transform = 'rotate(-10deg)';\n                break;\n        }\n    }\n    animateElement(element) {\n        requestAnimationFrame(() => {\n            element.style.opacity = '1';\n            element.style.transform = 'translate(0, 0) scale(1) rotate(0)';\n        });\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: StaggerListComponent, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: StaggerListComponent, isStandalone: true, selector: \"ngx-stagger-list\", inputs: { animation: \"animation\", duration: \"duration\", staggerDelay: \"staggerDelay\", initialDelay: \"initialDelay\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", reverse: \"reverse\" }, outputs: { animationStart: \"animationStart\", animationComplete: \"animationComplete\" }, ngImport: i0, template: `\n    <div class=\"stagger-container\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block}.stagger-container{display:contents}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: StaggerListComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-stagger-list', standalone: true, template: `\n    <div class=\"stagger-container\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block}.stagger-container{display:contents}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { animation: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], staggerDelay: [{\n                type: Input\n            }], initialDelay: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], reverse: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationComplete: [{\n                type: Output\n            }] } });","originalLength":5807,"removedExports":[],"renderedExports":["StaggerListComponent"],"renderedLength":5566},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/typewriter/typewriter.component.js":{"code":"/**\n * Typewriter Component\n * Types out text character by character with RTL support\n *\n * @example\n * <ngx-typewriter [text]=\"'Hello World!'\" [speed]=\"50\"></ngx-typewriter>\n */\nclass TypewriterComponent {\n    text = '';\n    speed = 50; // milliseconds per character\n    delay = 0;\n    showCursor = true;\n    loop = false;\n    deleteSpeed = 30;\n    pauseBeforeDelete = 2000;\n    rtl = false;\n    typingStart = new EventEmitter();\n    typingComplete = new EventEmitter();\n    deletingStart = new EventEmitter();\n    deletingComplete = new EventEmitter();\n    displayedText = signal('', ...(ngDevMode ? [{ debugName: \"displayedText\" }] : []));\n    currentIndex = 0;\n    isDeleting = false;\n    timeoutId;\n    platformId = inject(PLATFORM_ID);\n    constructor() {\n        // Watch for text changes\n        effect(() => {\n            const newText = this.text;\n            if (newText && isPlatformBrowser(this.platformId)) {\n                this.restart();\n            }\n        });\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.displayedText.set(this.text);\n            return;\n        }\n        this.start();\n    }\n    containerStyle() {\n        return this.rtl ? 'direction: rtl; text-align: right;' : '';\n    }\n    start() {\n        if (this.delay > 0) {\n            this.timeoutId = setTimeout(() => this.type(), this.delay);\n        }\n        else {\n            this.type();\n        }\n    }\n    type() {\n        if (!this.isDeleting && this.currentIndex === 0) {\n            this.typingStart.emit();\n        }\n        if (!this.isDeleting) {\n            // Typing forward\n            if (this.currentIndex < this.text.length) {\n                const nextChar = this.text.charAt(this.currentIndex);\n                this.displayedText.update(current => current + nextChar);\n                this.currentIndex++;\n                this.timeoutId = setTimeout(() => this.type(), this.speed);\n            }\n            else {\n                // Finished typing\n                this.typingComplete.emit();\n                if (this.loop) {\n                    this.timeoutId = setTimeout(() => {\n                        this.isDeleting = true;\n                        this.deletingStart.emit();\n                        this.type();\n                    }, this.pauseBeforeDelete);\n                }\n            }\n        }\n        else {\n            // Deleting backward\n            if (this.currentIndex > 0) {\n                this.currentIndex--;\n                this.displayedText.set(this.text.substring(0, this.currentIndex));\n                this.timeoutId = setTimeout(() => this.type(), this.deleteSpeed);\n            }\n            else {\n                // Finished deleting\n                this.deletingComplete.emit();\n                this.isDeleting = false;\n                this.timeoutId = setTimeout(() => this.type(), this.speed);\n            }\n        }\n    }\n    restart() {\n        this.stop();\n        this.currentIndex = 0;\n        this.isDeleting = false;\n        this.displayedText.set('');\n        this.start();\n    }\n    stop() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = undefined;\n        }\n    }\n    ngOnDestroy() {\n        this.stop();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TypewriterComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: TypewriterComponent, isStandalone: true, selector: \"ngx-typewriter\", inputs: { text: \"text\", speed: \"speed\", delay: \"delay\", showCursor: \"showCursor\", loop: \"loop\", deleteSpeed: \"deleteSpeed\", pauseBeforeDelete: \"pauseBeforeDelete\", rtl: \"rtl\" }, outputs: { typingStart: \"typingStart\", typingComplete: \"typingComplete\", deletingStart: \"deletingStart\", deletingComplete: \"deletingComplete\" }, ngImport: i0, template: `\n    <span [class.rtl]=\"rtl\" [style]=\"containerStyle()\">\n      {{ displayedText() }}<span class=\"cursor\" [class.blink]=\"showCursor\">|</span>\n    </span>\n  `, isInline: true, styles: [\":host{display:inline-block}span{font-family:inherit;font-size:inherit;line-height:inherit}.rtl{direction:rtl;unicode-bidi:bidi-override}.cursor{opacity:1;animation:none}.cursor.blink{animation:blink 1s step-end infinite}@keyframes blink{0%,50%{opacity:1}51%,to{opacity:0}}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TypewriterComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-typewriter', standalone: true, template: `\n    <span [class.rtl]=\"rtl\" [style]=\"containerStyle()\">\n      {{ displayedText() }}<span class=\"cursor\" [class.blink]=\"showCursor\">|</span>\n    </span>\n  `, styles: [\":host{display:inline-block}span{font-family:inherit;font-size:inherit;line-height:inherit}.rtl{direction:rtl;unicode-bidi:bidi-override}.cursor{opacity:1;animation:none}.cursor.blink{animation:blink 1s step-end infinite}@keyframes blink{0%,50%{opacity:1}51%,to{opacity:0}}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { text: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], showCursor: [{\n                type: Input\n            }], loop: [{\n                type: Input\n            }], deleteSpeed: [{\n                type: Input\n            }], pauseBeforeDelete: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], typingStart: [{\n                type: Output\n            }], typingComplete: [{\n                type: Output\n            }], deletingStart: [{\n                type: Output\n            }], deletingComplete: [{\n                type: Output\n            }] } });","originalLength":6120,"removedExports":[],"renderedExports":["TypewriterComponent"],"renderedLength":5865},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/marquee/marquee.component.js":{"code":"/**\n * Marquee Component\n * Continuous scrolling text/content with RTL support\n *\n * @example\n * <ngx-marquee [speed]=\"50\" direction=\"left\">\n *   Scrolling text content here...\n * </ngx-marquee>\n */\nclass MarqueeComponent {\n    speed = 50; // pixels per second\n    direction = 'left';\n    pauseOnHover = true;\n    rtl = false;\n    gap = 32; // gap between items in pixels\n    isVertical = signal(false, ...(ngDevMode ? [{ debugName: \"isVertical\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.isVertical.set(this.direction === 'up' || this.direction === 'down');\n    }\n    animationStyle() {\n        const duration = this.calculateDuration();\n        const animationName = this.getAnimationName();\n        const playState = this.pauseOnHover ? 'running' : 'running';\n        const styles = [\n            `animation-name: ${animationName}`,\n            `animation-duration: ${duration}s`,\n            `animation-play-state: ${playState}`,\n            `gap: ${this.gap}px`\n        ];\n        if (this.pauseOnHover) {\n            styles.push('&:hover { animation-play-state: paused; }');\n        }\n        return styles.join('; ');\n    }\n    calculateDuration() {\n        // Duration based on speed (slower speed = longer duration)\n        return 100 / this.speed;\n    }\n    getAnimationName() {\n        if (this.isVertical()) {\n            return this.direction === 'up' ? 'marquee-up' : 'marquee-down';\n        }\n        // For RTL, we might want to reverse the direction\n        if (this.rtl) {\n            return this.direction === 'left' ? 'marquee-right' : 'marquee-left';\n        }\n        return this.direction === 'left' ? 'marquee-left' : 'marquee-right';\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MarqueeComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MarqueeComponent, isStandalone: true, selector: \"ngx-marquee\", inputs: { speed: \"speed\", direction: \"direction\", pauseOnHover: \"pauseOnHover\", rtl: \"rtl\", gap: \"gap\" }, ngImport: i0, template: `\n    <div class=\"marquee-container\" [class.vertical]=\"isVertical()\" [class.rtl]=\"rtl\">\n      <div class=\"marquee-content\" [style]=\"animationStyle()\">\n        <div class=\"marquee-item\">\n          <ng-content></ng-content>\n        </div>\n        <div class=\"marquee-item\" aria-hidden=\"true\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, isInline: true, styles: [\"@keyframes marquee-left{0%{transform:translate(0)}to{transform:translate(-50%)}}@keyframes marquee-right{0%{transform:translate(-50%)}to{transform:translate(0)}}@keyframes marquee-up{0%{transform:translateY(0)}to{transform:translateY(-50%)}}@keyframes marquee-down{0%{transform:translateY(-50%)}to{transform:translateY(0)}}:host .marquee-content:hover{animation-play-state:paused!important}\\n\", \":host{display:block;overflow:hidden}.marquee-container{position:relative;width:100%;height:100%;overflow:hidden}.marquee-container.rtl{direction:rtl}.marquee-content{display:flex;width:fit-content;animation-timing-function:linear;animation-iteration-count:infinite}.marquee-container.vertical .marquee-content{flex-direction:column}.marquee-item{display:flex;align-items:center;white-space:nowrap;padding-right:2rem}.marquee-container.vertical .marquee-item{padding-right:0;padding-bottom:2rem}.marquee-container.rtl .marquee-item{padding-right:0;padding-left:2rem}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MarqueeComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-marquee', standalone: true, template: `\n    <div class=\"marquee-container\" [class.vertical]=\"isVertical()\" [class.rtl]=\"rtl\">\n      <div class=\"marquee-content\" [style]=\"animationStyle()\">\n        <div class=\"marquee-item\">\n          <ng-content></ng-content>\n        </div>\n        <div class=\"marquee-item\" aria-hidden=\"true\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, styles: [\"@keyframes marquee-left{0%{transform:translate(0)}to{transform:translate(-50%)}}@keyframes marquee-right{0%{transform:translate(-50%)}to{transform:translate(0)}}@keyframes marquee-up{0%{transform:translateY(0)}to{transform:translateY(-50%)}}@keyframes marquee-down{0%{transform:translateY(-50%)}to{transform:translateY(0)}}:host .marquee-content:hover{animation-play-state:paused!important}\\n\", \":host{display:block;overflow:hidden}.marquee-container{position:relative;width:100%;height:100%;overflow:hidden}.marquee-container.rtl{direction:rtl}.marquee-content{display:flex;width:fit-content;animation-timing-function:linear;animation-iteration-count:infinite}.marquee-container.vertical .marquee-content{flex-direction:column}.marquee-item{display:flex;align-items:center;white-space:nowrap;padding-right:2rem}.marquee-container.vertical .marquee-item{padding-right:0;padding-bottom:2rem}.marquee-container.rtl .marquee-item{padding-right:0;padding-left:2rem}\\n\"] }]\n        }], propDecorators: { speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], gap: [{\n                type: Input\n            }] } });","originalLength":5705,"removedExports":[],"renderedExports":["MarqueeComponent"],"renderedLength":5483},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/orbit-animation/orbit-animation.component.js":{"code":"/**\n * Orbit Animation Component\n * Rotates content in circular orbit around center point\n *\n * @example\n * <ngx-orbit-animation [radius]=\"100\" [speed]=\"5\">\n *   <div class=\"planet\">üåç</div>\n * </ngx-orbit-animation>\n */\nclass OrbitAnimationComponent {\n    radius = 100; // orbit radius in pixels\n    speed = 5; // seconds per revolution\n    direction = 'clockwise';\n    startAngle = 0; // starting angle in degrees\n    pauseOnHover = false;\n    showPath = false;\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    containerStyle() {\n        const size = this.radius * 2;\n        return `width: ${size}px; height: ${size}px;`;\n    }\n    orbitPathStyle() {\n        const size = this.radius * 2;\n        const animationName = this.direction === 'clockwise' ? 'orbit-clockwise' : 'orbit-counterclockwise';\n        const playState = this.pauseOnHover ? 'paused' : 'running';\n        const styles = [\n            `width: ${size}px`,\n            `height: ${size}px`,\n            `animation-name: ${animationName}`,\n            `animation-duration: ${this.speed}s`,\n            `animation-play-state: ${playState}`\n        ];\n        if (this.showPath) {\n            styles.push('border: 2px dashed rgba(0, 0, 0, 0.1)');\n        }\n        return styles.join('; ');\n    }\n    orbitItemStyle() {\n        const offset = -this.radius;\n        const counterRotation = this.direction === 'clockwise' ? 'orbit-counterclockwise' : 'orbit-clockwise';\n        return [\n            `transform: translate(-50%, -50%) rotate(${this.startAngle}deg) translateX(${this.radius}px)`,\n            `animation: ${counterRotation} ${this.speed}s linear infinite`\n        ].join('; ');\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: OrbitAnimationComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: OrbitAnimationComponent, isStandalone: true, selector: \"ngx-orbit-animation\", inputs: { radius: \"radius\", speed: \"speed\", direction: \"direction\", startAngle: \"startAngle\", pauseOnHover: \"pauseOnHover\", showPath: \"showPath\" }, ngImport: i0, template: `\n    <div class=\"orbit-container\" [style]=\"containerStyle()\">\n      <div class=\"orbit-path\" [style]=\"orbitPathStyle()\">\n        <div class=\"orbit-item\" [style]=\"orbitItemStyle()\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, isInline: true, styles: [\":host{display:inline-block}.orbit-container{position:relative;display:flex;align-items:center;justify-content:center}.orbit-path{position:relative;border-radius:50%;animation-timing-function:linear;animation-iteration-count:infinite}.orbit-item{position:absolute;top:50%;left:50%;transform-origin:center}@keyframes orbit-clockwise{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes orbit-counterclockwise{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: OrbitAnimationComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-orbit-animation', standalone: true, template: `\n    <div class=\"orbit-container\" [style]=\"containerStyle()\">\n      <div class=\"orbit-path\" [style]=\"orbitPathStyle()\">\n        <div class=\"orbit-item\" [style]=\"orbitItemStyle()\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, styles: [\":host{display:inline-block}.orbit-container{position:relative;display:flex;align-items:center;justify-content:center}.orbit-path{position:relative;border-radius:50%;animation-timing-function:linear;animation-iteration-count:infinite}.orbit-item{position:absolute;top:50%;left:50%;transform-origin:center}@keyframes orbit-clockwise{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes orbit-counterclockwise{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}\\n\"] }]\n        }], propDecorators: { radius: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], startAngle: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }], showPath: [{\n                type: Input\n            }] } });","originalLength":4624,"removedExports":[],"renderedExports":["OrbitAnimationComponent"],"renderedLength":4402},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/confetti/confetti.component.js":{"code":"/**\n * Confetti Component\n * Creates a celebratory confetti explosion effect\n *\n * @example\n * <ngx-confetti [particleCount]=\"100\" [duration]=\"3000\"></ngx-confetti>\n */\nclass ConfettiComponent {\n    particleCount = 150;\n    duration = 3000;\n    colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];\n    autoStart = true;\n    canvas;\n    width = signal(window.innerWidth, ...(ngDevMode ? [{ debugName: \"width\" }] : []));\n    height = signal(window.innerHeight, ...(ngDevMode ? [{ debugName: \"height\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    ctx;\n    particles = [];\n    animationId;\n    startTime;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const canvasEl = this.canvas.nativeElement;\n        canvasEl.width = window.innerWidth;\n        canvasEl.height = window.innerHeight;\n        this.ctx = canvasEl.getContext('2d');\n        window.addEventListener('resize', () => this.onResize());\n        if (this.autoStart) {\n            this.start();\n        }\n    }\n    onResize() {\n        const canvasEl = this.canvas.nativeElement;\n        canvasEl.width = window.innerWidth;\n        canvasEl.height = window.innerHeight;\n        this.width.set(window.innerWidth);\n        this.height.set(window.innerHeight);\n    }\n    start() {\n        this.createParticles();\n        this.startTime = Date.now();\n        this.animate();\n    }\n    createParticles() {\n        this.particles = [];\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        for (let i = 0; i < this.particleCount; i++) {\n            const angle = (Math.PI * 2 * i) / this.particleCount;\n            const velocity = 5 + Math.random() * 10;\n            this.particles.push({\n                x: centerX,\n                y: centerY,\n                vx: Math.cos(angle) * velocity,\n                vy: Math.sin(angle) * velocity - Math.random() * 5,\n                rotation: Math.random() * 360,\n                rotationSpeed: (Math.random() - 0.5) * 10,\n                color: this.colors[Math.floor(Math.random() * this.colors.length)],\n                size: 8 + Math.random() * 8,\n                opacity: 1\n            });\n        }\n    }\n    animate() {\n        if (!this.ctx || !this.startTime)\n            return;\n        const elapsed = Date.now() - this.startTime;\n        if (elapsed > this.duration) {\n            this.stop();\n            return;\n        }\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        this.particles.forEach((particle) => {\n            // Update position\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.vy += 0.5; // gravity\n            particle.rotation += particle.rotationSpeed;\n            // Fade out towards end\n            const fadeStart = this.duration * 0.7;\n            if (elapsed > fadeStart) {\n                particle.opacity = 1 - (elapsed - fadeStart) / (this.duration - fadeStart);\n            }\n            // Draw particle\n            if (this.ctx) {\n                this.ctx.save();\n                this.ctx.translate(particle.x, particle.y);\n                this.ctx.rotate((particle.rotation * Math.PI) / 180);\n                this.ctx.globalAlpha = particle.opacity;\n                this.ctx.fillStyle = particle.color;\n                // Draw rectangle confetti\n                this.ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);\n                this.ctx.restore();\n            }\n        });\n        this.animationId = requestAnimationFrame(() => this.animate());\n    }\n    stop() {\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n            this.animationId = undefined;\n        }\n        if (this.ctx) {\n            this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n    }\n    ngOnDestroy() {\n        this.stop();\n        window.removeEventListener('resize', () => this.onResize());\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ConfettiComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ConfettiComponent, isStandalone: true, selector: \"ngx-confetti\", inputs: { particleCount: \"particleCount\", duration: \"duration\", colors: \"colors\", autoStart: \"autoStart\" }, viewQueries: [{ propertyName: \"canvas\", first: true, predicate: [\"canvas\"], descendants: true, static: true }], ngImport: i0, template: `\n    <canvas #canvas [style.width.px]=\"width\" [style.height.px]=\"height\"></canvas>\n  `, isInline: true, styles: [\":host{display:block;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}canvas{width:100%;height:100%}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ConfettiComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-confetti', standalone: true, template: `\n    <canvas #canvas [style.width.px]=\"width\" [style.height.px]=\"height\"></canvas>\n  `, styles: [\":host{display:block;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}canvas{width:100%;height:100%}\\n\"] }]\n        }], propDecorators: { particleCount: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], colors: [{\n                type: Input\n            }], autoStart: [{\n                type: Input\n            }], canvas: [{\n                type: ViewChild,\n                args: ['canvas', { static: true }]\n            }] } });","originalLength":5932,"removedExports":[],"renderedExports":["ConfettiComponent"],"renderedLength":5698},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/text-scramble/text-scramble.component.js":{"code":"/**\n * Text Scramble Component\n * Creates a cool text scrambling effect (GSAP/Matrix-inspired)\n * Text appears to decode/unscramble character by character\n *\n * @example\n * <ngx-text-scramble [text]=\"'Hello World'\" [speed]=\"50\"></ngx-text-scramble>\n */\nclass TextScrambleComponent {\n    text = '';\n    speed = 50; // ms per character\n    scrambleChars = '!<>-_\\\\/[]{}‚Äî=+*^?#________';\n    delay = 0;\n    customClass = '';\n    complete = new EventEmitter();\n    displayedText = signal('', ...(ngDevMode ? [{ debugName: \"displayedText\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    frame = 0;\n    queue = [];\n    rafId;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.displayedText.set(this.text);\n            return;\n        }\n        setTimeout(() => this.scramble(), this.delay);\n    }\n    scramble() {\n        const length = this.text.length;\n        this.queue = [];\n        for (let i = 0; i < length; i++) {\n            const from = this.randomChar();\n            const to = this.text[i];\n            const start = Math.floor(Math.random() * 40);\n            const end = start + Math.floor(Math.random() * 40);\n            this.queue.push({ from, to, start, end });\n        }\n        this.update();\n    }\n    update() {\n        let output = '';\n        let complete = 0;\n        for (let i = 0; i < this.queue.length; i++) {\n            const { from, to, start, end } = this.queue[i];\n            if (this.frame >= end) {\n                complete++;\n                output += to;\n            }\n            else if (this.frame >= start) {\n                output += this.randomChar();\n            }\n            else {\n                output += '';\n            }\n        }\n        this.displayedText.set(output);\n        if (complete === this.queue.length) {\n            this.complete.emit();\n        }\n        else {\n            this.frame++;\n            this.rafId = requestAnimationFrame(() => this.update());\n        }\n    }\n    randomChar() {\n        return this.scrambleChars[Math.floor(Math.random() * this.scrambleChars.length)];\n    }\n    ngOnDestroy() {\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TextScrambleComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: TextScrambleComponent, isStandalone: true, selector: \"ngx-text-scramble\", inputs: { text: \"text\", speed: \"speed\", scrambleChars: \"scrambleChars\", delay: \"delay\", customClass: \"customClass\" }, outputs: { complete: \"complete\" }, ngImport: i0, template: `\n    <span [class]=\"customClass\">{{ displayedText() }}</span>\n  `, isInline: true, styles: [\":host{display:inline-block;font-family:Courier New,monospace}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TextScrambleComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-text-scramble', standalone: true, template: `\n    <span [class]=\"customClass\">{{ displayedText() }}</span>\n  `, styles: [\":host{display:inline-block;font-family:Courier New,monospace}\\n\"] }]\n        }], propDecorators: { text: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], scrambleChars: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], customClass: [{\n                type: Input\n            }], complete: [{\n                type: Output\n            }] } });","originalLength":3893,"removedExports":[],"renderedExports":["TextScrambleComponent"],"renderedLength":3643},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/mouse-follower/mouse-follower.component.js":{"code":"/**\n * Mouse Follower Component\n * Creates a custom cursor that follows the mouse (GSAP-inspired)\n * Adds a premium feel to any website\n *\n * @example\n * <ngx-mouse-follower [size]=\"20\" [color]=\"'#667eea'\"></ngx-mouse-follower>\n */\nclass MouseFollowerComponent {\n    size = 40;\n    dotSize = 8;\n    color = 'rgba(255, 255, 255, 0.5)';\n    dotColor = 'rgba(255, 255, 255, 0.8)';\n    speed = 0.15;\n    transform = signal('translate(-50%, -50%)', ...(ngDevMode ? [{ debugName: \"transform\" }] : []));\n    dotTransform = signal('translate(-50%, -50%)', ...(ngDevMode ? [{ debugName: \"dotTransform\" }] : []));\n    opacity = signal(0, ...(ngDevMode ? [{ debugName: \"opacity\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    mouseX = 0;\n    mouseY = 0;\n    currentX = 0;\n    currentY = 0;\n    dotX = 0;\n    dotY = 0;\n    rafId;\n    mouseMoveHandler;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.mouseMoveHandler = (e) => {\n            this.mouseX = e.clientX;\n            this.mouseY = e.clientY;\n            this.opacity.set(1);\n        };\n        window.addEventListener('mousemove', this.mouseMoveHandler);\n        this.animate();\n    }\n    animate() {\n        // Smooth follow with lerp\n        this.currentX += (this.mouseX - this.currentX) * this.speed;\n        this.currentY += (this.mouseY - this.currentY) * this.speed;\n        // Dot follows instantly\n        this.dotX = this.mouseX;\n        this.dotY = this.mouseY;\n        this.transform.set(`translate(${this.currentX}px, ${this.currentY}px) translate(-50%, -50%)`);\n        this.dotTransform.set(`translate(${this.dotX}px, ${this.dotY}px) translate(-50%, -50%)`);\n        this.rafId = requestAnimationFrame(() => this.animate());\n    }\n    ngOnDestroy() {\n        if (this.mouseMoveHandler) {\n            window.removeEventListener('mousemove', this.mouseMoveHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MouseFollowerComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MouseFollowerComponent, isStandalone: true, selector: \"ngx-mouse-follower\", inputs: { size: \"size\", dotSize: \"dotSize\", color: \"color\", dotColor: \"dotColor\", speed: \"speed\" }, ngImport: i0, template: `\n    <div class=\"mouse-follower\" \n         [style.width.px]=\"size\"\n         [style.height.px]=\"size\"\n         [style.background]=\"color\"\n         [style.transform]=\"transform()\"\n         [style.opacity]=\"opacity()\">\n    </div>\n    <div class=\"mouse-follower-dot\"\n         [style.width.px]=\"dotSize\"\n         [style.height.px]=\"dotSize\"\n         [style.background]=\"dotColor\"\n         [style.transform]=\"dotTransform()\">\n    </div>\n  `, isInline: true, styles: [\":host{pointer-events:none;position:fixed;top:0;left:0;z-index:9999;mix-blend-mode:difference}.mouse-follower{position:fixed;border-radius:50%;pointer-events:none;transition:transform .2s ease-out,opacity .3s;will-change:transform}.mouse-follower-dot{position:fixed;border-radius:50%;pointer-events:none;transition:transform .1s ease-out;will-change:transform}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MouseFollowerComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-mouse-follower', standalone: true, template: `\n    <div class=\"mouse-follower\" \n         [style.width.px]=\"size\"\n         [style.height.px]=\"size\"\n         [style.background]=\"color\"\n         [style.transform]=\"transform()\"\n         [style.opacity]=\"opacity()\">\n    </div>\n    <div class=\"mouse-follower-dot\"\n         [style.width.px]=\"dotSize\"\n         [style.height.px]=\"dotSize\"\n         [style.background]=\"dotColor\"\n         [style.transform]=\"dotTransform()\">\n    </div>\n  `, styles: [\":host{pointer-events:none;position:fixed;top:0;left:0;z-index:9999;mix-blend-mode:difference}.mouse-follower{position:fixed;border-radius:50%;pointer-events:none;transition:transform .2s ease-out,opacity .3s;will-change:transform}.mouse-follower-dot{position:fixed;border-radius:50%;pointer-events:none;transition:transform .1s ease-out;will-change:transform}\\n\"] }]\n        }], propDecorators: { size: [{\n                type: Input\n            }], dotSize: [{\n                type: Input\n            }], color: [{\n                type: Input\n            }], dotColor: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }] } });","originalLength":4875,"removedExports":[],"renderedExports":["MouseFollowerComponent"],"renderedLength":4646},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/profile-card/profile-card.component.js":{"code":"/**\n * Profile Card Component\n * Creates an interactive profile card with gradient background and hover effects\n * Perfect for team showcases, portfolios, and user grids\n *\n * @example\n * <ngx-profile-card\n *   [name]=\"'ÿ≥ÿßÿ±ÿ© ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä'\"\n *   [username]=\"'sara_zahrani@'\"\n *   [jobTitle]=\"'ÿπÿßŸÑŸÖÿ© ÿ®ŸäÿßŸÜÿßÿ™'\"\n *   [gradient]=\"'linear-gradient(135deg, #FF5D36, #763CBC)'\"\n *   icon=\"üìä\">\n * </ngx-profile-card>\n */\nclass ProfileCardComponent {\n    name = '';\n    username = '';\n    jobTitle = '';\n    gradient = 'linear-gradient(135deg, #763CBC, #FF5D36)';\n    icon = 'üë§';\n    iconSvg;\n    stats;\n    showStats = true;\n    enableTilt = true;\n    enableMagnetic = false;\n    magneticStrength = 0.3;\n    tiltMax = 15;\n    tiltGlare = true;\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    get cardClasses() {\n        const classes = ['profile-card'];\n        if (this.enableTilt)\n            classes.push('tilt-enabled');\n        if (this.enableMagnetic)\n            classes.push('magnetic-enabled');\n        return classes.join(' ');\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileCardComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.0\", type: ProfileCardComponent, isStandalone: true, selector: \"ngx-profile-card\", inputs: { name: \"name\", username: \"username\", jobTitle: \"jobTitle\", gradient: \"gradient\", icon: \"icon\", iconSvg: \"iconSvg\", stats: \"stats\", showStats: \"showStats\", enableTilt: \"enableTilt\", enableMagnetic: \"enableMagnetic\", magneticStrength: \"magneticStrength\", tiltMax: \"tiltMax\", tiltGlare: \"tiltGlare\" }, ngImport: i0, template: \"<div \\n  class=\\\"profile-card\\\"\\n  [ngClass]=\\\"cardClasses\\\"\\n  [style.--profile-gradient]=\\\"gradient\\\">\\n  \\n  <div class=\\\"card-content\\\">\\n    <!-- Icon -->\\n    <div class=\\\"card-icon\\\" [style.background]=\\\"gradient\\\">\\n      @if (iconSvg) {\\n        <svg class=\\\"icon-svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\">\\n          <path [attr.d]=\\\"iconSvg\\\" fill=\\\"currentColor\\\"/>\\n        </svg>\\n      } @else {\\n        <span class=\\\"icon-emoji\\\">{{ icon }}</span>\\n      }\\n    </div>\\n\\n    <!-- Name (Arabic) -->\\n    <h3 class=\\\"card-name\\\">{{ name }}</h3>\\n\\n    <!-- Username (English) -->\\n    <p class=\\\"card-username\\\">{{ username }}</p>\\n\\n    <!-- Job Title (Arabic) -->\\n    <p class=\\\"card-job\\\">{{ jobTitle }}</p>\\n\\n    <!-- Stats -->\\n    @if (showStats && stats) {\\n      <div class=\\\"card-stats\\\">\\n        @if (stats.documents !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDCC4</span>\\n            <span class=\\\"stat-value\\\">{{ stats.documents }}</span>\\n          </div>\\n        }\\n        @if (stats.views !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDC41\\uFE0F</span>\\n            <span class=\\\"stat-value\\\">{{ stats.views }}</span>\\n          </div>\\n        }\\n        @if (stats.links !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDD17</span>\\n            <span class=\\\"stat-value\\\">{{ stats.links }}</span>\\n          </div>\\n        }\\n      </div>\\n    }\\n  </div>\\n</div>\\n\\n\", styles: [\".profile-card{position:relative;border-radius:20px;padding:2rem;min-height:280px;display:flex;flex-direction:column;justify-content:space-between;cursor:default;transition:box-shadow .3s ease;overflow:hidden;color:#f7fafc;background:radial-gradient(circle at top left,#ffffff38,#ffffff05),var(--profile-gradient, linear-gradient(135deg, rgba(255, 93, 54, .65), rgba(118, 60, 188, .65)));background-blend-mode:overlay;backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.14);box-shadow:0 18px 45px #0000008c,0 0 0 1px #ffffff08}.card-content{display:flex;flex-direction:column;height:100%;gap:1rem}.card-icon{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff4d,#ffffff0d);border-radius:16px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);margin-bottom:.5rem}.icon-emoji{font-size:3rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.icon-svg{width:48px;height:48px;color:#fff;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.card-name{font-size:1.5rem;font-weight:700;margin:0;line-height:1.3;text-shadow:0 2px 8px rgba(0,0,0,.3)}.card-username{font-size:.95rem;opacity:.9;margin:0;font-weight:500;letter-spacing:.5px}.card-job{font-size:1rem;opacity:.95;margin:0;font-weight:600;text-shadow:0 1px 4px rgba(0,0,0,.2)}.card-stats{display:flex;gap:1rem;margin-top:auto;padding-top:1rem;border-top:1px solid rgba(255,255,255,.2)}.stat-item{display:flex;align-items:center;gap:.5rem;opacity:.9}.stat-icon{font-size:1.1rem;filter:drop-shadow(0 1px 2px rgba(0,0,0,.2))}.stat-value{font-size:.9rem;font-weight:600}[dir=rtl] .profile-card{text-align:right}[dir=rtl] .card-stats{flex-direction:row-reverse}@media(max-width:768px){.profile-card{min-height:240px;padding:1.5rem}.card-icon{width:60px;height:60px}.icon-emoji{font-size:2.5rem}.card-name{font-size:1.25rem}}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"directive\", type: i1.NgClass, selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileCardComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-profile-card', standalone: true, imports: [CommonModule, Tilt3dDirective, MagneticDirective], template: \"<div \\n  class=\\\"profile-card\\\"\\n  [ngClass]=\\\"cardClasses\\\"\\n  [style.--profile-gradient]=\\\"gradient\\\">\\n  \\n  <div class=\\\"card-content\\\">\\n    <!-- Icon -->\\n    <div class=\\\"card-icon\\\" [style.background]=\\\"gradient\\\">\\n      @if (iconSvg) {\\n        <svg class=\\\"icon-svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\">\\n          <path [attr.d]=\\\"iconSvg\\\" fill=\\\"currentColor\\\"/>\\n        </svg>\\n      } @else {\\n        <span class=\\\"icon-emoji\\\">{{ icon }}</span>\\n      }\\n    </div>\\n\\n    <!-- Name (Arabic) -->\\n    <h3 class=\\\"card-name\\\">{{ name }}</h3>\\n\\n    <!-- Username (English) -->\\n    <p class=\\\"card-username\\\">{{ username }}</p>\\n\\n    <!-- Job Title (Arabic) -->\\n    <p class=\\\"card-job\\\">{{ jobTitle }}</p>\\n\\n    <!-- Stats -->\\n    @if (showStats && stats) {\\n      <div class=\\\"card-stats\\\">\\n        @if (stats.documents !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDCC4</span>\\n            <span class=\\\"stat-value\\\">{{ stats.documents }}</span>\\n          </div>\\n        }\\n        @if (stats.views !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDC41\\uFE0F</span>\\n            <span class=\\\"stat-value\\\">{{ stats.views }}</span>\\n          </div>\\n        }\\n        @if (stats.links !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDD17</span>\\n            <span class=\\\"stat-value\\\">{{ stats.links }}</span>\\n          </div>\\n        }\\n      </div>\\n    }\\n  </div>\\n</div>\\n\\n\", styles: [\".profile-card{position:relative;border-radius:20px;padding:2rem;min-height:280px;display:flex;flex-direction:column;justify-content:space-between;cursor:default;transition:box-shadow .3s ease;overflow:hidden;color:#f7fafc;background:radial-gradient(circle at top left,#ffffff38,#ffffff05),var(--profile-gradient, linear-gradient(135deg, rgba(255, 93, 54, .65), rgba(118, 60, 188, .65)));background-blend-mode:overlay;backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.14);box-shadow:0 18px 45px #0000008c,0 0 0 1px #ffffff08}.card-content{display:flex;flex-direction:column;height:100%;gap:1rem}.card-icon{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff4d,#ffffff0d);border-radius:16px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);margin-bottom:.5rem}.icon-emoji{font-size:3rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.icon-svg{width:48px;height:48px;color:#fff;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.card-name{font-size:1.5rem;font-weight:700;margin:0;line-height:1.3;text-shadow:0 2px 8px rgba(0,0,0,.3)}.card-username{font-size:.95rem;opacity:.9;margin:0;font-weight:500;letter-spacing:.5px}.card-job{font-size:1rem;opacity:.95;margin:0;font-weight:600;text-shadow:0 1px 4px rgba(0,0,0,.2)}.card-stats{display:flex;gap:1rem;margin-top:auto;padding-top:1rem;border-top:1px solid rgba(255,255,255,.2)}.stat-item{display:flex;align-items:center;gap:.5rem;opacity:.9}.stat-icon{font-size:1.1rem;filter:drop-shadow(0 1px 2px rgba(0,0,0,.2))}.stat-value{font-size:.9rem;font-weight:600}[dir=rtl] .profile-card{text-align:right}[dir=rtl] .card-stats{flex-direction:row-reverse}@media(max-width:768px){.profile-card{min-height:240px;padding:1.5rem}.card-icon{width:60px;height:60px}.icon-emoji{font-size:2.5rem}.card-name{font-size:1.25rem}}\\n\"] }]\n        }], propDecorators: { name: [{\n                type: Input\n            }], username: [{\n                type: Input\n            }], jobTitle: [{\n                type: Input\n            }], gradient: [{\n                type: Input\n            }], icon: [{\n                type: Input\n            }], iconSvg: [{\n                type: Input\n            }], stats: [{\n                type: Input\n            }], showStats: [{\n                type: Input\n            }], enableTilt: [{\n                type: Input\n            }], enableMagnetic: [{\n                type: Input\n            }], magneticStrength: [{\n                type: Input\n            }], tiltMax: [{\n                type: Input\n            }], tiltGlare: [{\n                type: Input\n            }] } });","originalLength":10422,"removedExports":[],"renderedExports":["ProfileCardComponent"],"renderedLength":9973},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/profile-grid/profile-grid.component.js":{"code":"/**\n * Profile Grid Component\n * Displays a grid of profile cards with stagger animations\n * Perfect for team showcases, user directories, and portfolio grids\n *\n * @example\n * <ngx-profile-grid\n *   [profiles]=\"profileData\"\n *   [columns]=\"4\"\n *   [staggerDelay]=\"100\">\n * </ngx-profile-grid>\n */\nclass ProfileGridComponent {\n    profiles = [];\n    columns = 4; // Number of columns in grid\n    staggerDelay = 100; // Delay between each card animation\n    staggerAnimation = 'slide-up';\n    enableStagger = true;\n    enableScrollReveal = false;\n    gap = 1.5; // Gap in rem units\n    cardHeight = 'auto'; // Card height\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    get gridStyle() {\n        return `\n      grid-template-columns: repeat(${this.columns}, 1fr);\n      gap: ${this.gap}rem;\n    `;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileGridComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.0\", type: ProfileGridComponent, isStandalone: true, selector: \"ngx-profile-grid\", inputs: { profiles: \"profiles\", columns: \"columns\", staggerDelay: \"staggerDelay\", staggerAnimation: \"staggerAnimation\", enableStagger: \"enableStagger\", enableScrollReveal: \"enableScrollReveal\", gap: \"gap\", cardHeight: \"cardHeight\" }, ngImport: i0, template: \"<div class=\\\"profile-grid-container\\\">\\n  @if (enableStagger && !enableScrollReveal) {\\n    <ngx-stagger-list\\n      [animation]=\\\"staggerAnimation\\\"\\n      [staggerDelay]=\\\"staggerDelay\\\"\\n      [triggerOnScroll]=\\\"true\\\">\\n      <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n        @for (profile of profiles; track profile.id || $index) {\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        }\\n      </div>\\n    </ngx-stagger-list>\\n  } @else if (enableScrollReveal) {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-scroll-reveal\\n          animation=\\\"scale\\\"\\n          [delay]=\\\"$index * 50\\\">\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        </ngx-scroll-reveal>\\n      }\\n    </div>\\n  } @else {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-profile-card\\n          [name]=\\\"profile.name\\\"\\n          [username]=\\\"profile.username\\\"\\n          [jobTitle]=\\\"profile.jobTitle\\\"\\n          [gradient]=\\\"profile.gradient\\\"\\n          [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n        </ngx-profile-card>\\n      }\\n    </div>\\n  }\\n</div>\\n\\n\", styles: [\".profile-grid-container{width:100%}.profile-grid{display:grid;width:100%}@media(max-width:1200px){.profile-grid{grid-template-columns:repeat(3,1fr)!important}}@media(max-width:768px){.profile-grid{grid-template-columns:repeat(2,1fr)!important}}@media(max-width:480px){.profile-grid{grid-template-columns:1fr!important}}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"component\", type: ProfileCardComponent, selector: \"ngx-profile-card\", inputs: [\"name\", \"username\", \"jobTitle\", \"gradient\", \"icon\", \"iconSvg\", \"stats\", \"showStats\", \"enableTilt\", \"enableMagnetic\", \"magneticStrength\", \"tiltMax\", \"tiltGlare\"] }, { kind: \"component\", type: StaggerListComponent, selector: \"ngx-stagger-list\", inputs: [\"animation\", \"duration\", \"staggerDelay\", \"initialDelay\", \"triggerOnScroll\", \"threshold\", \"reverse\"], outputs: [\"animationStart\", \"animationComplete\"] }, { kind: \"component\", type: ScrollRevealComponent, selector: \"ngx-scroll-reveal\", inputs: [\"animation\", \"duration\", \"delay\", \"threshold\", \"once\", \"distance\"], outputs: [\"revealed\", \"hidden\"] }] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileGridComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-profile-grid', standalone: true, imports: [\n                        CommonModule,\n                        ProfileCardComponent,\n                        StaggerListComponent,\n                        ScrollRevealComponent\n                    ], template: \"<div class=\\\"profile-grid-container\\\">\\n  @if (enableStagger && !enableScrollReveal) {\\n    <ngx-stagger-list\\n      [animation]=\\\"staggerAnimation\\\"\\n      [staggerDelay]=\\\"staggerDelay\\\"\\n      [triggerOnScroll]=\\\"true\\\">\\n      <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n        @for (profile of profiles; track profile.id || $index) {\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        }\\n      </div>\\n    </ngx-stagger-list>\\n  } @else if (enableScrollReveal) {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-scroll-reveal\\n          animation=\\\"scale\\\"\\n          [delay]=\\\"$index * 50\\\">\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        </ngx-scroll-reveal>\\n      }\\n    </div>\\n  } @else {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-profile-card\\n          [name]=\\\"profile.name\\\"\\n          [username]=\\\"profile.username\\\"\\n          [jobTitle]=\\\"profile.jobTitle\\\"\\n          [gradient]=\\\"profile.gradient\\\"\\n          [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n        </ngx-profile-card>\\n      }\\n    </div>\\n  }\\n</div>\\n\\n\", styles: [\".profile-grid-container{width:100%}.profile-grid{display:grid;width:100%}@media(max-width:1200px){.profile-grid{grid-template-columns:repeat(3,1fr)!important}}@media(max-width:768px){.profile-grid{grid-template-columns:repeat(2,1fr)!important}}@media(max-width:480px){.profile-grid{grid-template-columns:1fr!important}}\\n\"] }]\n        }], propDecorators: { profiles: [{\n                type: Input\n            }], columns: [{\n                type: Input\n            }], staggerDelay: [{\n                type: Input\n            }], staggerAnimation: [{\n                type: Input\n            }], enableStagger: [{\n                type: Input\n            }], enableScrollReveal: [{\n                type: Input\n            }], gap: [{\n                type: Input\n            }], cardHeight: [{\n                type: Input\n            }] } });","originalLength":8315,"removedExports":[],"renderedExports":["ProfileGridComponent"],"renderedLength":7808},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/components/glass-card/glass-card.component.js":{"code":"class GlassCardComponent {\n    /** Slightly larger radius for very rounded cards */\n    borderRadius = '16px';\n    /** Hover lift effect */\n    hover = true;\n    /** Stronger shadow preset */\n    elevated = false;\n    /** Accent border using the primary color */\n    accent = false;\n    get hostRadius() {\n        return this.borderRadius;\n    }\n    get hoverClass() {\n        return this.hover;\n    }\n    get elevatedClass() {\n        return this.elevated;\n    }\n    get accentClass() {\n        return this.accent;\n    }\n    // Small tilt-on-hover effect for extra motion\n    transform = null;\n    onMouseMove(event) {\n        if (!this.hover)\n            return;\n        const rect = event.currentTarget.getBoundingClientRect();\n        const x = (event.clientX - rect.left) / rect.width - 0.5;\n        const y = (event.clientY - rect.top) / rect.height - 0.5;\n        const rotateX = y * -6;\n        const rotateY = x * 6;\n        this.transform = `perspective(700px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-4px)`;\n    }\n    onMouseLeave() {\n        this.transform = null;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlassCardComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: GlassCardComponent, isStandalone: true, selector: \"ngx-glass-card\", inputs: { borderRadius: \"borderRadius\", hover: \"hover\", elevated: \"elevated\", accent: \"accent\" }, host: { listeners: { \"mousemove\": \"onMouseMove($event)\", \"mouseleave\": \"onMouseLeave()\" }, properties: { \"style.borderRadius\": \"this.hostRadius\", \"class.hoverable\": \"this.hoverClass\", \"class.elevated\": \"this.elevatedClass\", \"class.accent-border\": \"this.accentClass\", \"style.transform\": \"this.transform\" } }, ngImport: i0, template: `\n    <div class=\"glass-card-inner\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block;border-radius:16px;overflow:hidden;position:relative;cursor:default;will-change:transform,box-shadow;transition:transform .2s ease,box-shadow .2s ease}.glass-card-inner{position:relative;padding:1.5rem;border-radius:inherit;background:radial-gradient(circle at top left,#ffffff40,#ffffff05);backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.08);box-shadow:0 18px 45px #00000073,0 0 0 1px #ffffff08;color:#f7fafc}:host(.elevated){box-shadow:0 24px 60px #0009,0 0 0 1px #ffffff0f}:host(.hoverable:hover){transform:translateY(-6px)}:host(.accent-border) .glass-card-inner{border:1px solid rgba(255,93,54,.75);box-shadow:0 22px 55px #ff5d3673,0 0 0 1px #ffffff14}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlassCardComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-glass-card', standalone: true, template: `\n    <div class=\"glass-card-inner\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block;border-radius:16px;overflow:hidden;position:relative;cursor:default;will-change:transform,box-shadow;transition:transform .2s ease,box-shadow .2s ease}.glass-card-inner{position:relative;padding:1.5rem;border-radius:inherit;background:radial-gradient(circle at top left,#ffffff40,#ffffff05);backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.08);box-shadow:0 18px 45px #00000073,0 0 0 1px #ffffff08;color:#f7fafc}:host(.elevated){box-shadow:0 24px 60px #0009,0 0 0 1px #ffffff0f}:host(.hoverable:hover){transform:translateY(-6px)}:host(.accent-border) .glass-card-inner{border:1px solid rgba(255,93,54,.75);box-shadow:0 22px 55px #ff5d3673,0 0 0 1px #ffffff14}\\n\"] }]\n        }], propDecorators: { borderRadius: [{\n                type: Input\n            }], hover: [{\n                type: Input\n            }], elevated: [{\n                type: Input\n            }], accent: [{\n                type: Input\n            }], hostRadius: [{\n                type: HostBinding,\n                args: ['style.borderRadius']\n            }], hoverClass: [{\n                type: HostBinding,\n                args: ['class.hoverable']\n            }], elevatedClass: [{\n                type: HostBinding,\n                args: ['class.elevated']\n            }], accentClass: [{\n                type: HostBinding,\n                args: ['class.accent-border']\n            }], transform: [{\n                type: HostBinding,\n                args: ['style.transform']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });","originalLength":4974,"removedExports":[],"renderedExports":["GlassCardComponent"],"renderedLength":4804},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/services/timeline.service.js":{"code":"/**\n * Timeline Service\n * Chain multiple animations in sequence or parallel\n * Similar to GSAP Timeline but Angular-friendly\n *\n * @example\n * const timeline = this.timelineService.create();\n * timeline\n *   .to(element1, { opacity: '1', transform: 'translateX(0)' }, 500)\n *   .to(element2, { opacity: '1' }, 300, 100)\n *   .play();\n */\nclass TimelineService {\n    createTimeline(options) {\n        return new Timeline(options);\n    }\n    // Convenience method\n    create(options) {\n        return this.createTimeline(options);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, deps: [], target: i0.…µ…µFactoryTarget.Injectable });\n    static …µprov = i0.…µ…µngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, providedIn: 'root' });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\nclass Timeline {\n    steps = [];\n    parallelSteps = [];\n    currentStep = 0;\n    isPlaying = false;\n    isPaused = false;\n    options;\n    currentTimeouts = [];\n    constructor(options = {}) {\n        this.options = options;\n    }\n    /**\n     * Add animation step to timeline\n     */\n    to(element, properties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        this.steps.push({\n            element: htmlElement,\n            properties,\n            duration,\n            delay,\n            easing\n        });\n        return this;\n    }\n    /**\n     * Add animation step that starts from current properties\n     */\n    from(element, properties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        // Set initial properties\n        Object.assign(htmlElement.style, properties);\n        // Then animate to normal state\n        const finalProperties = {};\n        Object.keys(properties).forEach(key => {\n            finalProperties[key] = '';\n        });\n        return this.to(htmlElement, finalProperties, duration, delay, easing);\n    }\n    /**\n     * Add animation step relative to current state\n     */\n    fromTo(element, fromProperties, toProperties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        // Set from properties\n        Object.assign(htmlElement.style, fromProperties);\n        // Animate to properties\n        return this.to(htmlElement, toProperties, duration, delay, easing);\n    }\n    /**\n     * Add multiple animations to run in parallel\n     */\n    parallel(callback) {\n        const parallelTimeline = new Timeline();\n        callback(parallelTimeline);\n        this.parallelSteps.push(parallelTimeline.steps);\n        return this;\n    }\n    /**\n     * Add a delay in the timeline\n     */\n    wait(duration) {\n        this.steps.push({\n            element: document.createElement('div'),\n            properties: {},\n            duration,\n            delay: 0\n        });\n        return this;\n    }\n    /**\n     * Add a label for positioning\n     */\n    addLabel(label) {\n        // Labels can be implemented for more complex timelines\n        return this;\n    }\n    /**\n     * Play the timeline\n     */\n    play() {\n        if (this.isPlaying && !this.isPaused)\n            return Promise.resolve();\n        this.isPlaying = true;\n        this.isPaused = false;\n        if (this.options.onStart) {\n            this.options.onStart();\n        }\n        return this.playSteps();\n    }\n    /**\n     * Pause the timeline\n     */\n    pause() {\n        this.isPaused = true;\n        this.clearTimeouts();\n        return this;\n    }\n    /**\n     * Resume the timeline\n     */\n    resume() {\n        if (!this.isPaused)\n            return this;\n        this.isPaused = false;\n        this.playSteps();\n        return this;\n    }\n    /**\n     * Stop and reset the timeline\n     */\n    stop() {\n        this.isPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.clearTimeouts();\n        return this;\n    }\n    /**\n     * Restart the timeline from beginning\n     */\n    restart() {\n        this.stop();\n        return this.play();\n    }\n    /**\n     * Reverse the timeline\n     */\n    reverse() {\n        this.steps.reverse();\n        return this;\n    }\n    async playSteps() {\n        while (this.currentStep < this.steps.length && this.isPlaying && !this.isPaused) {\n            const step = this.steps[this.currentStep];\n            await this.animateStep(step);\n            this.currentStep++;\n        }\n        // Play parallel steps\n        if (this.parallelSteps.length > 0 && this.isPlaying && !this.isPaused) {\n            await this.playParallelSteps();\n        }\n        if (this.currentStep >= this.steps.length && this.isPlaying) {\n            this.onComplete();\n        }\n    }\n    async playParallelSteps() {\n        const promises = this.parallelSteps[0].map(step => this.animateStep(step));\n        await Promise.all(promises);\n        this.parallelSteps.shift();\n    }\n    animateStep(step) {\n        return new Promise((resolve) => {\n            const { element, properties, duration, delay = 0, easing = 'ease' } = step;\n            const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n            // Set transition\n            const transitionProperties = Object.keys(properties).join(', ');\n            htmlElement.style.transition = `${transitionProperties} ${duration}ms ${easing}`;\n            const timeoutId = setTimeout(() => {\n                // Apply properties\n                Object.assign(htmlElement.style, properties);\n                // Resolve after animation completes\n                const completeTimeoutId = setTimeout(() => {\n                    resolve();\n                }, duration);\n                this.currentTimeouts.push(completeTimeoutId);\n            }, delay);\n            this.currentTimeouts.push(timeoutId);\n        });\n    }\n    onComplete() {\n        this.isPlaying = false;\n        this.currentStep = 0;\n        if (this.options.onComplete) {\n            this.options.onComplete();\n        }\n        if (this.options.repeat) {\n            const delay = this.options.repeatDelay || 0;\n            setTimeout(() => {\n                if (this.options.onRepeat) {\n                    this.options.onRepeat();\n                }\n                this.play();\n            }, delay);\n        }\n    }\n    clearTimeouts() {\n        this.currentTimeouts.forEach(timeout => clearTimeout(timeout));\n        this.currentTimeouts = [];\n    }\n}","originalLength":7071,"removedExports":[],"renderedExports":["TimelineService","Timeline"],"renderedLength":6919},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/lib/services/rtl-language.service.js":{"code":"/**\n * RTL & Language Service\n * Provides runtime toggle between LTR/RTL and EN/AR.\n *\n * This is intentionally simple ‚Äì you can use it or plug it into your own i18n layer.\n */\nclass RtlLanguageService {\n    platformId = inject(PLATFORM_ID);\n    /** Current locale: 'en' or 'ar'. Default 'en'. */\n    locale = signal('en', ...(ngDevMode ? [{ debugName: \"locale\" }] : []));\n    /** Text direction derived from locale. */\n    direction = computed(() => this.locale() === 'ar' ? 'rtl' : 'ltr', ...(ngDevMode ? [{ debugName: \"direction\" }] : []));\n    /** True when current direction is RTL. */\n    isRtl = computed(() => this.direction() === 'rtl', ...(ngDevMode ? [{ debugName: \"isRtl\" }] : []));\n    constructor() {\n        // Keep <html> dir/lang in sync with current locale (browser only).\n        effect(() => {\n            if (!isPlatformBrowser(this.platformId))\n                return;\n            const dir = this.direction();\n            const lang = this.locale();\n            document.documentElement.setAttribute('dir', dir);\n            document.documentElement.setAttribute('lang', lang);\n        });\n    }\n    setLocale(locale) {\n        this.locale.set(locale);\n    }\n    toggleLocale() {\n        this.locale.update((current) => (current === 'en' ? 'ar' : 'en'));\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, deps: [], target: i0.…µ…µFactoryTarget.Injectable });\n    static …µprov = i0.…µ…µngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, providedIn: 'root' });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [] });","originalLength":2155,"removedExports":[],"renderedExports":["RtlLanguageService"],"renderedLength":1886},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/public-api.js":{"code":"/*\n * Public API Surface of @elm/ngx-animations\n */\n// Directives - Basic","originalLength":2032,"removedExports":[],"renderedExports":[],"renderedLength":73},"/Users/bananalasmari/Desktop/animation-lib/dist/elm/ngx-animations/tmp-esm2022/elm-ngx-animations.js":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":124,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, signal, inject, PLATFORM_ID, Output, Input, Directive, Renderer2, HostListener, ViewChild, Component, effect, HostBinding, Injectable, ElementRef, computed } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\n * Fade In/Out Directive\n * Applies smooth fade animations to any element\n *\n * @example\n * <div ngxFadeIn [duration]=\"500\" [delay]=\"100\">Content</div>\n */\nclass FadeInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'ease-out';\n    direction = 'in';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    startOpacity = 0;\n    endOpacity = 1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startOpacity when the element leaves the viewport\n     * so the animation can replay on the next entry.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // SSR: Set final state\n            const element = this.el.nativeElement;\n            element.style.opacity = this.endOpacity.toString();\n            return;\n        }\n        const element = this.el.nativeElement;\n        // Set initial state\n        element.style.opacity = this.startOpacity.toString();\n        element.style.transition = `opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit) {\n                        const element = this.el.nativeElement;\n                        element.style.opacity = this.startOpacity.toString();\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // SSR: Set final state immediately\n            const element = this.el.nativeElement;\n            element.style.opacity = this.endOpacity.toString();\n            return;\n        }\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        // Trigger animation on next frame\n        requestAnimationFrame(() => {\n            if (this.direction === 'in' || this.direction === 'in-out') {\n                element.style.opacity = this.endOpacity.toString();\n            }\n            else {\n                element.style.opacity = this.startOpacity.toString();\n            }\n        });\n        // Emit end event after animation completes\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FadeInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: FadeInDirective, isStandalone: true, selector: \"[ngxFadeIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", direction: \"direction\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", startOpacity: \"startOpacity\", endOpacity: \"endOpacity\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FadeInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxFadeIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], startOpacity: [{\n                type: Input\n            }], endOpacity: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Slide In Directive\n * Slides element from specified direction with RTL support\n *\n * @example\n * <div ngxSlideIn direction=\"left\" [duration]=\"500\">Content</div>\n */\nclass SlideInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    direction = 'left';\n    distance = 50;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    rtl = false;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial offset + opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    initialTransform = null;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Detect RTL from element or input\n        const isRTL = this.rtl || getComputedStyle(element).direction === 'rtl';\n        // Adjust direction for RTL\n        let actualDirection = this.direction;\n        if (isRTL) {\n            if (this.direction === 'left')\n                actualDirection = 'right';\n            else if (this.direction === 'right')\n                actualDirection = 'left';\n        }\n        // Set initial transform\n        const transform = this.getTransform(actualDirection, this.distance);\n        this.initialTransform = transform;\n        element.style.transform = transform;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getTransform(direction, distance) {\n        switch (direction) {\n            case 'left':\n                return `translateX(-${distance}px)`;\n            case 'right':\n                return `translateX(${distance}px)`;\n            case 'top':\n                return `translateY(-${distance}px)`;\n            case 'bottom':\n                return `translateY(${distance}px)`;\n            default:\n                return 'translateX(0)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit && this.initialTransform !== null) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = this.initialTransform;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = 'translate(0, 0)';\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: SlideInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: SlideInDirective, isStandalone: true, selector: \"[ngxSlideIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", direction: \"direction\", distance: \"distance\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", rtl: \"rtl\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: SlideInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxSlideIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Scale In Directive\n * Scales element from specified origin point\n *\n * @example\n * <div ngxScaleIn [startScale]=\"0.5\" [duration]=\"500\">Content</div>\n */\nclass ScaleInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    startScale = 0.5;\n    endScale = 1;\n    origin = 'center';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to the startScale and opacity 0 when the element\n     * leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set transform origin\n        element.style.transformOrigin = this.getTransformOrigin();\n        element.style.transform = `scale(${this.startScale})`;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getTransformOrigin() {\n        return this.origin.replace('-', ' ');\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = `scale(${this.startScale})`;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = `scale(${this.endScale})`;\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScaleInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScaleInDirective, isStandalone: true, selector: \"[ngxScaleIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", startScale: \"startScale\", endScale: \"endScale\", origin: \"origin\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScaleInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxScaleIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], startScale: [{\n                type: Input\n            }], endScale: [{\n                type: Input\n            }], origin: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Rotate In Directive\n * Rotates element on specified axis\n *\n * @example\n * <div ngxRotateIn axis=\"y\" [degrees]=\"90\">Content</div>\n */\nclass RotateInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    easing = 'cubic-bezier(0.4, 0, 0.2, 1)';\n    axis = 'z';\n    degrees = 180;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    /**\n     * When true and triggerOnScroll is enabled, the directive will\n     * reset back to its initial rotated state with opacity 0 when the\n     * element leaves the viewport so the animation can replay.\n     */\n    resetOnExit = false;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    initialTransform = null;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial rotation\n        const initial = this.getRotateTransform(this.degrees);\n        this.initialTransform = initial;\n        element.style.transform = initial;\n        element.style.opacity = '0';\n        element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getRotateTransform(degrees) {\n        switch (this.axis) {\n            case 'x':\n                return `rotateX(${degrees}deg)`;\n            case 'y':\n                return `rotateY(${degrees}deg)`;\n            case 'z':\n                return `rotateZ(${degrees}deg)`;\n            default:\n                return `rotate(${degrees}deg)`;\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    // Optionally reset to initial state so animation can replay\n                    if (this.resetOnExit && this.initialTransform !== null) {\n                        const element = this.el.nativeElement;\n                        element.style.transform = this.initialTransform;\n                        element.style.opacity = '0';\n                    }\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        requestAnimationFrame(() => {\n            element.style.transform = this.getRotateTransform(0);\n            element.style.opacity = '1';\n        });\n        setTimeout(() => {\n            this.animationEnd.emit();\n        }, this.duration + this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RotateInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: RotateInDirective, isStandalone: true, selector: \"[ngxRotateIn]\", inputs: { duration: \"duration\", delay: \"delay\", easing: \"easing\", axis: \"axis\", degrees: \"degrees\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", resetOnExit: \"resetOnExit\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RotateInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxRotateIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], easing: [{\n                type: Input\n            }], axis: [{\n                type: Input\n            }], degrees: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], resetOnExit: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Parallax Scroll Directive\n * Creates smooth parallax effect on scroll\n *\n * @example\n * <div ngxParallaxScroll [speed]=\"0.5\">Content</div>\n */\nclass ParallaxScrollDirective {\n    el;\n    speed = 0.5; // 0 to 1, where 1 is normal scroll speed\n    direction = 'vertical';\n    reverse = false;\n    platformId = inject(PLATFORM_ID);\n    scrollHandler;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform';\n        element.style.transition = 'transform 0.1s ease-out';\n        this.scrollHandler = () => {\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n            }\n            this.rafId = requestAnimationFrame(() => {\n                this.updateParallax();\n            });\n        };\n        window.addEventListener('scroll', this.scrollHandler, { passive: true });\n        this.updateParallax();\n    }\n    updateParallax() {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const windowHeight = window.innerHeight;\n        // Calculate how much the element is in view (0 to 1)\n        const elementMiddle = rect.top + rect.height / 2;\n        const scrollProgress = 1 - (elementMiddle / windowHeight);\n        // Apply parallax effect\n        const multiplier = this.reverse ? -1 : 1;\n        const offset = scrollProgress * 100 * this.speed * multiplier;\n        if (this.direction === 'vertical') {\n            element.style.transform = `translateY(${offset}px)`;\n        }\n        else {\n            element.style.transform = `translateX(${offset}px)`;\n        }\n    }\n    ngOnDestroy() {\n        if (this.scrollHandler) {\n            window.removeEventListener('scroll', this.scrollHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ParallaxScrollDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ParallaxScrollDirective, isStandalone: true, selector: \"[ngxParallaxScroll]\", inputs: { speed: \"speed\", direction: \"direction\", reverse: \"reverse\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ParallaxScrollDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxParallaxScroll]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], reverse: [{\n                type: Input\n            }] } });\n\n/**\n * Ripple Click Directive\n * Creates Material Design-style ripple effect on click\n * Modern and performant implementation\n *\n * @example\n * <button ngxRippleClick [rippleColor]=\"'rgba(255, 255, 255, 0.5)'\">Click me</button>\n */\nclass RippleClickDirective {\n    el;\n    rippleColor = 'rgba(255, 255, 255, 0.5)';\n    rippleDuration = 600;\n    rippleRadius = 0; // 0 means auto-calculate\n    centered = false;\n    platformId = inject(PLATFORM_ID);\n    renderer = inject(Renderer2);\n    constructor(el) {\n        this.el = el;\n        this.setupHostElement();\n    }\n    setupHostElement() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const position = getComputedStyle(element).position;\n        if (position === 'static') {\n            this.renderer.setStyle(element, 'position', 'relative');\n        }\n        this.renderer.setStyle(element, 'overflow', 'hidden');\n        this.renderer.setStyle(element, 'user-select', 'none');\n        this.renderer.setStyle(element, '-webkit-tap-highlight-color', 'transparent');\n    }\n    onClick(event) {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.createRipple(event);\n    }\n    createRipple(event) {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        // Calculate ripple position\n        let x, y;\n        if (this.centered) {\n            x = rect.width / 2;\n            y = rect.height / 2;\n        }\n        else {\n            x = event.clientX - rect.left;\n            y = event.clientY - rect.top;\n        }\n        // Calculate ripple size\n        const radius = this.rippleRadius || Math.max(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(y, 2)), Math.sqrt(Math.pow(x, 2) + Math.pow(rect.height - y, 2)), Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(rect.height - y, 2)));\n        // Create ripple element\n        const ripple = this.renderer.createElement('span');\n        this.renderer.addClass(ripple, 'ngx-ripple');\n        // Apply styles\n        const styles = {\n            'position': 'absolute',\n            'border-radius': '50%',\n            'background-color': this.rippleColor,\n            'width': `${radius * 2}px`,\n            'height': `${radius * 2}px`,\n            'left': `${x - radius}px`,\n            'top': `${y - radius}px`,\n            'transform': 'scale(0)',\n            'opacity': '1',\n            'pointer-events': 'none',\n            'transition': `transform ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1), opacity ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`\n        };\n        Object.entries(styles).forEach(([key, value]) => {\n            this.renderer.setStyle(ripple, key, value);\n        });\n        // Add to DOM\n        this.renderer.appendChild(element, ripple);\n        // Trigger animation\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                this.renderer.setStyle(ripple, 'transform', 'scale(1)');\n                this.renderer.setStyle(ripple, 'opacity', '0');\n            });\n        });\n        // Remove after animation\n        setTimeout(() => {\n            this.renderer.removeChild(element, ripple);\n        }, this.rippleDuration);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RippleClickDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: RippleClickDirective, isStandalone: true, selector: \"[ngxRippleClick]\", inputs: { rippleColor: \"rippleColor\", rippleDuration: \"rippleDuration\", rippleRadius: \"rippleRadius\", centered: \"centered\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RippleClickDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxRippleClick]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { rippleColor: [{\n                type: Input\n            }], rippleDuration: [{\n                type: Input\n            }], rippleRadius: [{\n                type: Input\n            }], centered: [{\n                type: Input\n            }], onClick: [{\n                type: HostListener,\n                args: ['click', ['$event']]\n            }] } });\n\n/**\n * Bounce In Directive\n * Creates a playful bounce effect when element appears\n *\n * @example\n * <div ngxBounceIn direction=\"up\" [duration]=\"800\">Bouncy content!</div>\n */\nclass BounceInDirective {\n    el;\n    duration = 800;\n    delay = 0;\n    direction = 'up';\n    distance = 50;\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial state\n        this.setInitialState(element);\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setInitialState(element) {\n        element.style.opacity = '0';\n        element.style.transform = this.getInitialTransform();\n    }\n    getInitialTransform() {\n        switch (this.direction) {\n            case 'up':\n                return `translateY(${this.distance}px) scale(0.3)`;\n            case 'down':\n                return `translateY(-${this.distance}px) scale(0.3)`;\n            case 'left':\n                return `translateX(${this.distance}px) scale(0.3)`;\n            case 'right':\n                return `translateX(-${this.distance}px) scale(0.3)`;\n            case 'center':\n                return 'scale(0.3)';\n            default:\n                return 'scale(0.3)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            // Create bounce keyframes animation\n            const keyframes = [\n                { transform: this.getInitialTransform(), opacity: '0', offset: 0 },\n                { transform: 'translate(0, 0) scale(1.1)', opacity: '1', offset: 0.6 },\n                { transform: 'translate(0, 0) scale(0.95)', opacity: '1', offset: 0.8 },\n                { transform: 'translate(0, 0) scale(1.02)', opacity: '1', offset: 0.9 },\n                { transform: 'translate(0, 0) scale(1)', opacity: '1', offset: 1 }\n            ];\n            element.animate(keyframes, {\n                duration: this.duration,\n                easing: 'ease-out',\n                fill: 'forwards'\n            });\n            setTimeout(() => {\n                element.style.opacity = '1';\n                element.style.transform = 'translate(0, 0) scale(1)';\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: BounceInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: BounceInDirective, isStandalone: true, selector: \"[ngxBounceIn]\", inputs: { duration: \"duration\", delay: \"delay\", direction: \"direction\", distance: \"distance\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: BounceInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxBounceIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Flip In Directive\n * Creates a 3D flip animation effect\n *\n * @example\n * <div ngxFlipIn axis=\"horizontal\" [duration]=\"600\">Flip me!</div>\n */\nclass FlipInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    axis = 'horizontal';\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Add perspective to parent for 3D effect\n        const parent = element.parentElement;\n        if (parent) {\n            parent.style.perspective = '1000px';\n        }\n        // Set initial state\n        element.style.opacity = '0';\n        element.style.transform = this.getInitialTransform();\n        element.style.backfaceVisibility = 'visible';\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    getInitialTransform() {\n        switch (this.axis) {\n            case 'horizontal':\n                return 'rotateY(-90deg)';\n            case 'vertical':\n                return 'rotateX(-90deg)';\n            case 'diagonal':\n                return 'rotate3d(1, 1, 0, -90deg)';\n            default:\n                return 'rotateY(-90deg)';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n            element.style.opacity = '1';\n            element.style.transform = 'rotate3d(0, 0, 0, 0deg)';\n            setTimeout(() => {\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FlipInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: FlipInDirective, isStandalone: true, selector: \"[ngxFlipIn]\", inputs: { duration: \"duration\", delay: \"delay\", axis: \"axis\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: FlipInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxFlipIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], axis: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Shake Directive\n * Creates a shake/wobble effect on interaction or programmatically\n *\n * @example\n * <div ngxShake [shakeOnHover]=\"true\" intensity=\"medium\">Shake on hover!</div>\n */\nclass ShakeDirective {\n    el;\n    intensity = 'medium';\n    duration = 500;\n    shakeOnHover = false;\n    shakeOnClick = false;\n    continuous = false;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        if (this.continuous) {\n            this.startContinuousShake();\n        }\n    }\n    onMouseEnter() {\n        if (this.shakeOnHover) {\n            this.shake();\n        }\n    }\n    onClick() {\n        if (this.shakeOnClick) {\n            this.shake();\n        }\n    }\n    getShakeDistance() {\n        switch (this.intensity) {\n            case 'soft':\n                return 5;\n            case 'medium':\n                return 10;\n            case 'hard':\n                return 15;\n            default:\n                return 10;\n        }\n    }\n    shake() {\n        const element = this.el.nativeElement;\n        const distance = this.getShakeDistance();\n        const keyframes = [\n            { transform: 'translateX(0)' },\n            { transform: `translateX(-${distance}px)` },\n            { transform: `translateX(${distance}px)` },\n            { transform: `translateX(-${distance}px)` },\n            { transform: `translateX(${distance}px)` },\n            { transform: `translateX(-${distance / 2}px)` },\n            { transform: `translateX(${distance / 2}px)` },\n            { transform: 'translateX(0)' }\n        ];\n        element.animate(keyframes, {\n            duration: this.duration,\n            easing: 'ease-in-out'\n        });\n    }\n    startContinuousShake() {\n        this.shake();\n        this.intervalId = setInterval(() => {\n            this.shake();\n        }, this.duration + 2000);\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ShakeDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ShakeDirective, isStandalone: true, selector: \"[ngxShake]\", inputs: { intensity: \"intensity\", duration: \"duration\", shakeOnHover: \"shakeOnHover\", shakeOnClick: \"shakeOnClick\", continuous: \"continuous\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"click\": \"onClick()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ShakeDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxShake]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { intensity: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], shakeOnHover: [{\n                type: Input\n            }], shakeOnClick: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });\n\n/**\n * Pulse Directive\n * Creates a continuous pulsing/heartbeat effect\n *\n * @example\n * <div ngxPulse [speed]=\"1000\" [scale]=\"1.1\">Pulsing content!</div>\n */\nclass PulseDirective {\n    el;\n    speed = 1000; // duration of one pulse cycle\n    scale = 1.05; // how much to scale (1.0 = no scale, 1.1 = 10% larger)\n    continuous = true;\n    pauseOnHover = false;\n    platformId = inject(PLATFORM_ID);\n    animation;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform';\n        if (this.continuous) {\n            this.startPulse();\n        }\n        if (this.pauseOnHover) {\n            element.addEventListener('mouseenter', () => this.pause());\n            element.addEventListener('mouseleave', () => this.resume());\n        }\n    }\n    startPulse() {\n        const element = this.el.nativeElement;\n        const keyframes = [\n            { transform: 'scale(1)', offset: 0 },\n            { transform: `scale(${this.scale})`, offset: 0.5 },\n            { transform: 'scale(1)', offset: 1 }\n        ];\n        this.animation = element.animate(keyframes, {\n            duration: this.speed,\n            iterations: Infinity,\n            easing: 'ease-in-out'\n        });\n    }\n    pause() {\n        if (this.animation) {\n            this.animation.pause();\n        }\n    }\n    resume() {\n        if (this.animation) {\n            this.animation.play();\n        }\n    }\n    ngOnDestroy() {\n        if (this.animation) {\n            this.animation.cancel();\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: PulseDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: PulseDirective, isStandalone: true, selector: \"[ngxPulse]\", inputs: { speed: \"speed\", scale: \"scale\", continuous: \"continuous\", pauseOnHover: \"pauseOnHover\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: PulseDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPulse]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { speed: [{\n                type: Input\n            }], scale: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }] } });\n\n/**\n * Glitch Directive\n * Creates a cool glitch/distortion effect\n *\n * @example\n * <div ngxGlitch [intensity]=\"5\" [speed]=\"3000\">Glitchy text!</div>\n */\nclass GlitchDirective {\n    el;\n    intensity = 3; // 1-10, higher = more glitch\n    speed = 3000; // how often glitch occurs (ms)\n    duration = 200; // how long each glitch lasts\n    continuous = true;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.position = 'relative';\n        element.style.display = 'inline-block';\n        if (this.continuous) {\n            this.startGlitching();\n        }\n    }\n    startGlitching() {\n        this.intervalId = setInterval(() => {\n            this.glitch();\n        }, this.speed);\n    }\n    glitch() {\n        const element = this.el.nativeElement;\n        const originalText = element.textContent || '';\n        // Create glitch effect with text-shadow and transform\n        const glitchKeyframes = [\n            {\n                transform: 'translate(0, 0)',\n                textShadow: `${this.intensity}px 0 red, -${this.intensity}px 0 blue`,\n                offset: 0\n            },\n            {\n                transform: `translate(${this.intensity}px, ${this.intensity}px)`,\n                textShadow: `-${this.intensity}px 0 red, ${this.intensity}px 0 cyan`,\n                offset: 0.25\n            },\n            {\n                transform: `translate(-${this.intensity}px, -${this.intensity}px)`,\n                textShadow: `${this.intensity}px 0 green, -${this.intensity}px 0 magenta`,\n                offset: 0.5\n            },\n            {\n                transform: `translate(${this.intensity}px, -${this.intensity}px)`,\n                textShadow: `-${this.intensity}px 0 yellow, ${this.intensity}px 0 blue`,\n                offset: 0.75\n            },\n            {\n                transform: 'translate(0, 0)',\n                textShadow: 'none',\n                offset: 1\n            }\n        ];\n        element.animate(glitchKeyframes, {\n            duration: this.duration,\n            easing: 'steps(4)'\n        });\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlitchDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: GlitchDirective, isStandalone: true, selector: \"[ngxGlitch]\", inputs: { intensity: \"intensity\", speed: \"speed\", duration: \"duration\", continuous: \"continuous\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlitchDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxGlitch]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { intensity: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }] } });\n\n/**\n * Zoom In Directive\n * Creates various zoom-in effects with different styles\n *\n * @example\n * <div ngxZoomIn style=\"bounce\" [intensity]=\"1.5\">Zoom content!</div>\n */\nclass ZoomInDirective {\n    el;\n    duration = 600;\n    delay = 0;\n    style = 'smooth';\n    intensity = 1.2; // peak zoom scale\n    triggerOnScroll = false;\n    threshold = 0.1;\n    animationStart = new EventEmitter();\n    animationEnd = new EventEmitter();\n    observer;\n    hasAnimated = signal(false, ...(ngDevMode ? [{ debugName: \"hasAnimated\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        // Set initial state\n        element.style.opacity = '0';\n        element.style.transform = 'scale(0)';\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            this.animate();\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animate();\n                    this.hasAnimated.set(true);\n                }\n                else {\n                    this.hasAnimated.set(false);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animate() {\n        const element = this.el.nativeElement;\n        this.animationStart.emit();\n        setTimeout(() => {\n            const keyframes = this.getKeyframes();\n            element.animate(keyframes, {\n                duration: this.duration,\n                easing: this.getEasing(),\n                fill: 'forwards'\n            });\n            setTimeout(() => {\n                element.style.opacity = '1';\n                element.style.transform = 'scale(1)';\n                this.animationEnd.emit();\n            }, this.duration);\n        }, this.delay);\n    }\n    getKeyframes() {\n        switch (this.style) {\n            case 'smooth':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            case 'bounce':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.6 },\n                    { transform: 'scale(0.9)', opacity: '1', offset: 0.8 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            case 'elastic':\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.5 },\n                    { transform: 'scale(0.85)', opacity: '1', offset: 0.7 },\n                    { transform: 'scale(1.05)', opacity: '1', offset: 0.85 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n            default:\n                return [\n                    { transform: 'scale(0)', opacity: '0', offset: 0 },\n                    { transform: 'scale(1)', opacity: '1', offset: 1 }\n                ];\n        }\n    }\n    getEasing() {\n        switch (this.style) {\n            case 'smooth':\n                return 'cubic-bezier(0.4, 0, 0.2, 1)';\n            case 'bounce':\n                return 'ease-out';\n            case 'elastic':\n                return 'ease-out';\n            default:\n                return 'ease-out';\n        }\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ZoomInDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ZoomInDirective, isStandalone: true, selector: \"[ngxZoomIn]\", inputs: { duration: \"duration\", delay: \"delay\", style: \"style\", intensity: \"intensity\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, outputs: { animationStart: \"animationStart\", animationEnd: \"animationEnd\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ZoomInDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxZoomIn]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], style: [{\n                type: Input\n            }], intensity: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationEnd: [{\n                type: Output\n            }] } });\n\n/**\n * Hover Lift Directive\n * Adds a subtle scale + shadow effect on hover.\n *\n * Useful for cards, buttons, and tiles.\n *\n * @example\n * <div ngxHoverLift [liftScale]=\"1.03\" [shadowStrength]=\"0.25\">Card</div>\n */\nclass HoverLiftDirective {\n    el;\n    /** Scale factor on hover (1 = no scale) */\n    liftScale = 1.03;\n    /** Shadow strength 0‚Äì1 */\n    shadowStrength = 0.25;\n    /** Transition duration in ms */\n    hoverDuration = 200;\n    platformId = inject(PLATFORM_ID);\n    originalTransform = '';\n    originalBoxShadow = '';\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const style = getComputedStyle(element);\n        this.originalTransform = style.transform === 'none' ? '' : style.transform;\n        this.originalBoxShadow = style.boxShadow || 'none';\n        element.style.transition =\n            element.style.transition ||\n                `transform ${this.hoverDuration}ms ease-out, box-shadow ${this.hoverDuration}ms ease-out`;\n        element.style.willChange = 'transform, box-shadow';\n    }\n    onEnter() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        const shadowAlpha = this.shadowStrength;\n        const shadow = `0 12px 25px rgba(0, 0, 0, ${shadowAlpha})`;\n        element.style.transform = `${this.originalTransform} scale(${this.liftScale})`.trim();\n        element.style.boxShadow = shadow;\n    }\n    onLeave() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transform = this.originalTransform || 'none';\n        element.style.boxShadow = this.originalBoxShadow;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: HoverLiftDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: HoverLiftDirective, isStandalone: true, selector: \"[ngxHoverLift]\", inputs: { liftScale: \"liftScale\", shadowStrength: \"shadowStrength\", hoverDuration: \"hoverDuration\" }, host: { listeners: { \"mouseenter\": \"onEnter()\", \"mouseleave\": \"onLeave()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: HoverLiftDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxHoverLift]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { liftScale: [{\n                type: Input\n            }], shadowStrength: [{\n                type: Input\n            }], hoverDuration: [{\n                type: Input\n            }], onEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });\n\n/**\n * Count Up Directive\n * Animates numbers from a start value to an end value.\n *\n * @example\n * <span ngxCountUp [end]=\"2500\" [duration]=\"1200\"></span>\n */\nclass CountUpDirective {\n    el;\n    /** Starting value */\n    start = 0;\n    /** Final value */\n    end = 100;\n    /** Duration in ms */\n    duration = 1000;\n    /** Decimal places */\n    decimals = 0;\n    /** Optional prefix (e.g. '$') */\n    prefix = '';\n    /** Optional suffix (e.g. '%') */\n    suffix = '';\n    /** Whether to animate on scroll into view */\n    triggerOnScroll = true;\n    /** Intersection threshold */\n    threshold = 0.2;\n    platformId = inject(PLATFORM_ID);\n    observer;\n    startTime = 0;\n    rafId;\n    hasAnimated = false;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.render(this.end);\n            return;\n        }\n        if (this.triggerOnScroll) {\n            this.setupObserver();\n        }\n        else {\n            this.startAnimation();\n        }\n    }\n    setupObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    if (!this.hasAnimated) {\n                        this.startAnimation();\n                        this.hasAnimated = true;\n                    }\n                }\n                else {\n                    // Reset so animation can play again on next scroll into view\n                    this.hasAnimated = false;\n                    this.render(this.start);\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    startAnimation() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.startTime = performance.now();\n        this.animate();\n    }\n    animate = () => {\n        const now = performance.now();\n        const elapsed = now - this.startTime;\n        const progress = Math.min(elapsed / this.duration, 1);\n        const currentValue = this.start + (this.end - this.start) * progress;\n        this.render(currentValue);\n        if (progress < 1) {\n            this.rafId = requestAnimationFrame(this.animate);\n        }\n    };\n    render(value) {\n        const formatted = this.prefix +\n            value.toFixed(this.decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') +\n            this.suffix;\n        this.el.nativeElement.textContent = formatted;\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n        if (this.rafId)\n            cancelAnimationFrame(this.rafId);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: CountUpDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: CountUpDirective, isStandalone: true, selector: \"[ngxCountUp]\", inputs: { start: \"start\", end: \"end\", duration: \"duration\", decimals: \"decimals\", prefix: \"prefix\", suffix: \"suffix\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: CountUpDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxCountUp]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { start: [{\n                type: Input\n            }], end: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], decimals: [{\n                type: Input\n            }], prefix: [{\n                type: Input\n            }], suffix: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }] } });\n\n/**\n * Magnetic Directive\n * Creates a magnetic pull effect on hover (GSAP-inspired)\n * Elements follow the mouse cursor when hovering\n *\n * @example\n * <button ngxMagnetic [strength]=\"0.5\">Magnetic Button</button>\n */\nclass MagneticDirective {\n    el;\n    strength = 0.4; // 0-1, how strong the magnetic effect is\n    speed = 0.3; // 0-1, how fast it follows\n    platformId = inject(PLATFORM_ID);\n    rect;\n    isHovering = false;\n    currentX = 0;\n    currentY = 0;\n    targetX = 0;\n    targetY = 0;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transition = 'transform 0.1s ease-out';\n        element.style.willChange = 'transform';\n    }\n    onMouseEnter() {\n        this.isHovering = true;\n        this.rect = this.el.nativeElement.getBoundingClientRect();\n        this.animate();\n    }\n    onMouseLeave() {\n        this.isHovering = false;\n        this.targetX = 0;\n        this.targetY = 0;\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n        // Reset to center\n        this.el.nativeElement.style.transform = 'translate(0px, 0px)';\n    }\n    onMouseMove(event) {\n        if (!this.isHovering || !this.rect)\n            return;\n        const x = event.clientX - this.rect.left - this.rect.width / 2;\n        const y = event.clientY - this.rect.top - this.rect.height / 2;\n        this.targetX = x * this.strength;\n        this.targetY = y * this.strength;\n    }\n    animate() {\n        if (!this.isHovering)\n            return;\n        // Smooth lerp (linear interpolation)\n        this.currentX += (this.targetX - this.currentX) * this.speed;\n        this.currentY += (this.targetY - this.currentY) * this.speed;\n        this.el.nativeElement.style.transform =\n            `translate(${this.currentX}px, ${this.currentY}px)`;\n        this.rafId = requestAnimationFrame(() => this.animate());\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MagneticDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MagneticDirective, isStandalone: true, selector: \"[ngxMagnetic]\", inputs: { strength: \"strength\", speed: \"speed\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mouseleave\": \"onMouseLeave()\", \"mousemove\": \"onMouseMove($event)\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MagneticDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxMagnetic]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { strength: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }] } });\n\n/**\n * 3D Tilt Directive\n * Creates a 3D tilt effect following mouse movement (GSAP-inspired)\n * Perfect for cards and interactive elements\n *\n * @example\n * <div ngxTilt3d [maxTilt]=\"15\" [perspective]=\"1000\">3D Card</div>\n */\nclass Tilt3dDirective {\n    el;\n    maxTilt = 20; // Maximum tilt angle in degrees\n    perspective = 1000; // Perspective value\n    scale = 1.05; // Scale on hover\n    speed = 400; // Transition speed in ms\n    glare = false; // Add glare effect\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.transformStyle = 'preserve-3d';\n        element.style.transition = `transform ${this.speed}ms cubic-bezier(0.03, 0.98, 0.52, 0.99)`;\n        element.style.willChange = 'transform';\n        if (this.glare) {\n            this.addGlareEffect();\n        }\n    }\n    addGlareEffect() {\n        const glare = document.createElement('div');\n        glare.className = 'tilt-glare';\n        glare.style.cssText = `\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: linear-gradient(135deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%);\n      opacity: 0;\n      pointer-events: none;\n      transition: opacity ${this.speed}ms;\n      border-radius: inherit;\n    `;\n        this.el.nativeElement.appendChild(glare);\n        this.el.nativeElement.style.position = 'relative';\n        this.el.nativeElement.style.overflow = 'hidden';\n    }\n    onMouseEnter() {\n        const element = this.el.nativeElement;\n        element.style.transform = `perspective(${this.perspective}px) scale(${this.scale})`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare)\n                glare.style.opacity = '1';\n        }\n    }\n    onMouseMove(event) {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const rotateX = ((y - centerY) / centerY) * this.maxTilt;\n        const rotateY = ((centerX - x) / centerX) * this.maxTilt;\n        element.style.transform =\n            `perspective(${this.perspective}px) scale(${this.scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare) {\n                const angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);\n                glare.style.background =\n                    `linear-gradient(${angle}deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%)`;\n            }\n        }\n    }\n    onMouseLeave() {\n        const element = this.el.nativeElement;\n        element.style.transform = `perspective(${this.perspective}px) rotateX(0deg) rotateY(0deg) scale(1)`;\n        if (this.glare) {\n            const glare = element.querySelector('.tilt-glare');\n            if (glare)\n                glare.style.opacity = '0';\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: Tilt3dDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: Tilt3dDirective, isStandalone: true, selector: \"[ngxTilt3d]\", inputs: { maxTilt: \"maxTilt\", perspective: \"perspective\", scale: \"scale\", speed: \"speed\", glare: \"glare\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mousemove\": \"onMouseMove($event)\", \"mouseleave\": \"onMouseLeave()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: Tilt3dDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxTilt3d]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { maxTilt: [{\n                type: Input\n            }], perspective: [{\n                type: Input\n            }], scale: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], glare: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });\n\n/**\n * Scroll Progress Directive\n * Animates elements based on scroll progress (GSAP ScrollTrigger-inspired)\n * Perfect for parallax and scroll-driven animations\n *\n * @example\n * <div ngxScrollProgress [startProgress]=\"0\" [endProgress]=\"100\">Content</div>\n */\nclass ScrollProgressDirective {\n    el;\n    startProgress = 0; // Start at this scroll percentage\n    endProgress = 100; // End at this scroll percentage\n    animateOpacity = true;\n    animateScale = false;\n    animateX = 0; // Translate X distance\n    animateY = 0; // Translate Y distance\n    animateRotate = 0; // Rotation degrees\n    progressChange = new EventEmitter();\n    platformId = inject(PLATFORM_ID);\n    scrollHandler;\n    rafId;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        element.style.willChange = 'transform, opacity';\n        this.scrollHandler = () => {\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n            }\n            this.rafId = requestAnimationFrame(() => this.updateProgress());\n        };\n        window.addEventListener('scroll', this.scrollHandler, { passive: true });\n        this.updateProgress();\n    }\n    updateProgress() {\n        const element = this.el.nativeElement;\n        const rect = element.getBoundingClientRect();\n        const windowHeight = window.innerHeight;\n        // Calculate progress (0 to 1)\n        const elementTop = rect.top;\n        const elementHeight = rect.height;\n        const scrollProgress = (windowHeight - elementTop) / (windowHeight + elementHeight);\n        const clampedProgress = Math.max(0, Math.min(1, scrollProgress));\n        // Map to start/end range\n        const rangeStart = this.startProgress / 100;\n        const rangeEnd = this.endProgress / 100;\n        const normalizedProgress = (clampedProgress - rangeStart) / (rangeEnd - rangeStart);\n        const progress = Math.max(0, Math.min(1, normalizedProgress));\n        this.progressChange.emit(progress);\n        // Apply transformations\n        const transforms = [];\n        if (this.animateX !== 0) {\n            const x = this.animateX * (1 - progress);\n            transforms.push(`translateX(${x}px)`);\n        }\n        if (this.animateY !== 0) {\n            const y = this.animateY * (1 - progress);\n            transforms.push(`translateY(${y}px)`);\n        }\n        if (this.animateScale) {\n            const scale = 0.5 + (progress * 0.5);\n            transforms.push(`scale(${scale})`);\n        }\n        if (this.animateRotate !== 0) {\n            const rotate = this.animateRotate * progress;\n            transforms.push(`rotate(${rotate}deg)`);\n        }\n        element.style.transform = transforms.join(' ');\n        if (this.animateOpacity) {\n            element.style.opacity = progress.toString();\n        }\n    }\n    ngOnDestroy() {\n        if (this.scrollHandler) {\n            window.removeEventListener('scroll', this.scrollHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollProgressDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScrollProgressDirective, isStandalone: true, selector: \"[ngxScrollProgress]\", inputs: { startProgress: \"startProgress\", endProgress: \"endProgress\", animateOpacity: \"animateOpacity\", animateScale: \"animateScale\", animateX: \"animateX\", animateY: \"animateY\", animateRotate: \"animateRotate\" }, outputs: { progressChange: \"progressChange\" }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollProgressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxScrollProgress]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { startProgress: [{\n                type: Input\n            }], endProgress: [{\n                type: Input\n            }], animateOpacity: [{\n                type: Input\n            }], animateScale: [{\n                type: Input\n            }], animateX: [{\n                type: Input\n            }], animateY: [{\n                type: Input\n            }], animateRotate: [{\n                type: Input\n            }], progressChange: [{\n                type: Output\n            }] } });\n\n/**\n * Morph Directive\n * Creates smooth morphing transitions between shapes (GSAP MorphSVG-inspired)\n * Works with border-radius to create organic shape changes\n *\n * @example\n * <div ngxMorph [morphOnHover]=\"true\">Morphing element</div>\n */\nclass MorphDirective {\n    el;\n    morphOnHover = true;\n    morphOnClick = false;\n    duration = 600;\n    continuous = false;\n    platformId = inject(PLATFORM_ID);\n    intervalId;\n    originalBorderRadius;\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const element = this.el.nativeElement;\n        this.originalBorderRadius = getComputedStyle(element).borderRadius || '0px';\n        element.style.transition = `border-radius ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n        if (this.continuous) {\n            this.startContinuousMorph();\n        }\n    }\n    onMouseEnter() {\n        if (this.morphOnHover && !this.continuous) {\n            this.morph();\n        }\n    }\n    onMouseLeave() {\n        if (this.morphOnHover && !this.continuous) {\n            this.reset();\n        }\n    }\n    onClick() {\n        if (this.morphOnClick) {\n            this.morph();\n            setTimeout(() => this.reset(), this.duration);\n        }\n    }\n    morph() {\n        const element = this.el.nativeElement;\n        const shapes = this.getRandomShape();\n        element.style.borderRadius = shapes;\n    }\n    reset() {\n        const element = this.el.nativeElement;\n        element.style.borderRadius = this.originalBorderRadius || '0px';\n    }\n    getRandomShape() {\n        const shapes = [\n            '60% 40% 30% 70% / 60% 30% 70% 40%',\n            '30% 60% 70% 40% / 50% 60% 30% 60%',\n            '60% 40% 60% 40% / 70% 50% 50% 60%',\n            '40% 60% 70% 30% / 40% 50% 60% 50%',\n            '80% 20% 50% 50% / 60% 70% 30% 40%',\n            '50% 50% 30% 70% / 30% 60% 40% 60%'\n        ];\n        return shapes[Math.floor(Math.random() * shapes.length)];\n    }\n    startContinuousMorph() {\n        this.morph();\n        this.intervalId = setInterval(() => {\n            this.morph();\n        }, this.duration + 500);\n    }\n    ngOnDestroy() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MorphDirective, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Directive });\n    static …µdir = i0.…µ…µngDeclareDirective({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MorphDirective, isStandalone: true, selector: \"[ngxMorph]\", inputs: { morphOnHover: \"morphOnHover\", morphOnClick: \"morphOnClick\", duration: \"duration\", continuous: \"continuous\" }, host: { listeners: { \"mouseenter\": \"onMouseEnter()\", \"mouseleave\": \"onMouseLeave()\", \"click\": \"onClick()\" } }, ngImport: i0 });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MorphDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxMorph]',\n                    standalone: true\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { morphOnHover: [{\n                type: Input\n            }], morphOnClick: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], continuous: [{\n                type: Input\n            }], onMouseEnter: [{\n                type: HostListener,\n                args: ['mouseenter']\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });\n\n/**\n * Scroll Reveal Component\n * Reveals content when it comes into viewport\n *\n * @example\n * <ngx-scroll-reveal animation=\"slide-up\">\n *   <h1>Content to reveal</h1>\n * </ngx-scroll-reveal>\n */\nclass ScrollRevealComponent {\n    el;\n    animation = 'fade';\n    duration = 600;\n    delay = 0;\n    threshold = 0.1;\n    once = true;\n    distance = 50;\n    revealed = new EventEmitter();\n    hidden = new EventEmitter();\n    container;\n    isRevealed = signal(false, ...(ngDevMode ? [{ debugName: \"isRevealed\" }] : []));\n    observer;\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.isRevealed.set(true);\n            return;\n        }\n        this.setupIntersectionObserver();\n    }\n    containerStyle() {\n        const styles = [\n            `transition-duration: ${this.duration}ms`,\n            `transition-delay: ${this.delay}ms`\n        ];\n        if (!this.isRevealed()) {\n            styles.push('opacity: 0');\n            styles.push(this.getInitialTransform());\n        }\n        return styles.join('; ');\n    }\n    getInitialTransform() {\n        switch (this.animation) {\n            case 'fade':\n                return 'transform: none';\n            case 'slide-up':\n                return `transform: translateY(${this.distance}px)`;\n            case 'slide-down':\n                return `transform: translateY(-${this.distance}px)`;\n            case 'slide-left':\n                return `transform: translateX(${this.distance}px)`;\n            case 'slide-right':\n                return `transform: translateX(-${this.distance}px)`;\n            case 'scale':\n                return 'transform: scale(0.8)';\n            case 'rotate':\n                return 'transform: rotate(10deg)';\n            default:\n                return 'transform: none';\n        }\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.isRevealed.set(true);\n                    this.revealed.emit();\n                    if (this.once) {\n                        this.observer?.unobserve(entry.target);\n                    }\n                }\n                else if (!this.once) {\n                    this.isRevealed.set(false);\n                    this.hidden.emit();\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollRevealComponent, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ScrollRevealComponent, isStandalone: true, selector: \"ngx-scroll-reveal\", inputs: { animation: \"animation\", duration: \"duration\", delay: \"delay\", threshold: \"threshold\", once: \"once\", distance: \"distance\" }, outputs: { revealed: \"revealed\", hidden: \"hidden\" }, viewQueries: [{ propertyName: \"container\", first: true, predicate: [\"container\"], descendants: true, static: true }], ngImport: i0, template: `\n    <div #container [class.revealed]=\"isRevealed()\" [style]=\"containerStyle()\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block}div{transition-property:opacity,transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.revealed{opacity:1!important;transform:translate(0) scale(1) rotate(0)!important}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ScrollRevealComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-scroll-reveal', standalone: true, template: `\n    <div #container [class.revealed]=\"isRevealed()\" [style]=\"containerStyle()\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block}div{transition-property:opacity,transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.revealed{opacity:1!important;transform:translate(0) scale(1) rotate(0)!important}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { animation: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], once: [{\n                type: Input\n            }], distance: [{\n                type: Input\n            }], revealed: [{\n                type: Output\n            }], hidden: [{\n                type: Output\n            }], container: [{\n                type: ViewChild,\n                args: ['container', { static: true }]\n            }] } });\n\n/**\n * Stagger List Component\n * Animates child elements with staggered delays\n *\n * @example\n * <ngx-stagger-list animation=\"slide-up\" [staggerDelay]=\"100\">\n *   <div class=\"item\">Item 1</div>\n *   <div class=\"item\">Item 2</div>\n *   <div class=\"item\">Item 3</div>\n * </ngx-stagger-list>\n */\nclass StaggerListComponent {\n    el;\n    animation = 'fade';\n    duration = 600;\n    staggerDelay = 100;\n    initialDelay = 0;\n    triggerOnScroll = true;\n    threshold = 0.1;\n    reverse = false;\n    animationStart = new EventEmitter();\n    animationComplete = new EventEmitter();\n    observer;\n    hasAnimated = false;\n    platformId = inject(PLATFORM_ID);\n    constructor(el) {\n        this.el = el;\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        if (this.triggerOnScroll) {\n            this.setupIntersectionObserver();\n        }\n        else {\n            setTimeout(() => this.animateChildren(), this.initialDelay);\n        }\n    }\n    ngAfterContentInit() {\n        // Animation will be triggered by intersection observer or immediately\n    }\n    setupIntersectionObserver() {\n        this.observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    this.animateChildren();\n                    this.hasAnimated = true;\n                }\n                else {\n                    this.hasAnimated = false;\n                }\n            });\n        }, { threshold: this.threshold });\n        this.observer.observe(this.el.nativeElement);\n    }\n    animateChildren() {\n        const container = this.el.nativeElement.querySelector('.stagger-container');\n        if (!container)\n            return;\n        const children = Array.from(container.children);\n        const itemsToAnimate = this.reverse ? children.reverse() : children;\n        itemsToAnimate.forEach((child, index) => {\n            // Set initial state\n            this.setInitialState(child);\n            // Animate with stagger\n            const delay = this.initialDelay + (index * this.staggerDelay);\n            setTimeout(() => {\n                this.animationStart.emit(index);\n                this.animateElement(child);\n            }, delay);\n            // Emit complete event after last animation\n            if (index === itemsToAnimate.length - 1) {\n                setTimeout(() => {\n                    this.animationComplete.emit();\n                }, delay + this.duration);\n            }\n        });\n    }\n    setInitialState(element) {\n        element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\n        switch (this.animation) {\n            case 'fade':\n                element.style.opacity = '0';\n                break;\n            case 'slide-up':\n                element.style.opacity = '0';\n                element.style.transform = 'translateY(30px)';\n                break;\n            case 'slide-down':\n                element.style.opacity = '0';\n                element.style.transform = 'translateY(-30px)';\n                break;\n            case 'scale':\n                element.style.opacity = '0';\n                element.style.transform = 'scale(0.8)';\n                break;\n            case 'rotate':\n                element.style.opacity = '0';\n                element.style.transform = 'rotate(-10deg)';\n                break;\n        }\n    }\n    animateElement(element) {\n        requestAnimationFrame(() => {\n            element.style.opacity = '1';\n            element.style.transform = 'translate(0, 0) scale(1) rotate(0)';\n        });\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: StaggerListComponent, deps: [{ token: i0.ElementRef }], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: StaggerListComponent, isStandalone: true, selector: \"ngx-stagger-list\", inputs: { animation: \"animation\", duration: \"duration\", staggerDelay: \"staggerDelay\", initialDelay: \"initialDelay\", triggerOnScroll: \"triggerOnScroll\", threshold: \"threshold\", reverse: \"reverse\" }, outputs: { animationStart: \"animationStart\", animationComplete: \"animationComplete\" }, ngImport: i0, template: `\n    <div class=\"stagger-container\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block}.stagger-container{display:contents}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: StaggerListComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-stagger-list', standalone: true, template: `\n    <div class=\"stagger-container\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block}.stagger-container{display:contents}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { animation: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], staggerDelay: [{\n                type: Input\n            }], initialDelay: [{\n                type: Input\n            }], triggerOnScroll: [{\n                type: Input\n            }], threshold: [{\n                type: Input\n            }], reverse: [{\n                type: Input\n            }], animationStart: [{\n                type: Output\n            }], animationComplete: [{\n                type: Output\n            }] } });\n\n/**\n * Typewriter Component\n * Types out text character by character with RTL support\n *\n * @example\n * <ngx-typewriter [text]=\"'Hello World!'\" [speed]=\"50\"></ngx-typewriter>\n */\nclass TypewriterComponent {\n    text = '';\n    speed = 50; // milliseconds per character\n    delay = 0;\n    showCursor = true;\n    loop = false;\n    deleteSpeed = 30;\n    pauseBeforeDelete = 2000;\n    rtl = false;\n    typingStart = new EventEmitter();\n    typingComplete = new EventEmitter();\n    deletingStart = new EventEmitter();\n    deletingComplete = new EventEmitter();\n    displayedText = signal('', ...(ngDevMode ? [{ debugName: \"displayedText\" }] : []));\n    currentIndex = 0;\n    isDeleting = false;\n    timeoutId;\n    platformId = inject(PLATFORM_ID);\n    constructor() {\n        // Watch for text changes\n        effect(() => {\n            const newText = this.text;\n            if (newText && isPlatformBrowser(this.platformId)) {\n                this.restart();\n            }\n        });\n    }\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.displayedText.set(this.text);\n            return;\n        }\n        this.start();\n    }\n    containerStyle() {\n        return this.rtl ? 'direction: rtl; text-align: right;' : '';\n    }\n    start() {\n        if (this.delay > 0) {\n            this.timeoutId = setTimeout(() => this.type(), this.delay);\n        }\n        else {\n            this.type();\n        }\n    }\n    type() {\n        if (!this.isDeleting && this.currentIndex === 0) {\n            this.typingStart.emit();\n        }\n        if (!this.isDeleting) {\n            // Typing forward\n            if (this.currentIndex < this.text.length) {\n                const nextChar = this.text.charAt(this.currentIndex);\n                this.displayedText.update(current => current + nextChar);\n                this.currentIndex++;\n                this.timeoutId = setTimeout(() => this.type(), this.speed);\n            }\n            else {\n                // Finished typing\n                this.typingComplete.emit();\n                if (this.loop) {\n                    this.timeoutId = setTimeout(() => {\n                        this.isDeleting = true;\n                        this.deletingStart.emit();\n                        this.type();\n                    }, this.pauseBeforeDelete);\n                }\n            }\n        }\n        else {\n            // Deleting backward\n            if (this.currentIndex > 0) {\n                this.currentIndex--;\n                this.displayedText.set(this.text.substring(0, this.currentIndex));\n                this.timeoutId = setTimeout(() => this.type(), this.deleteSpeed);\n            }\n            else {\n                // Finished deleting\n                this.deletingComplete.emit();\n                this.isDeleting = false;\n                this.timeoutId = setTimeout(() => this.type(), this.speed);\n            }\n        }\n    }\n    restart() {\n        this.stop();\n        this.currentIndex = 0;\n        this.isDeleting = false;\n        this.displayedText.set('');\n        this.start();\n    }\n    stop() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = undefined;\n        }\n    }\n    ngOnDestroy() {\n        this.stop();\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TypewriterComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: TypewriterComponent, isStandalone: true, selector: \"ngx-typewriter\", inputs: { text: \"text\", speed: \"speed\", delay: \"delay\", showCursor: \"showCursor\", loop: \"loop\", deleteSpeed: \"deleteSpeed\", pauseBeforeDelete: \"pauseBeforeDelete\", rtl: \"rtl\" }, outputs: { typingStart: \"typingStart\", typingComplete: \"typingComplete\", deletingStart: \"deletingStart\", deletingComplete: \"deletingComplete\" }, ngImport: i0, template: `\n    <span [class.rtl]=\"rtl\" [style]=\"containerStyle()\">\n      {{ displayedText() }}<span class=\"cursor\" [class.blink]=\"showCursor\">|</span>\n    </span>\n  `, isInline: true, styles: [\":host{display:inline-block}span{font-family:inherit;font-size:inherit;line-height:inherit}.rtl{direction:rtl;unicode-bidi:bidi-override}.cursor{opacity:1;animation:none}.cursor.blink{animation:blink 1s step-end infinite}@keyframes blink{0%,50%{opacity:1}51%,to{opacity:0}}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TypewriterComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-typewriter', standalone: true, template: `\n    <span [class.rtl]=\"rtl\" [style]=\"containerStyle()\">\n      {{ displayedText() }}<span class=\"cursor\" [class.blink]=\"showCursor\">|</span>\n    </span>\n  `, styles: [\":host{display:inline-block}span{font-family:inherit;font-size:inherit;line-height:inherit}.rtl{direction:rtl;unicode-bidi:bidi-override}.cursor{opacity:1;animation:none}.cursor.blink{animation:blink 1s step-end infinite}@keyframes blink{0%,50%{opacity:1}51%,to{opacity:0}}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { text: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], showCursor: [{\n                type: Input\n            }], loop: [{\n                type: Input\n            }], deleteSpeed: [{\n                type: Input\n            }], pauseBeforeDelete: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], typingStart: [{\n                type: Output\n            }], typingComplete: [{\n                type: Output\n            }], deletingStart: [{\n                type: Output\n            }], deletingComplete: [{\n                type: Output\n            }] } });\n\n/**\n * Marquee Component\n * Continuous scrolling text/content with RTL support\n *\n * @example\n * <ngx-marquee [speed]=\"50\" direction=\"left\">\n *   Scrolling text content here...\n * </ngx-marquee>\n */\nclass MarqueeComponent {\n    speed = 50; // pixels per second\n    direction = 'left';\n    pauseOnHover = true;\n    rtl = false;\n    gap = 32; // gap between items in pixels\n    isVertical = signal(false, ...(ngDevMode ? [{ debugName: \"isVertical\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.isVertical.set(this.direction === 'up' || this.direction === 'down');\n    }\n    animationStyle() {\n        const duration = this.calculateDuration();\n        const animationName = this.getAnimationName();\n        const playState = this.pauseOnHover ? 'running' : 'running';\n        const styles = [\n            `animation-name: ${animationName}`,\n            `animation-duration: ${duration}s`,\n            `animation-play-state: ${playState}`,\n            `gap: ${this.gap}px`\n        ];\n        if (this.pauseOnHover) {\n            styles.push('&:hover { animation-play-state: paused; }');\n        }\n        return styles.join('; ');\n    }\n    calculateDuration() {\n        // Duration based on speed (slower speed = longer duration)\n        return 100 / this.speed;\n    }\n    getAnimationName() {\n        if (this.isVertical()) {\n            return this.direction === 'up' ? 'marquee-up' : 'marquee-down';\n        }\n        // For RTL, we might want to reverse the direction\n        if (this.rtl) {\n            return this.direction === 'left' ? 'marquee-right' : 'marquee-left';\n        }\n        return this.direction === 'left' ? 'marquee-left' : 'marquee-right';\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MarqueeComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MarqueeComponent, isStandalone: true, selector: \"ngx-marquee\", inputs: { speed: \"speed\", direction: \"direction\", pauseOnHover: \"pauseOnHover\", rtl: \"rtl\", gap: \"gap\" }, ngImport: i0, template: `\n    <div class=\"marquee-container\" [class.vertical]=\"isVertical()\" [class.rtl]=\"rtl\">\n      <div class=\"marquee-content\" [style]=\"animationStyle()\">\n        <div class=\"marquee-item\">\n          <ng-content></ng-content>\n        </div>\n        <div class=\"marquee-item\" aria-hidden=\"true\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, isInline: true, styles: [\"@keyframes marquee-left{0%{transform:translate(0)}to{transform:translate(-50%)}}@keyframes marquee-right{0%{transform:translate(-50%)}to{transform:translate(0)}}@keyframes marquee-up{0%{transform:translateY(0)}to{transform:translateY(-50%)}}@keyframes marquee-down{0%{transform:translateY(-50%)}to{transform:translateY(0)}}:host .marquee-content:hover{animation-play-state:paused!important}\\n\", \":host{display:block;overflow:hidden}.marquee-container{position:relative;width:100%;height:100%;overflow:hidden}.marquee-container.rtl{direction:rtl}.marquee-content{display:flex;width:fit-content;animation-timing-function:linear;animation-iteration-count:infinite}.marquee-container.vertical .marquee-content{flex-direction:column}.marquee-item{display:flex;align-items:center;white-space:nowrap;padding-right:2rem}.marquee-container.vertical .marquee-item{padding-right:0;padding-bottom:2rem}.marquee-container.rtl .marquee-item{padding-right:0;padding-left:2rem}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MarqueeComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-marquee', standalone: true, template: `\n    <div class=\"marquee-container\" [class.vertical]=\"isVertical()\" [class.rtl]=\"rtl\">\n      <div class=\"marquee-content\" [style]=\"animationStyle()\">\n        <div class=\"marquee-item\">\n          <ng-content></ng-content>\n        </div>\n        <div class=\"marquee-item\" aria-hidden=\"true\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, styles: [\"@keyframes marquee-left{0%{transform:translate(0)}to{transform:translate(-50%)}}@keyframes marquee-right{0%{transform:translate(-50%)}to{transform:translate(0)}}@keyframes marquee-up{0%{transform:translateY(0)}to{transform:translateY(-50%)}}@keyframes marquee-down{0%{transform:translateY(-50%)}to{transform:translateY(0)}}:host .marquee-content:hover{animation-play-state:paused!important}\\n\", \":host{display:block;overflow:hidden}.marquee-container{position:relative;width:100%;height:100%;overflow:hidden}.marquee-container.rtl{direction:rtl}.marquee-content{display:flex;width:fit-content;animation-timing-function:linear;animation-iteration-count:infinite}.marquee-container.vertical .marquee-content{flex-direction:column}.marquee-item{display:flex;align-items:center;white-space:nowrap;padding-right:2rem}.marquee-container.vertical .marquee-item{padding-right:0;padding-bottom:2rem}.marquee-container.rtl .marquee-item{padding-right:0;padding-left:2rem}\\n\"] }]\n        }], propDecorators: { speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }], rtl: [{\n                type: Input\n            }], gap: [{\n                type: Input\n            }] } });\n\n/**\n * Orbit Animation Component\n * Rotates content in circular orbit around center point\n *\n * @example\n * <ngx-orbit-animation [radius]=\"100\" [speed]=\"5\">\n *   <div class=\"planet\">üåç</div>\n * </ngx-orbit-animation>\n */\nclass OrbitAnimationComponent {\n    radius = 100; // orbit radius in pixels\n    speed = 5; // seconds per revolution\n    direction = 'clockwise';\n    startAngle = 0; // starting angle in degrees\n    pauseOnHover = false;\n    showPath = false;\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    containerStyle() {\n        const size = this.radius * 2;\n        return `width: ${size}px; height: ${size}px;`;\n    }\n    orbitPathStyle() {\n        const size = this.radius * 2;\n        const animationName = this.direction === 'clockwise' ? 'orbit-clockwise' : 'orbit-counterclockwise';\n        const playState = this.pauseOnHover ? 'paused' : 'running';\n        const styles = [\n            `width: ${size}px`,\n            `height: ${size}px`,\n            `animation-name: ${animationName}`,\n            `animation-duration: ${this.speed}s`,\n            `animation-play-state: ${playState}`\n        ];\n        if (this.showPath) {\n            styles.push('border: 2px dashed rgba(0, 0, 0, 0.1)');\n        }\n        return styles.join('; ');\n    }\n    orbitItemStyle() {\n        const offset = -this.radius;\n        const counterRotation = this.direction === 'clockwise' ? 'orbit-counterclockwise' : 'orbit-clockwise';\n        return [\n            `transform: translate(-50%, -50%) rotate(${this.startAngle}deg) translateX(${this.radius}px)`,\n            `animation: ${counterRotation} ${this.speed}s linear infinite`\n        ].join('; ');\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: OrbitAnimationComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: OrbitAnimationComponent, isStandalone: true, selector: \"ngx-orbit-animation\", inputs: { radius: \"radius\", speed: \"speed\", direction: \"direction\", startAngle: \"startAngle\", pauseOnHover: \"pauseOnHover\", showPath: \"showPath\" }, ngImport: i0, template: `\n    <div class=\"orbit-container\" [style]=\"containerStyle()\">\n      <div class=\"orbit-path\" [style]=\"orbitPathStyle()\">\n        <div class=\"orbit-item\" [style]=\"orbitItemStyle()\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, isInline: true, styles: [\":host{display:inline-block}.orbit-container{position:relative;display:flex;align-items:center;justify-content:center}.orbit-path{position:relative;border-radius:50%;animation-timing-function:linear;animation-iteration-count:infinite}.orbit-item{position:absolute;top:50%;left:50%;transform-origin:center}@keyframes orbit-clockwise{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes orbit-counterclockwise{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: OrbitAnimationComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-orbit-animation', standalone: true, template: `\n    <div class=\"orbit-container\" [style]=\"containerStyle()\">\n      <div class=\"orbit-path\" [style]=\"orbitPathStyle()\">\n        <div class=\"orbit-item\" [style]=\"orbitItemStyle()\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  `, styles: [\":host{display:inline-block}.orbit-container{position:relative;display:flex;align-items:center;justify-content:center}.orbit-path{position:relative;border-radius:50%;animation-timing-function:linear;animation-iteration-count:infinite}.orbit-item{position:absolute;top:50%;left:50%;transform-origin:center}@keyframes orbit-clockwise{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes orbit-counterclockwise{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}\\n\"] }]\n        }], propDecorators: { radius: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], direction: [{\n                type: Input\n            }], startAngle: [{\n                type: Input\n            }], pauseOnHover: [{\n                type: Input\n            }], showPath: [{\n                type: Input\n            }] } });\n\n/**\n * Confetti Component\n * Creates a celebratory confetti explosion effect\n *\n * @example\n * <ngx-confetti [particleCount]=\"100\" [duration]=\"3000\"></ngx-confetti>\n */\nclass ConfettiComponent {\n    particleCount = 150;\n    duration = 3000;\n    colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];\n    autoStart = true;\n    canvas;\n    width = signal(window.innerWidth, ...(ngDevMode ? [{ debugName: \"width\" }] : []));\n    height = signal(window.innerHeight, ...(ngDevMode ? [{ debugName: \"height\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    ctx;\n    particles = [];\n    animationId;\n    startTime;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        const canvasEl = this.canvas.nativeElement;\n        canvasEl.width = window.innerWidth;\n        canvasEl.height = window.innerHeight;\n        this.ctx = canvasEl.getContext('2d');\n        window.addEventListener('resize', () => this.onResize());\n        if (this.autoStart) {\n            this.start();\n        }\n    }\n    onResize() {\n        const canvasEl = this.canvas.nativeElement;\n        canvasEl.width = window.innerWidth;\n        canvasEl.height = window.innerHeight;\n        this.width.set(window.innerWidth);\n        this.height.set(window.innerHeight);\n    }\n    start() {\n        this.createParticles();\n        this.startTime = Date.now();\n        this.animate();\n    }\n    createParticles() {\n        this.particles = [];\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        for (let i = 0; i < this.particleCount; i++) {\n            const angle = (Math.PI * 2 * i) / this.particleCount;\n            const velocity = 5 + Math.random() * 10;\n            this.particles.push({\n                x: centerX,\n                y: centerY,\n                vx: Math.cos(angle) * velocity,\n                vy: Math.sin(angle) * velocity - Math.random() * 5,\n                rotation: Math.random() * 360,\n                rotationSpeed: (Math.random() - 0.5) * 10,\n                color: this.colors[Math.floor(Math.random() * this.colors.length)],\n                size: 8 + Math.random() * 8,\n                opacity: 1\n            });\n        }\n    }\n    animate() {\n        if (!this.ctx || !this.startTime)\n            return;\n        const elapsed = Date.now() - this.startTime;\n        if (elapsed > this.duration) {\n            this.stop();\n            return;\n        }\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        this.particles.forEach((particle) => {\n            // Update position\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.vy += 0.5; // gravity\n            particle.rotation += particle.rotationSpeed;\n            // Fade out towards end\n            const fadeStart = this.duration * 0.7;\n            if (elapsed > fadeStart) {\n                particle.opacity = 1 - (elapsed - fadeStart) / (this.duration - fadeStart);\n            }\n            // Draw particle\n            if (this.ctx) {\n                this.ctx.save();\n                this.ctx.translate(particle.x, particle.y);\n                this.ctx.rotate((particle.rotation * Math.PI) / 180);\n                this.ctx.globalAlpha = particle.opacity;\n                this.ctx.fillStyle = particle.color;\n                // Draw rectangle confetti\n                this.ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);\n                this.ctx.restore();\n            }\n        });\n        this.animationId = requestAnimationFrame(() => this.animate());\n    }\n    stop() {\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n            this.animationId = undefined;\n        }\n        if (this.ctx) {\n            this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n    }\n    ngOnDestroy() {\n        this.stop();\n        window.removeEventListener('resize', () => this.onResize());\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ConfettiComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: ConfettiComponent, isStandalone: true, selector: \"ngx-confetti\", inputs: { particleCount: \"particleCount\", duration: \"duration\", colors: \"colors\", autoStart: \"autoStart\" }, viewQueries: [{ propertyName: \"canvas\", first: true, predicate: [\"canvas\"], descendants: true, static: true }], ngImport: i0, template: `\n    <canvas #canvas [style.width.px]=\"width\" [style.height.px]=\"height\"></canvas>\n  `, isInline: true, styles: [\":host{display:block;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}canvas{width:100%;height:100%}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ConfettiComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-confetti', standalone: true, template: `\n    <canvas #canvas [style.width.px]=\"width\" [style.height.px]=\"height\"></canvas>\n  `, styles: [\":host{display:block;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}canvas{width:100%;height:100%}\\n\"] }]\n        }], propDecorators: { particleCount: [{\n                type: Input\n            }], duration: [{\n                type: Input\n            }], colors: [{\n                type: Input\n            }], autoStart: [{\n                type: Input\n            }], canvas: [{\n                type: ViewChild,\n                args: ['canvas', { static: true }]\n            }] } });\n\n/**\n * Text Scramble Component\n * Creates a cool text scrambling effect (GSAP/Matrix-inspired)\n * Text appears to decode/unscramble character by character\n *\n * @example\n * <ngx-text-scramble [text]=\"'Hello World'\" [speed]=\"50\"></ngx-text-scramble>\n */\nclass TextScrambleComponent {\n    text = '';\n    speed = 50; // ms per character\n    scrambleChars = '!<>-_\\\\/[]{}‚Äî=+*^?#________';\n    delay = 0;\n    customClass = '';\n    complete = new EventEmitter();\n    displayedText = signal('', ...(ngDevMode ? [{ debugName: \"displayedText\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    frame = 0;\n    queue = [];\n    rafId;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.displayedText.set(this.text);\n            return;\n        }\n        setTimeout(() => this.scramble(), this.delay);\n    }\n    scramble() {\n        const length = this.text.length;\n        this.queue = [];\n        for (let i = 0; i < length; i++) {\n            const from = this.randomChar();\n            const to = this.text[i];\n            const start = Math.floor(Math.random() * 40);\n            const end = start + Math.floor(Math.random() * 40);\n            this.queue.push({ from, to, start, end });\n        }\n        this.update();\n    }\n    update() {\n        let output = '';\n        let complete = 0;\n        for (let i = 0; i < this.queue.length; i++) {\n            const { from, to, start, end } = this.queue[i];\n            if (this.frame >= end) {\n                complete++;\n                output += to;\n            }\n            else if (this.frame >= start) {\n                output += this.randomChar();\n            }\n            else {\n                output += '';\n            }\n        }\n        this.displayedText.set(output);\n        if (complete === this.queue.length) {\n            this.complete.emit();\n        }\n        else {\n            this.frame++;\n            this.rafId = requestAnimationFrame(() => this.update());\n        }\n    }\n    randomChar() {\n        return this.scrambleChars[Math.floor(Math.random() * this.scrambleChars.length)];\n    }\n    ngOnDestroy() {\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TextScrambleComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: TextScrambleComponent, isStandalone: true, selector: \"ngx-text-scramble\", inputs: { text: \"text\", speed: \"speed\", scrambleChars: \"scrambleChars\", delay: \"delay\", customClass: \"customClass\" }, outputs: { complete: \"complete\" }, ngImport: i0, template: `\n    <span [class]=\"customClass\">{{ displayedText() }}</span>\n  `, isInline: true, styles: [\":host{display:inline-block;font-family:Courier New,monospace}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TextScrambleComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-text-scramble', standalone: true, template: `\n    <span [class]=\"customClass\">{{ displayedText() }}</span>\n  `, styles: [\":host{display:inline-block;font-family:Courier New,monospace}\\n\"] }]\n        }], propDecorators: { text: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], scrambleChars: [{\n                type: Input\n            }], delay: [{\n                type: Input\n            }], customClass: [{\n                type: Input\n            }], complete: [{\n                type: Output\n            }] } });\n\n/**\n * Mouse Follower Component\n * Creates a custom cursor that follows the mouse (GSAP-inspired)\n * Adds a premium feel to any website\n *\n * @example\n * <ngx-mouse-follower [size]=\"20\" [color]=\"'#667eea'\"></ngx-mouse-follower>\n */\nclass MouseFollowerComponent {\n    size = 40;\n    dotSize = 8;\n    color = 'rgba(255, 255, 255, 0.5)';\n    dotColor = 'rgba(255, 255, 255, 0.8)';\n    speed = 0.15;\n    transform = signal('translate(-50%, -50%)', ...(ngDevMode ? [{ debugName: \"transform\" }] : []));\n    dotTransform = signal('translate(-50%, -50%)', ...(ngDevMode ? [{ debugName: \"dotTransform\" }] : []));\n    opacity = signal(0, ...(ngDevMode ? [{ debugName: \"opacity\" }] : []));\n    platformId = inject(PLATFORM_ID);\n    mouseX = 0;\n    mouseY = 0;\n    currentX = 0;\n    currentY = 0;\n    dotX = 0;\n    dotY = 0;\n    rafId;\n    mouseMoveHandler;\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n        this.mouseMoveHandler = (e) => {\n            this.mouseX = e.clientX;\n            this.mouseY = e.clientY;\n            this.opacity.set(1);\n        };\n        window.addEventListener('mousemove', this.mouseMoveHandler);\n        this.animate();\n    }\n    animate() {\n        // Smooth follow with lerp\n        this.currentX += (this.mouseX - this.currentX) * this.speed;\n        this.currentY += (this.mouseY - this.currentY) * this.speed;\n        // Dot follows instantly\n        this.dotX = this.mouseX;\n        this.dotY = this.mouseY;\n        this.transform.set(`translate(${this.currentX}px, ${this.currentY}px) translate(-50%, -50%)`);\n        this.dotTransform.set(`translate(${this.dotX}px, ${this.dotY}px) translate(-50%, -50%)`);\n        this.rafId = requestAnimationFrame(() => this.animate());\n    }\n    ngOnDestroy() {\n        if (this.mouseMoveHandler) {\n            window.removeEventListener('mousemove', this.mouseMoveHandler);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MouseFollowerComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: MouseFollowerComponent, isStandalone: true, selector: \"ngx-mouse-follower\", inputs: { size: \"size\", dotSize: \"dotSize\", color: \"color\", dotColor: \"dotColor\", speed: \"speed\" }, ngImport: i0, template: `\n    <div class=\"mouse-follower\" \n         [style.width.px]=\"size\"\n         [style.height.px]=\"size\"\n         [style.background]=\"color\"\n         [style.transform]=\"transform()\"\n         [style.opacity]=\"opacity()\">\n    </div>\n    <div class=\"mouse-follower-dot\"\n         [style.width.px]=\"dotSize\"\n         [style.height.px]=\"dotSize\"\n         [style.background]=\"dotColor\"\n         [style.transform]=\"dotTransform()\">\n    </div>\n  `, isInline: true, styles: [\":host{pointer-events:none;position:fixed;top:0;left:0;z-index:9999;mix-blend-mode:difference}.mouse-follower{position:fixed;border-radius:50%;pointer-events:none;transition:transform .2s ease-out,opacity .3s;will-change:transform}.mouse-follower-dot{position:fixed;border-radius:50%;pointer-events:none;transition:transform .1s ease-out;will-change:transform}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: MouseFollowerComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-mouse-follower', standalone: true, template: `\n    <div class=\"mouse-follower\" \n         [style.width.px]=\"size\"\n         [style.height.px]=\"size\"\n         [style.background]=\"color\"\n         [style.transform]=\"transform()\"\n         [style.opacity]=\"opacity()\">\n    </div>\n    <div class=\"mouse-follower-dot\"\n         [style.width.px]=\"dotSize\"\n         [style.height.px]=\"dotSize\"\n         [style.background]=\"dotColor\"\n         [style.transform]=\"dotTransform()\">\n    </div>\n  `, styles: [\":host{pointer-events:none;position:fixed;top:0;left:0;z-index:9999;mix-blend-mode:difference}.mouse-follower{position:fixed;border-radius:50%;pointer-events:none;transition:transform .2s ease-out,opacity .3s;will-change:transform}.mouse-follower-dot{position:fixed;border-radius:50%;pointer-events:none;transition:transform .1s ease-out;will-change:transform}\\n\"] }]\n        }], propDecorators: { size: [{\n                type: Input\n            }], dotSize: [{\n                type: Input\n            }], color: [{\n                type: Input\n            }], dotColor: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }] } });\n\n/**\n * Profile Card Component\n * Creates an interactive profile card with gradient background and hover effects\n * Perfect for team showcases, portfolios, and user grids\n *\n * @example\n * <ngx-profile-card\n *   [name]=\"'ÿ≥ÿßÿ±ÿ© ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä'\"\n *   [username]=\"'sara_zahrani@'\"\n *   [jobTitle]=\"'ÿπÿßŸÑŸÖÿ© ÿ®ŸäÿßŸÜÿßÿ™'\"\n *   [gradient]=\"'linear-gradient(135deg, #FF5D36, #763CBC)'\"\n *   icon=\"üìä\">\n * </ngx-profile-card>\n */\nclass ProfileCardComponent {\n    name = '';\n    username = '';\n    jobTitle = '';\n    gradient = 'linear-gradient(135deg, #763CBC, #FF5D36)';\n    icon = 'üë§';\n    iconSvg;\n    stats;\n    showStats = true;\n    enableTilt = true;\n    enableMagnetic = false;\n    magneticStrength = 0.3;\n    tiltMax = 15;\n    tiltGlare = true;\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    get cardClasses() {\n        const classes = ['profile-card'];\n        if (this.enableTilt)\n            classes.push('tilt-enabled');\n        if (this.enableMagnetic)\n            classes.push('magnetic-enabled');\n        return classes.join(' ');\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileCardComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.0\", type: ProfileCardComponent, isStandalone: true, selector: \"ngx-profile-card\", inputs: { name: \"name\", username: \"username\", jobTitle: \"jobTitle\", gradient: \"gradient\", icon: \"icon\", iconSvg: \"iconSvg\", stats: \"stats\", showStats: \"showStats\", enableTilt: \"enableTilt\", enableMagnetic: \"enableMagnetic\", magneticStrength: \"magneticStrength\", tiltMax: \"tiltMax\", tiltGlare: \"tiltGlare\" }, ngImport: i0, template: \"<div \\n  class=\\\"profile-card\\\"\\n  [ngClass]=\\\"cardClasses\\\"\\n  [style.--profile-gradient]=\\\"gradient\\\">\\n  \\n  <div class=\\\"card-content\\\">\\n    <!-- Icon -->\\n    <div class=\\\"card-icon\\\" [style.background]=\\\"gradient\\\">\\n      @if (iconSvg) {\\n        <svg class=\\\"icon-svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\">\\n          <path [attr.d]=\\\"iconSvg\\\" fill=\\\"currentColor\\\"/>\\n        </svg>\\n      } @else {\\n        <span class=\\\"icon-emoji\\\">{{ icon }}</span>\\n      }\\n    </div>\\n\\n    <!-- Name (Arabic) -->\\n    <h3 class=\\\"card-name\\\">{{ name }}</h3>\\n\\n    <!-- Username (English) -->\\n    <p class=\\\"card-username\\\">{{ username }}</p>\\n\\n    <!-- Job Title (Arabic) -->\\n    <p class=\\\"card-job\\\">{{ jobTitle }}</p>\\n\\n    <!-- Stats -->\\n    @if (showStats && stats) {\\n      <div class=\\\"card-stats\\\">\\n        @if (stats.documents !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDCC4</span>\\n            <span class=\\\"stat-value\\\">{{ stats.documents }}</span>\\n          </div>\\n        }\\n        @if (stats.views !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDC41\\uFE0F</span>\\n            <span class=\\\"stat-value\\\">{{ stats.views }}</span>\\n          </div>\\n        }\\n        @if (stats.links !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDD17</span>\\n            <span class=\\\"stat-value\\\">{{ stats.links }}</span>\\n          </div>\\n        }\\n      </div>\\n    }\\n  </div>\\n</div>\\n\\n\", styles: [\".profile-card{position:relative;border-radius:20px;padding:2rem;min-height:280px;display:flex;flex-direction:column;justify-content:space-between;cursor:default;transition:box-shadow .3s ease;overflow:hidden;color:#f7fafc;background:radial-gradient(circle at top left,#ffffff38,#ffffff05),var(--profile-gradient, linear-gradient(135deg, rgba(255, 93, 54, .65), rgba(118, 60, 188, .65)));background-blend-mode:overlay;backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.14);box-shadow:0 18px 45px #0000008c,0 0 0 1px #ffffff08}.card-content{display:flex;flex-direction:column;height:100%;gap:1rem}.card-icon{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff4d,#ffffff0d);border-radius:16px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);margin-bottom:.5rem}.icon-emoji{font-size:3rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.icon-svg{width:48px;height:48px;color:#fff;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.card-name{font-size:1.5rem;font-weight:700;margin:0;line-height:1.3;text-shadow:0 2px 8px rgba(0,0,0,.3)}.card-username{font-size:.95rem;opacity:.9;margin:0;font-weight:500;letter-spacing:.5px}.card-job{font-size:1rem;opacity:.95;margin:0;font-weight:600;text-shadow:0 1px 4px rgba(0,0,0,.2)}.card-stats{display:flex;gap:1rem;margin-top:auto;padding-top:1rem;border-top:1px solid rgba(255,255,255,.2)}.stat-item{display:flex;align-items:center;gap:.5rem;opacity:.9}.stat-icon{font-size:1.1rem;filter:drop-shadow(0 1px 2px rgba(0,0,0,.2))}.stat-value{font-size:.9rem;font-weight:600}[dir=rtl] .profile-card{text-align:right}[dir=rtl] .card-stats{flex-direction:row-reverse}@media(max-width:768px){.profile-card{min-height:240px;padding:1.5rem}.card-icon{width:60px;height:60px}.icon-emoji{font-size:2.5rem}.card-name{font-size:1.25rem}}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"directive\", type: i1.NgClass, selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileCardComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-profile-card', standalone: true, imports: [CommonModule, Tilt3dDirective, MagneticDirective], template: \"<div \\n  class=\\\"profile-card\\\"\\n  [ngClass]=\\\"cardClasses\\\"\\n  [style.--profile-gradient]=\\\"gradient\\\">\\n  \\n  <div class=\\\"card-content\\\">\\n    <!-- Icon -->\\n    <div class=\\\"card-icon\\\" [style.background]=\\\"gradient\\\">\\n      @if (iconSvg) {\\n        <svg class=\\\"icon-svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\">\\n          <path [attr.d]=\\\"iconSvg\\\" fill=\\\"currentColor\\\"/>\\n        </svg>\\n      } @else {\\n        <span class=\\\"icon-emoji\\\">{{ icon }}</span>\\n      }\\n    </div>\\n\\n    <!-- Name (Arabic) -->\\n    <h3 class=\\\"card-name\\\">{{ name }}</h3>\\n\\n    <!-- Username (English) -->\\n    <p class=\\\"card-username\\\">{{ username }}</p>\\n\\n    <!-- Job Title (Arabic) -->\\n    <p class=\\\"card-job\\\">{{ jobTitle }}</p>\\n\\n    <!-- Stats -->\\n    @if (showStats && stats) {\\n      <div class=\\\"card-stats\\\">\\n        @if (stats.documents !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDCC4</span>\\n            <span class=\\\"stat-value\\\">{{ stats.documents }}</span>\\n          </div>\\n        }\\n        @if (stats.views !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDC41\\uFE0F</span>\\n            <span class=\\\"stat-value\\\">{{ stats.views }}</span>\\n          </div>\\n        }\\n        @if (stats.links !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">\\uD83D\\uDD17</span>\\n            <span class=\\\"stat-value\\\">{{ stats.links }}</span>\\n          </div>\\n        }\\n      </div>\\n    }\\n  </div>\\n</div>\\n\\n\", styles: [\".profile-card{position:relative;border-radius:20px;padding:2rem;min-height:280px;display:flex;flex-direction:column;justify-content:space-between;cursor:default;transition:box-shadow .3s ease;overflow:hidden;color:#f7fafc;background:radial-gradient(circle at top left,#ffffff38,#ffffff05),var(--profile-gradient, linear-gradient(135deg, rgba(255, 93, 54, .65), rgba(118, 60, 188, .65)));background-blend-mode:overlay;backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.14);box-shadow:0 18px 45px #0000008c,0 0 0 1px #ffffff08}.card-content{display:flex;flex-direction:column;height:100%;gap:1rem}.card-icon{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff4d,#ffffff0d);border-radius:16px;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);margin-bottom:.5rem}.icon-emoji{font-size:3rem;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.icon-svg{width:48px;height:48px;color:#fff;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.card-name{font-size:1.5rem;font-weight:700;margin:0;line-height:1.3;text-shadow:0 2px 8px rgba(0,0,0,.3)}.card-username{font-size:.95rem;opacity:.9;margin:0;font-weight:500;letter-spacing:.5px}.card-job{font-size:1rem;opacity:.95;margin:0;font-weight:600;text-shadow:0 1px 4px rgba(0,0,0,.2)}.card-stats{display:flex;gap:1rem;margin-top:auto;padding-top:1rem;border-top:1px solid rgba(255,255,255,.2)}.stat-item{display:flex;align-items:center;gap:.5rem;opacity:.9}.stat-icon{font-size:1.1rem;filter:drop-shadow(0 1px 2px rgba(0,0,0,.2))}.stat-value{font-size:.9rem;font-weight:600}[dir=rtl] .profile-card{text-align:right}[dir=rtl] .card-stats{flex-direction:row-reverse}@media(max-width:768px){.profile-card{min-height:240px;padding:1.5rem}.card-icon{width:60px;height:60px}.icon-emoji{font-size:2.5rem}.card-name{font-size:1.25rem}}\\n\"] }]\n        }], propDecorators: { name: [{\n                type: Input\n            }], username: [{\n                type: Input\n            }], jobTitle: [{\n                type: Input\n            }], gradient: [{\n                type: Input\n            }], icon: [{\n                type: Input\n            }], iconSvg: [{\n                type: Input\n            }], stats: [{\n                type: Input\n            }], showStats: [{\n                type: Input\n            }], enableTilt: [{\n                type: Input\n            }], enableMagnetic: [{\n                type: Input\n            }], magneticStrength: [{\n                type: Input\n            }], tiltMax: [{\n                type: Input\n            }], tiltGlare: [{\n                type: Input\n            }] } });\n\n/**\n * Profile Grid Component\n * Displays a grid of profile cards with stagger animations\n * Perfect for team showcases, user directories, and portfolio grids\n *\n * @example\n * <ngx-profile-grid\n *   [profiles]=\"profileData\"\n *   [columns]=\"4\"\n *   [staggerDelay]=\"100\">\n * </ngx-profile-grid>\n */\nclass ProfileGridComponent {\n    profiles = [];\n    columns = 4; // Number of columns in grid\n    staggerDelay = 100; // Delay between each card animation\n    staggerAnimation = 'slide-up';\n    enableStagger = true;\n    enableScrollReveal = false;\n    gap = 1.5; // Gap in rem units\n    cardHeight = 'auto'; // Card height\n    platformId = inject(PLATFORM_ID);\n    ngOnInit() {\n        if (!isPlatformBrowser(this.platformId))\n            return;\n    }\n    get gridStyle() {\n        return `\n      grid-template-columns: repeat(${this.columns}, 1fr);\n      gap: ${this.gap}rem;\n    `;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileGridComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.0\", type: ProfileGridComponent, isStandalone: true, selector: \"ngx-profile-grid\", inputs: { profiles: \"profiles\", columns: \"columns\", staggerDelay: \"staggerDelay\", staggerAnimation: \"staggerAnimation\", enableStagger: \"enableStagger\", enableScrollReveal: \"enableScrollReveal\", gap: \"gap\", cardHeight: \"cardHeight\" }, ngImport: i0, template: \"<div class=\\\"profile-grid-container\\\">\\n  @if (enableStagger && !enableScrollReveal) {\\n    <ngx-stagger-list\\n      [animation]=\\\"staggerAnimation\\\"\\n      [staggerDelay]=\\\"staggerDelay\\\"\\n      [triggerOnScroll]=\\\"true\\\">\\n      <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n        @for (profile of profiles; track profile.id || $index) {\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        }\\n      </div>\\n    </ngx-stagger-list>\\n  } @else if (enableScrollReveal) {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-scroll-reveal\\n          animation=\\\"scale\\\"\\n          [delay]=\\\"$index * 50\\\">\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        </ngx-scroll-reveal>\\n      }\\n    </div>\\n  } @else {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-profile-card\\n          [name]=\\\"profile.name\\\"\\n          [username]=\\\"profile.username\\\"\\n          [jobTitle]=\\\"profile.jobTitle\\\"\\n          [gradient]=\\\"profile.gradient\\\"\\n          [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n        </ngx-profile-card>\\n      }\\n    </div>\\n  }\\n</div>\\n\\n\", styles: [\".profile-grid-container{width:100%}.profile-grid{display:grid;width:100%}@media(max-width:1200px){.profile-grid{grid-template-columns:repeat(3,1fr)!important}}@media(max-width:768px){.profile-grid{grid-template-columns:repeat(2,1fr)!important}}@media(max-width:480px){.profile-grid{grid-template-columns:1fr!important}}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"component\", type: ProfileCardComponent, selector: \"ngx-profile-card\", inputs: [\"name\", \"username\", \"jobTitle\", \"gradient\", \"icon\", \"iconSvg\", \"stats\", \"showStats\", \"enableTilt\", \"enableMagnetic\", \"magneticStrength\", \"tiltMax\", \"tiltGlare\"] }, { kind: \"component\", type: StaggerListComponent, selector: \"ngx-stagger-list\", inputs: [\"animation\", \"duration\", \"staggerDelay\", \"initialDelay\", \"triggerOnScroll\", \"threshold\", \"reverse\"], outputs: [\"animationStart\", \"animationComplete\"] }, { kind: \"component\", type: ScrollRevealComponent, selector: \"ngx-scroll-reveal\", inputs: [\"animation\", \"duration\", \"delay\", \"threshold\", \"once\", \"distance\"], outputs: [\"revealed\", \"hidden\"] }] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: ProfileGridComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-profile-grid', standalone: true, imports: [\n                        CommonModule,\n                        ProfileCardComponent,\n                        StaggerListComponent,\n                        ScrollRevealComponent\n                    ], template: \"<div class=\\\"profile-grid-container\\\">\\n  @if (enableStagger && !enableScrollReveal) {\\n    <ngx-stagger-list\\n      [animation]=\\\"staggerAnimation\\\"\\n      [staggerDelay]=\\\"staggerDelay\\\"\\n      [triggerOnScroll]=\\\"true\\\">\\n      <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n        @for (profile of profiles; track profile.id || $index) {\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        }\\n      </div>\\n    </ngx-stagger-list>\\n  } @else if (enableScrollReveal) {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-scroll-reveal\\n          animation=\\\"scale\\\"\\n          [delay]=\\\"$index * 50\\\">\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        </ngx-scroll-reveal>\\n      }\\n    </div>\\n  } @else {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-profile-card\\n          [name]=\\\"profile.name\\\"\\n          [username]=\\\"profile.username\\\"\\n          [jobTitle]=\\\"profile.jobTitle\\\"\\n          [gradient]=\\\"profile.gradient\\\"\\n          [icon]=\\\"profile.icon || '\\uD83D\\uDC64'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n        </ngx-profile-card>\\n      }\\n    </div>\\n  }\\n</div>\\n\\n\", styles: [\".profile-grid-container{width:100%}.profile-grid{display:grid;width:100%}@media(max-width:1200px){.profile-grid{grid-template-columns:repeat(3,1fr)!important}}@media(max-width:768px){.profile-grid{grid-template-columns:repeat(2,1fr)!important}}@media(max-width:480px){.profile-grid{grid-template-columns:1fr!important}}\\n\"] }]\n        }], propDecorators: { profiles: [{\n                type: Input\n            }], columns: [{\n                type: Input\n            }], staggerDelay: [{\n                type: Input\n            }], staggerAnimation: [{\n                type: Input\n            }], enableStagger: [{\n                type: Input\n            }], enableScrollReveal: [{\n                type: Input\n            }], gap: [{\n                type: Input\n            }], cardHeight: [{\n                type: Input\n            }] } });\n\nclass GlassCardComponent {\n    /** Slightly larger radius for very rounded cards */\n    borderRadius = '16px';\n    /** Hover lift effect */\n    hover = true;\n    /** Stronger shadow preset */\n    elevated = false;\n    /** Accent border using the primary color */\n    accent = false;\n    get hostRadius() {\n        return this.borderRadius;\n    }\n    get hoverClass() {\n        return this.hover;\n    }\n    get elevatedClass() {\n        return this.elevated;\n    }\n    get accentClass() {\n        return this.accent;\n    }\n    // Small tilt-on-hover effect for extra motion\n    transform = null;\n    onMouseMove(event) {\n        if (!this.hover)\n            return;\n        const rect = event.currentTarget.getBoundingClientRect();\n        const x = (event.clientX - rect.left) / rect.width - 0.5;\n        const y = (event.clientY - rect.top) / rect.height - 0.5;\n        const rotateX = y * -6;\n        const rotateY = x * 6;\n        this.transform = `perspective(700px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-4px)`;\n    }\n    onMouseLeave() {\n        this.transform = null;\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlassCardComponent, deps: [], target: i0.…µ…µFactoryTarget.Component });\n    static …µcmp = i0.…µ…µngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.0\", type: GlassCardComponent, isStandalone: true, selector: \"ngx-glass-card\", inputs: { borderRadius: \"borderRadius\", hover: \"hover\", elevated: \"elevated\", accent: \"accent\" }, host: { listeners: { \"mousemove\": \"onMouseMove($event)\", \"mouseleave\": \"onMouseLeave()\" }, properties: { \"style.borderRadius\": \"this.hostRadius\", \"class.hoverable\": \"this.hoverClass\", \"class.elevated\": \"this.elevatedClass\", \"class.accent-border\": \"this.accentClass\", \"style.transform\": \"this.transform\" } }, ngImport: i0, template: `\n    <div class=\"glass-card-inner\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host{display:block;border-radius:16px;overflow:hidden;position:relative;cursor:default;will-change:transform,box-shadow;transition:transform .2s ease,box-shadow .2s ease}.glass-card-inner{position:relative;padding:1.5rem;border-radius:inherit;background:radial-gradient(circle at top left,#ffffff40,#ffffff05);backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.08);box-shadow:0 18px 45px #00000073,0 0 0 1px #ffffff08;color:#f7fafc}:host(.elevated){box-shadow:0 24px 60px #0009,0 0 0 1px #ffffff0f}:host(.hoverable:hover){transform:translateY(-6px)}:host(.accent-border) .glass-card-inner{border:1px solid rgba(255,93,54,.75);box-shadow:0 22px 55px #ff5d3673,0 0 0 1px #ffffff14}\\n\"] });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: GlassCardComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-glass-card', standalone: true, template: `\n    <div class=\"glass-card-inner\">\n      <ng-content></ng-content>\n    </div>\n  `, styles: [\":host{display:block;border-radius:16px;overflow:hidden;position:relative;cursor:default;will-change:transform,box-shadow;transition:transform .2s ease,box-shadow .2s ease}.glass-card-inner{position:relative;padding:1.5rem;border-radius:inherit;background:radial-gradient(circle at top left,#ffffff40,#ffffff05);backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px);border:1px solid rgba(255,255,255,.08);box-shadow:0 18px 45px #00000073,0 0 0 1px #ffffff08;color:#f7fafc}:host(.elevated){box-shadow:0 24px 60px #0009,0 0 0 1px #ffffff0f}:host(.hoverable:hover){transform:translateY(-6px)}:host(.accent-border) .glass-card-inner{border:1px solid rgba(255,93,54,.75);box-shadow:0 22px 55px #ff5d3673,0 0 0 1px #ffffff14}\\n\"] }]\n        }], propDecorators: { borderRadius: [{\n                type: Input\n            }], hover: [{\n                type: Input\n            }], elevated: [{\n                type: Input\n            }], accent: [{\n                type: Input\n            }], hostRadius: [{\n                type: HostBinding,\n                args: ['style.borderRadius']\n            }], hoverClass: [{\n                type: HostBinding,\n                args: ['class.hoverable']\n            }], elevatedClass: [{\n                type: HostBinding,\n                args: ['class.elevated']\n            }], accentClass: [{\n                type: HostBinding,\n                args: ['class.accent-border']\n            }], transform: [{\n                type: HostBinding,\n                args: ['style.transform']\n            }], onMouseMove: [{\n                type: HostListener,\n                args: ['mousemove', ['$event']]\n            }], onMouseLeave: [{\n                type: HostListener,\n                args: ['mouseleave']\n            }] } });\n\n/**\n * Timeline Service\n * Chain multiple animations in sequence or parallel\n * Similar to GSAP Timeline but Angular-friendly\n *\n * @example\n * const timeline = this.timelineService.create();\n * timeline\n *   .to(element1, { opacity: '1', transform: 'translateX(0)' }, 500)\n *   .to(element2, { opacity: '1' }, 300, 100)\n *   .play();\n */\nclass TimelineService {\n    createTimeline(options) {\n        return new Timeline(options);\n    }\n    // Convenience method\n    create(options) {\n        return this.createTimeline(options);\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, deps: [], target: i0.…µ…µFactoryTarget.Injectable });\n    static …µprov = i0.…µ…µngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, providedIn: 'root' });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: TimelineService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\nclass Timeline {\n    steps = [];\n    parallelSteps = [];\n    currentStep = 0;\n    isPlaying = false;\n    isPaused = false;\n    options;\n    currentTimeouts = [];\n    constructor(options = {}) {\n        this.options = options;\n    }\n    /**\n     * Add animation step to timeline\n     */\n    to(element, properties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        this.steps.push({\n            element: htmlElement,\n            properties,\n            duration,\n            delay,\n            easing\n        });\n        return this;\n    }\n    /**\n     * Add animation step that starts from current properties\n     */\n    from(element, properties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        // Set initial properties\n        Object.assign(htmlElement.style, properties);\n        // Then animate to normal state\n        const finalProperties = {};\n        Object.keys(properties).forEach(key => {\n            finalProperties[key] = '';\n        });\n        return this.to(htmlElement, finalProperties, duration, delay, easing);\n    }\n    /**\n     * Add animation step relative to current state\n     */\n    fromTo(element, fromProperties, toProperties, duration, delay = 0, easing = 'cubic-bezier(0.4, 0, 0.2, 1)') {\n        const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n        // Set from properties\n        Object.assign(htmlElement.style, fromProperties);\n        // Animate to properties\n        return this.to(htmlElement, toProperties, duration, delay, easing);\n    }\n    /**\n     * Add multiple animations to run in parallel\n     */\n    parallel(callback) {\n        const parallelTimeline = new Timeline();\n        callback(parallelTimeline);\n        this.parallelSteps.push(parallelTimeline.steps);\n        return this;\n    }\n    /**\n     * Add a delay in the timeline\n     */\n    wait(duration) {\n        this.steps.push({\n            element: document.createElement('div'),\n            properties: {},\n            duration,\n            delay: 0\n        });\n        return this;\n    }\n    /**\n     * Add a label for positioning\n     */\n    addLabel(label) {\n        // Labels can be implemented for more complex timelines\n        return this;\n    }\n    /**\n     * Play the timeline\n     */\n    play() {\n        if (this.isPlaying && !this.isPaused)\n            return Promise.resolve();\n        this.isPlaying = true;\n        this.isPaused = false;\n        if (this.options.onStart) {\n            this.options.onStart();\n        }\n        return this.playSteps();\n    }\n    /**\n     * Pause the timeline\n     */\n    pause() {\n        this.isPaused = true;\n        this.clearTimeouts();\n        return this;\n    }\n    /**\n     * Resume the timeline\n     */\n    resume() {\n        if (!this.isPaused)\n            return this;\n        this.isPaused = false;\n        this.playSteps();\n        return this;\n    }\n    /**\n     * Stop and reset the timeline\n     */\n    stop() {\n        this.isPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.clearTimeouts();\n        return this;\n    }\n    /**\n     * Restart the timeline from beginning\n     */\n    restart() {\n        this.stop();\n        return this.play();\n    }\n    /**\n     * Reverse the timeline\n     */\n    reverse() {\n        this.steps.reverse();\n        return this;\n    }\n    async playSteps() {\n        while (this.currentStep < this.steps.length && this.isPlaying && !this.isPaused) {\n            const step = this.steps[this.currentStep];\n            await this.animateStep(step);\n            this.currentStep++;\n        }\n        // Play parallel steps\n        if (this.parallelSteps.length > 0 && this.isPlaying && !this.isPaused) {\n            await this.playParallelSteps();\n        }\n        if (this.currentStep >= this.steps.length && this.isPlaying) {\n            this.onComplete();\n        }\n    }\n    async playParallelSteps() {\n        const promises = this.parallelSteps[0].map(step => this.animateStep(step));\n        await Promise.all(promises);\n        this.parallelSteps.shift();\n    }\n    animateStep(step) {\n        return new Promise((resolve) => {\n            const { element, properties, duration, delay = 0, easing = 'ease' } = step;\n            const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\n            // Set transition\n            const transitionProperties = Object.keys(properties).join(', ');\n            htmlElement.style.transition = `${transitionProperties} ${duration}ms ${easing}`;\n            const timeoutId = setTimeout(() => {\n                // Apply properties\n                Object.assign(htmlElement.style, properties);\n                // Resolve after animation completes\n                const completeTimeoutId = setTimeout(() => {\n                    resolve();\n                }, duration);\n                this.currentTimeouts.push(completeTimeoutId);\n            }, delay);\n            this.currentTimeouts.push(timeoutId);\n        });\n    }\n    onComplete() {\n        this.isPlaying = false;\n        this.currentStep = 0;\n        if (this.options.onComplete) {\n            this.options.onComplete();\n        }\n        if (this.options.repeat) {\n            const delay = this.options.repeatDelay || 0;\n            setTimeout(() => {\n                if (this.options.onRepeat) {\n                    this.options.onRepeat();\n                }\n                this.play();\n            }, delay);\n        }\n    }\n    clearTimeouts() {\n        this.currentTimeouts.forEach(timeout => clearTimeout(timeout));\n        this.currentTimeouts = [];\n    }\n}\n\n/**\n * RTL & Language Service\n * Provides runtime toggle between LTR/RTL and EN/AR.\n *\n * This is intentionally simple ‚Äì you can use it or plug it into your own i18n layer.\n */\nclass RtlLanguageService {\n    platformId = inject(PLATFORM_ID);\n    /** Current locale: 'en' or 'ar'. Default 'en'. */\n    locale = signal('en', ...(ngDevMode ? [{ debugName: \"locale\" }] : []));\n    /** Text direction derived from locale. */\n    direction = computed(() => this.locale() === 'ar' ? 'rtl' : 'ltr', ...(ngDevMode ? [{ debugName: \"direction\" }] : []));\n    /** True when current direction is RTL. */\n    isRtl = computed(() => this.direction() === 'rtl', ...(ngDevMode ? [{ debugName: \"isRtl\" }] : []));\n    constructor() {\n        // Keep <html> dir/lang in sync with current locale (browser only).\n        effect(() => {\n            if (!isPlatformBrowser(this.platformId))\n                return;\n            const dir = this.direction();\n            const lang = this.locale();\n            document.documentElement.setAttribute('dir', dir);\n            document.documentElement.setAttribute('lang', lang);\n        });\n    }\n    setLocale(locale) {\n        this.locale.set(locale);\n    }\n    toggleLocale() {\n        this.locale.update((current) => (current === 'en' ? 'ar' : 'en'));\n    }\n    static …µfac = i0.…µ…µngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, deps: [], target: i0.…µ…µFactoryTarget.Injectable });\n    static …µprov = i0.…µ…µngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, providedIn: 'root' });\n}\ni0.…µ…µngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.0\", ngImport: i0, type: RtlLanguageService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [] });\n\n/*\n * Public API Surface of @elm/ngx-animations\n */\n// Directives - Basic\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BounceInDirective, ConfettiComponent, CountUpDirective, FadeInDirective, FlipInDirective, GlassCardComponent, GlitchDirective, HoverLiftDirective, MagneticDirective, MarqueeComponent, MorphDirective, MouseFollowerComponent, OrbitAnimationComponent, ParallaxScrollDirective, ProfileCardComponent, ProfileGridComponent, PulseDirective, RippleClickDirective, RotateInDirective, RtlLanguageService, ScaleInDirective, ScrollProgressDirective, ScrollRevealComponent, ShakeDirective, SlideInDirective, StaggerListComponent, TextScrambleComponent, Tilt3dDirective, Timeline, TimelineService, TypewriterComponent, ZoomInDirective };\n//# sourceMappingURL=elm-ngx-animations.mjs.map\n","map":null,"preliminaryFileName":"elm-ngx-animations.mjs","sourcemapFileName":"elm-ngx-animations.mjs.map"},{"fileName":"elm-ngx-animations.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"elm-ngx-animations.mjs\",\"sources\":[\"../../../../projects/elm/ngx-animations/src/lib/directives/fade-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/slide-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/scale-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/rotate-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/parallax-scroll.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/ripple-click.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/bounce-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/flip-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/shake.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/pulse.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/glitch.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/zoom-in.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/hover-lift.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/count-up.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/magnetic.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/tilt-3d.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/scroll-progress.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/directives/morph.directive.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/scroll-reveal/scroll-reveal.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/stagger-list/stagger-list.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/typewriter/typewriter.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/marquee/marquee.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/orbit-animation/orbit-animation.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/confetti/confetti.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/text-scramble/text-scramble.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/mouse-follower/mouse-follower.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/profile-card/profile-card.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/profile-card/profile-card.component.html\",\"../../../../projects/elm/ngx-animations/src/lib/components/profile-grid/profile-grid.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/components/profile-grid/profile-grid.component.html\",\"../../../../projects/elm/ngx-animations/src/lib/components/glass-card/glass-card.component.ts\",\"../../../../projects/elm/ngx-animations/src/lib/services/timeline.service.ts\",\"../../../../projects/elm/ngx-animations/src/lib/services/rtl-language.service.ts\",\"../../../../projects/elm/ngx-animations/src/public-api.ts\",\"../../../../projects/elm/ngx-animations/src/elm-ngx-animations.ts\"],\"sourcesContent\":[\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  effect,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type FadeDirection = 'in' | 'out' | 'in-out';\\nexport type EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\\n\\n/**\\n * Fade In/Out Directive\\n * Applies smooth fade animations to any element\\n * \\n * @example\\n * <div ngxFadeIn [duration]=\\\"500\\\" [delay]=\\\"100\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxFadeIn]',\\n  standalone: true\\n})\\nexport class FadeInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() easing: EasingFunction = 'ease-out';\\n  @Input() direction: FadeDirection = 'in';\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n  @Input() startOpacity: number = 0;\\n  @Input() endOpacity: number = 1;\\n  /**\\n   * When true and triggerOnScroll is enabled, the directive will\\n   * reset back to the startOpacity when the element leaves the viewport\\n   * so the animation can replay on the next entry.\\n   */\\n  @Input() resetOnExit: boolean = false;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      // SSR: Set final state\\n      const element = this.el.nativeElement;\\n      element.style.opacity = this.endOpacity.toString();\\n      return;\\n    }\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Set initial state\\n    element.style.opacity = this.startOpacity.toString();\\n    element.style.transition = `opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            // Optionally reset to initial state so animation can replay\\n            if (this.resetOnExit) {\\n              const element = this.el.nativeElement;\\n              element.style.opacity = this.startOpacity.toString();\\n            }\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      // SSR: Set final state immediately\\n      const element = this.el.nativeElement;\\n      element.style.opacity = this.endOpacity.toString();\\n      return;\\n    }\\n\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    // Trigger animation on next frame\\n    requestAnimationFrame(() => {\\n      if (this.direction === 'in' || this.direction === 'in-out') {\\n        element.style.opacity = this.endOpacity.toString();\\n      } else {\\n        element.style.opacity = this.startOpacity.toString();\\n      }\\n    });\\n\\n    // Emit end event after animation completes\\n    setTimeout(() => {\\n      this.animationEnd.emit();\\n    }, this.duration + this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type SlideDirection = 'left' | 'right' | 'top' | 'bottom';\\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\\n\\n/**\\n * Slide In Directive\\n * Slides element from specified direction with RTL support\\n * \\n * @example\\n * <div ngxSlideIn direction=\\\"left\\\" [duration]=\\\"500\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxSlideIn]',\\n  standalone: true\\n})\\nexport class SlideInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() easing: EasingFunction = 'cubic-bezier(0.4, 0, 0.2, 1)';\\n  @Input() direction: SlideDirection = 'left';\\n  @Input() distance: number = 50;\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n  @Input() rtl: boolean = false;\\n  /**\\n   * When true and triggerOnScroll is enabled, the directive will\\n   * reset back to its initial offset + opacity 0 when the element\\n   * leaves the viewport so the animation can replay.\\n   */\\n  @Input() resetOnExit: boolean = false;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n  private initialTransform: string | null = null;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Detect RTL from element or input\\n    const isRTL = this.rtl || getComputedStyle(element).direction === 'rtl';\\n    \\n    // Adjust direction for RTL\\n    let actualDirection = this.direction;\\n    if (isRTL) {\\n      if (this.direction === 'left') actualDirection = 'right';\\n      else if (this.direction === 'right') actualDirection = 'left';\\n    }\\n\\n    // Set initial transform\\n    const transform = this.getTransform(actualDirection, this.distance);\\n    this.initialTransform = transform;\\n    element.style.transform = transform;\\n    element.style.opacity = '0';\\n    element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private getTransform(direction: SlideDirection, distance: number): string {\\n    switch (direction) {\\n      case 'left':\\n        return `translateX(-${distance}px)`;\\n      case 'right':\\n        return `translateX(${distance}px)`;\\n      case 'top':\\n        return `translateY(-${distance}px)`;\\n      case 'bottom':\\n        return `translateY(${distance}px)`;\\n      default:\\n        return 'translateX(0)';\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            // Optionally reset to initial state so animation can replay\\n            if (this.resetOnExit && this.initialTransform !== null) {\\n              const element = this.el.nativeElement;\\n              element.style.transform = this.initialTransform;\\n              element.style.opacity = '0';\\n            }\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    requestAnimationFrame(() => {\\n      element.style.transform = 'translate(0, 0)';\\n      element.style.opacity = '1';\\n    });\\n\\n    setTimeout(() => {\\n      this.animationEnd.emit();\\n    }, this.duration + this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type ScaleOrigin = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\\n\\n/**\\n * Scale In Directive\\n * Scales element from specified origin point\\n * \\n * @example\\n * <div ngxScaleIn [startScale]=\\\"0.5\\\" [duration]=\\\"500\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxScaleIn]',\\n  standalone: true\\n})\\nexport class ScaleInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() easing: EasingFunction = 'cubic-bezier(0.4, 0, 0.2, 1)';\\n  @Input() startScale: number = 0.5;\\n  @Input() endScale: number = 1;\\n  @Input() origin: ScaleOrigin = 'center';\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n  /**\\n   * When true and triggerOnScroll is enabled, the directive will\\n   * reset back to the startScale and opacity 0 when the element\\n   * leaves the viewport so the animation can replay.\\n   */\\n  @Input() resetOnExit: boolean = false;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Set transform origin\\n    element.style.transformOrigin = this.getTransformOrigin();\\n    element.style.transform = `scale(${this.startScale})`;\\n    element.style.opacity = '0';\\n    element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private getTransformOrigin(): string {\\n    return this.origin.replace('-', ' ');\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            // Optionally reset to initial state so animation can replay\\n            if (this.resetOnExit) {\\n              const element = this.el.nativeElement;\\n              element.style.transform = `scale(${this.startScale})`;\\n              element.style.opacity = '0';\\n            }\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    requestAnimationFrame(() => {\\n      element.style.transform = `scale(${this.endScale})`;\\n      element.style.opacity = '1';\\n    });\\n\\n    setTimeout(() => {\\n      this.animationEnd.emit();\\n    }, this.duration + this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type RotateAxis = 'x' | 'y' | 'z';\\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'cubic-bezier(0.4, 0, 0.2, 1)';\\n\\n/**\\n * Rotate In Directive\\n * Rotates element on specified axis\\n * \\n * @example\\n * <div ngxRotateIn axis=\\\"y\\\" [degrees]=\\\"90\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxRotateIn]',\\n  standalone: true\\n})\\nexport class RotateInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() easing: EasingFunction = 'cubic-bezier(0.4, 0, 0.2, 1)';\\n  @Input() axis: RotateAxis = 'z';\\n  @Input() degrees: number = 180;\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n  /**\\n   * When true and triggerOnScroll is enabled, the directive will\\n   * reset back to its initial rotated state with opacity 0 when the\\n   * element leaves the viewport so the animation can replay.\\n   */\\n  @Input() resetOnExit: boolean = false;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n  private initialTransform: string | null = null;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Set initial rotation\\n    const initial = this.getRotateTransform(this.degrees);\\n    this.initialTransform = initial;\\n    element.style.transform = initial;\\n    element.style.opacity = '0';\\n    element.style.transition = `transform ${this.duration}ms ${this.easing} ${this.delay}ms, opacity ${this.duration}ms ${this.easing} ${this.delay}ms`;\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private getRotateTransform(degrees: number): string {\\n    switch (this.axis) {\\n      case 'x':\\n        return `rotateX(${degrees}deg)`;\\n      case 'y':\\n        return `rotateY(${degrees}deg)`;\\n      case 'z':\\n        return `rotateZ(${degrees}deg)`;\\n      default:\\n        return `rotate(${degrees}deg)`;\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            // Optionally reset to initial state so animation can replay\\n            if (this.resetOnExit && this.initialTransform !== null) {\\n              const element = this.el.nativeElement;\\n              element.style.transform = this.initialTransform;\\n              element.style.opacity = '0';\\n            }\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    requestAnimationFrame(() => {\\n      element.style.transform = this.getRotateTransform(0);\\n      element.style.opacity = '1';\\n    });\\n\\n    setTimeout(() => {\\n      this.animationEnd.emit();\\n    }, this.duration + this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Parallax Scroll Directive\\n * Creates smooth parallax effect on scroll\\n * \\n * @example\\n * <div ngxParallaxScroll [speed]=\\\"0.5\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxParallaxScroll]',\\n  standalone: true\\n})\\nexport class ParallaxScrollDirective implements OnInit, OnDestroy {\\n  @Input() speed: number = 0.5; // 0 to 1, where 1 is normal scroll speed\\n  @Input() direction: 'vertical' | 'horizontal' = 'vertical';\\n  @Input() reverse: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private scrollHandler?: () => void;\\n  private rafId?: number;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    element.style.willChange = 'transform';\\n    element.style.transition = 'transform 0.1s ease-out';\\n\\n    this.scrollHandler = () => {\\n      if (this.rafId) {\\n        cancelAnimationFrame(this.rafId);\\n      }\\n\\n      this.rafId = requestAnimationFrame(() => {\\n        this.updateParallax();\\n      });\\n    };\\n\\n    window.addEventListener('scroll', this.scrollHandler, { passive: true });\\n    this.updateParallax();\\n  }\\n\\n  private updateParallax(): void {\\n    const element = this.el.nativeElement;\\n    const rect = element.getBoundingClientRect();\\n    const windowHeight = window.innerHeight;\\n\\n    // Calculate how much the element is in view (0 to 1)\\n    const elementMiddle = rect.top + rect.height / 2;\\n    const scrollProgress = 1 - (elementMiddle / windowHeight);\\n\\n    // Apply parallax effect\\n    const multiplier = this.reverse ? -1 : 1;\\n    const offset = scrollProgress * 100 * this.speed * multiplier;\\n\\n    if (this.direction === 'vertical') {\\n      element.style.transform = `translateY(${offset}px)`;\\n    } else {\\n      element.style.transform = `translateX(${offset}px)`;\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.scrollHandler) {\\n      window.removeEventListener('scroll', this.scrollHandler);\\n    }\\n    if (this.rafId) {\\n      cancelAnimationFrame(this.rafId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID,\\n  Renderer2\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Ripple Click Directive\\n * Creates Material Design-style ripple effect on click\\n * Modern and performant implementation\\n * \\n * @example\\n * <button ngxRippleClick [rippleColor]=\\\"'rgba(255, 255, 255, 0.5)'\\\">Click me</button>\\n */\\n@Directive({\\n  selector: '[ngxRippleClick]',\\n  standalone: true\\n})\\nexport class RippleClickDirective {\\n  @Input() rippleColor: string = 'rgba(255, 255, 255, 0.5)';\\n  @Input() rippleDuration: number = 600;\\n  @Input() rippleRadius: number = 0; // 0 means auto-calculate\\n  @Input() centered: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private renderer = inject(Renderer2);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {\\n    this.setupHostElement();\\n  }\\n\\n  private setupHostElement(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    const position = getComputedStyle(element).position;\\n    \\n    if (position === 'static') {\\n      this.renderer.setStyle(element, 'position', 'relative');\\n    }\\n    \\n    this.renderer.setStyle(element, 'overflow', 'hidden');\\n    this.renderer.setStyle(element, 'user-select', 'none');\\n    this.renderer.setStyle(element, '-webkit-tap-highlight-color', 'transparent');\\n  }\\n\\n  @HostListener('click', ['$event'])\\n  onClick(event: MouseEvent): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    this.createRipple(event);\\n  }\\n\\n  private createRipple(event: MouseEvent): void {\\n    const element = this.el.nativeElement;\\n    const rect = element.getBoundingClientRect();\\n\\n    // Calculate ripple position\\n    let x: number, y: number;\\n    \\n    if (this.centered) {\\n      x = rect.width / 2;\\n      y = rect.height / 2;\\n    } else {\\n      x = event.clientX - rect.left;\\n      y = event.clientY - rect.top;\\n    }\\n\\n    // Calculate ripple size\\n    const radius = this.rippleRadius || Math.max(\\n      Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)),\\n      Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(y, 2)),\\n      Math.sqrt(Math.pow(x, 2) + Math.pow(rect.height - y, 2)),\\n      Math.sqrt(Math.pow(rect.width - x, 2) + Math.pow(rect.height - y, 2))\\n    );\\n\\n    // Create ripple element\\n    const ripple = this.renderer.createElement('span');\\n    this.renderer.addClass(ripple, 'ngx-ripple');\\n    \\n    // Apply styles\\n    const styles = {\\n      'position': 'absolute',\\n      'border-radius': '50%',\\n      'background-color': this.rippleColor,\\n      'width': `${radius * 2}px`,\\n      'height': `${radius * 2}px`,\\n      'left': `${x - radius}px`,\\n      'top': `${y - radius}px`,\\n      'transform': 'scale(0)',\\n      'opacity': '1',\\n      'pointer-events': 'none',\\n      'transition': `transform ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1), opacity ${this.rippleDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`\\n    };\\n\\n    Object.entries(styles).forEach(([key, value]) => {\\n      this.renderer.setStyle(ripple, key, value);\\n    });\\n\\n    // Add to DOM\\n    this.renderer.appendChild(element, ripple);\\n\\n    // Trigger animation\\n    requestAnimationFrame(() => {\\n      requestAnimationFrame(() => {\\n        this.renderer.setStyle(ripple, 'transform', 'scale(1)');\\n        this.renderer.setStyle(ripple, 'opacity', '0');\\n      });\\n    });\\n\\n    // Remove after animation\\n    setTimeout(() => {\\n      this.renderer.removeChild(element, ripple);\\n    }, this.rippleDuration);\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type BounceDirection = 'up' | 'down' | 'left' | 'right' | 'center';\\ntype EasingFunction = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear';\\n\\n/**\\n * Bounce In Directive\\n * Creates a playful bounce effect when element appears\\n * \\n * @example\\n * <div ngxBounceIn direction=\\\"up\\\" [duration]=\\\"800\\\">Bouncy content!</div>\\n */\\n@Directive({\\n  selector: '[ngxBounceIn]',\\n  standalone: true\\n})\\nexport class BounceInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 800;\\n  @Input() delay: number = 0;\\n  @Input() direction: BounceDirection = 'up';\\n  @Input() distance: number = 50;\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Set initial state\\n    this.setInitialState(element);\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private setInitialState(element: HTMLElement): void {\\n    element.style.opacity = '0';\\n    element.style.transform = this.getInitialTransform();\\n  }\\n\\n  private getInitialTransform(): string {\\n    switch (this.direction) {\\n      case 'up':\\n        return `translateY(${this.distance}px) scale(0.3)`;\\n      case 'down':\\n        return `translateY(-${this.distance}px) scale(0.3)`;\\n      case 'left':\\n        return `translateX(${this.distance}px) scale(0.3)`;\\n      case 'right':\\n        return `translateX(-${this.distance}px) scale(0.3)`;\\n      case 'center':\\n        return 'scale(0.3)';\\n      default:\\n        return 'scale(0.3)';\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    setTimeout(() => {\\n      // Create bounce keyframes animation\\n      const keyframes = [\\n        { transform: this.getInitialTransform(), opacity: '0', offset: 0 },\\n        { transform: 'translate(0, 0) scale(1.1)', opacity: '1', offset: 0.6 },\\n        { transform: 'translate(0, 0) scale(0.95)', opacity: '1', offset: 0.8 },\\n        { transform: 'translate(0, 0) scale(1.02)', opacity: '1', offset: 0.9 },\\n        { transform: 'translate(0, 0) scale(1)', opacity: '1', offset: 1 }\\n      ];\\n\\n      element.animate(keyframes, {\\n        duration: this.duration,\\n        easing: 'ease-out',\\n        fill: 'forwards'\\n      });\\n\\n      setTimeout(() => {\\n        element.style.opacity = '1';\\n        element.style.transform = 'translate(0, 0) scale(1)';\\n        this.animationEnd.emit();\\n      }, this.duration);\\n    }, this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type FlipAxis = 'horizontal' | 'vertical' | 'diagonal';\\n\\n/**\\n * Flip In Directive\\n * Creates a 3D flip animation effect\\n * \\n * @example\\n * <div ngxFlipIn axis=\\\"horizontal\\\" [duration]=\\\"600\\\">Flip me!</div>\\n */\\n@Directive({\\n  selector: '[ngxFlipIn]',\\n  standalone: true\\n})\\nexport class FlipInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() axis: FlipAxis = 'horizontal';\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Add perspective to parent for 3D effect\\n    const parent = element.parentElement;\\n    if (parent) {\\n      parent.style.perspective = '1000px';\\n    }\\n\\n    // Set initial state\\n    element.style.opacity = '0';\\n    element.style.transform = this.getInitialTransform();\\n    element.style.backfaceVisibility = 'visible';\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private getInitialTransform(): string {\\n    switch (this.axis) {\\n      case 'horizontal':\\n        return 'rotateY(-90deg)';\\n      case 'vertical':\\n        return 'rotateX(-90deg)';\\n      case 'diagonal':\\n        return 'rotate3d(1, 1, 0, -90deg)';\\n      default:\\n        return 'rotateY(-90deg)';\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    setTimeout(() => {\\n      element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\\n      element.style.opacity = '1';\\n      element.style.transform = 'rotate3d(0, 0, 0, 0deg)';\\n\\n      setTimeout(() => {\\n        this.animationEnd.emit();\\n      }, this.duration);\\n    }, this.delay);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type ShakeIntensity = 'soft' | 'medium' | 'hard';\\n\\n/**\\n * Shake Directive\\n * Creates a shake/wobble effect on interaction or programmatically\\n * \\n * @example\\n * <div ngxShake [shakeOnHover]=\\\"true\\\" intensity=\\\"medium\\\">Shake on hover!</div>\\n */\\n@Directive({\\n  selector: '[ngxShake]',\\n  standalone: true\\n})\\nexport class ShakeDirective {\\n  @Input() intensity: ShakeIntensity = 'medium';\\n  @Input() duration: number = 500;\\n  @Input() shakeOnHover: boolean = false;\\n  @Input() shakeOnClick: boolean = false;\\n  @Input() continuous: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private intervalId?: ReturnType<typeof setInterval>;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    if (this.continuous) {\\n      this.startContinuousShake();\\n    }\\n  }\\n\\n  @HostListener('mouseenter')\\n  onMouseEnter(): void {\\n    if (this.shakeOnHover) {\\n      this.shake();\\n    }\\n  }\\n\\n  @HostListener('click')\\n  onClick(): void {\\n    if (this.shakeOnClick) {\\n      this.shake();\\n    }\\n  }\\n\\n  private getShakeDistance(): number {\\n    switch (this.intensity) {\\n      case 'soft':\\n        return 5;\\n      case 'medium':\\n        return 10;\\n      case 'hard':\\n        return 15;\\n      default:\\n        return 10;\\n    }\\n  }\\n\\n  shake(): void {\\n    const element = this.el.nativeElement;\\n    const distance = this.getShakeDistance();\\n\\n    const keyframes = [\\n      { transform: 'translateX(0)' },\\n      { transform: `translateX(-${distance}px)` },\\n      { transform: `translateX(${distance}px)` },\\n      { transform: `translateX(-${distance}px)` },\\n      { transform: `translateX(${distance}px)` },\\n      { transform: `translateX(-${distance / 2}px)` },\\n      { transform: `translateX(${distance / 2}px)` },\\n      { transform: 'translateX(0)' }\\n    ];\\n\\n    element.animate(keyframes, {\\n      duration: this.duration,\\n      easing: 'ease-in-out'\\n    });\\n  }\\n\\n  private startContinuousShake(): void {\\n    this.shake();\\n    this.intervalId = setInterval(() => {\\n      this.shake();\\n    }, this.duration + 2000);\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.intervalId) {\\n      clearInterval(this.intervalId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Pulse Directive\\n * Creates a continuous pulsing/heartbeat effect\\n * \\n * @example\\n * <div ngxPulse [speed]=\\\"1000\\\" [scale]=\\\"1.1\\\">Pulsing content!</div>\\n */\\n@Directive({\\n  selector: '[ngxPulse]',\\n  standalone: true\\n})\\nexport class PulseDirective implements OnInit, OnDestroy {\\n  @Input() speed: number = 1000; // duration of one pulse cycle\\n  @Input() scale: number = 1.05; // how much to scale (1.0 = no scale, 1.1 = 10% larger)\\n  @Input() continuous: boolean = true;\\n  @Input() pauseOnHover: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private animation?: Animation;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    element.style.willChange = 'transform';\\n\\n    if (this.continuous) {\\n      this.startPulse();\\n    }\\n\\n    if (this.pauseOnHover) {\\n      element.addEventListener('mouseenter', () => this.pause());\\n      element.addEventListener('mouseleave', () => this.resume());\\n    }\\n  }\\n\\n  private startPulse(): void {\\n    const element = this.el.nativeElement;\\n\\n    const keyframes = [\\n      { transform: 'scale(1)', offset: 0 },\\n      { transform: `scale(${this.scale})`, offset: 0.5 },\\n      { transform: 'scale(1)', offset: 1 }\\n    ];\\n\\n    this.animation = element.animate(keyframes, {\\n      duration: this.speed,\\n      iterations: Infinity,\\n      easing: 'ease-in-out'\\n    });\\n  }\\n\\n  private pause(): void {\\n    if (this.animation) {\\n      this.animation.pause();\\n    }\\n  }\\n\\n  private resume(): void {\\n    if (this.animation) {\\n      this.animation.play();\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.animation) {\\n      this.animation.cancel();\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Glitch Directive\\n * Creates a cool glitch/distortion effect\\n * \\n * @example\\n * <div ngxGlitch [intensity]=\\\"5\\\" [speed]=\\\"3000\\\">Glitchy text!</div>\\n */\\n@Directive({\\n  selector: '[ngxGlitch]',\\n  standalone: true\\n})\\nexport class GlitchDirective implements OnInit, OnDestroy {\\n  @Input() intensity: number = 3; // 1-10, higher = more glitch\\n  @Input() speed: number = 3000; // how often glitch occurs (ms)\\n  @Input() duration: number = 200; // how long each glitch lasts\\n  @Input() continuous: boolean = true;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private intervalId?: ReturnType<typeof setInterval>;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    element.style.position = 'relative';\\n    element.style.display = 'inline-block';\\n\\n    if (this.continuous) {\\n      this.startGlitching();\\n    }\\n  }\\n\\n  private startGlitching(): void {\\n    this.intervalId = setInterval(() => {\\n      this.glitch();\\n    }, this.speed);\\n  }\\n\\n  private glitch(): void {\\n    const element = this.el.nativeElement;\\n    const originalText = element.textContent || '';\\n\\n    // Create glitch effect with text-shadow and transform\\n    const glitchKeyframes = [\\n      {\\n        transform: 'translate(0, 0)',\\n        textShadow: `${this.intensity}px 0 red, -${this.intensity}px 0 blue`,\\n        offset: 0\\n      },\\n      {\\n        transform: `translate(${this.intensity}px, ${this.intensity}px)`,\\n        textShadow: `-${this.intensity}px 0 red, ${this.intensity}px 0 cyan`,\\n        offset: 0.25\\n      },\\n      {\\n        transform: `translate(-${this.intensity}px, -${this.intensity}px)`,\\n        textShadow: `${this.intensity}px 0 green, -${this.intensity}px 0 magenta`,\\n        offset: 0.5\\n      },\\n      {\\n        transform: `translate(${this.intensity}px, -${this.intensity}px)`,\\n        textShadow: `-${this.intensity}px 0 yellow, ${this.intensity}px 0 blue`,\\n        offset: 0.75\\n      },\\n      {\\n        transform: 'translate(0, 0)',\\n        textShadow: 'none',\\n        offset: 1\\n      }\\n    ];\\n\\n    element.animate(glitchKeyframes, {\\n      duration: this.duration,\\n      easing: 'steps(4)'\\n    });\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.intervalId) {\\n      clearInterval(this.intervalId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  OnDestroy,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type ZoomStyle = 'smooth' | 'bounce' | 'elastic';\\n\\n/**\\n * Zoom In Directive\\n * Creates various zoom-in effects with different styles\\n * \\n * @example\\n * <div ngxZoomIn style=\\\"bounce\\\" [intensity]=\\\"1.5\\\">Zoom content!</div>\\n */\\n@Directive({\\n  selector: '[ngxZoomIn]',\\n  standalone: true\\n})\\nexport class ZoomInDirective implements OnInit, OnDestroy {\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() style: ZoomStyle = 'smooth';\\n  @Input() intensity: number = 1.2; // peak zoom scale\\n  @Input() triggerOnScroll: boolean = false;\\n  @Input() threshold: number = 0.1;\\n\\n  @Output() animationStart = new EventEmitter<void>();\\n  @Output() animationEnd = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    \\n    // Set initial state\\n    element.style.opacity = '0';\\n    element.style.transform = 'scale(0)';\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      this.animate();\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animate();\\n            this.hasAnimated.set(true);\\n          } else {\\n            this.hasAnimated.set(false);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animate(): void {\\n    const element = this.el.nativeElement;\\n    \\n    this.animationStart.emit();\\n\\n    setTimeout(() => {\\n      const keyframes = this.getKeyframes();\\n\\n      element.animate(keyframes, {\\n        duration: this.duration,\\n        easing: this.getEasing(),\\n        fill: 'forwards'\\n      });\\n\\n      setTimeout(() => {\\n        element.style.opacity = '1';\\n        element.style.transform = 'scale(1)';\\n        this.animationEnd.emit();\\n      }, this.duration);\\n    }, this.delay);\\n  }\\n\\n  private getKeyframes(): Keyframe[] {\\n    switch (this.style) {\\n      case 'smooth':\\n        return [\\n          { transform: 'scale(0)', opacity: '0', offset: 0 },\\n          { transform: 'scale(1)', opacity: '1', offset: 1 }\\n        ];\\n\\n      case 'bounce':\\n        return [\\n          { transform: 'scale(0)', opacity: '0', offset: 0 },\\n          { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.6 },\\n          { transform: 'scale(0.9)', opacity: '1', offset: 0.8 },\\n          { transform: 'scale(1)', opacity: '1', offset: 1 }\\n        ];\\n\\n      case 'elastic':\\n        return [\\n          { transform: 'scale(0)', opacity: '0', offset: 0 },\\n          { transform: `scale(${this.intensity})`, opacity: '1', offset: 0.5 },\\n          { transform: 'scale(0.85)', opacity: '1', offset: 0.7 },\\n          { transform: 'scale(1.05)', opacity: '1', offset: 0.85 },\\n          { transform: 'scale(1)', opacity: '1', offset: 1 }\\n        ];\\n\\n      default:\\n        return [\\n          { transform: 'scale(0)', opacity: '0', offset: 0 },\\n          { transform: 'scale(1)', opacity: '1', offset: 1 }\\n        ];\\n    }\\n  }\\n\\n  private getEasing(): string {\\n    switch (this.style) {\\n      case 'smooth':\\n        return 'cubic-bezier(0.4, 0, 0.2, 1)';\\n      case 'bounce':\\n        return 'ease-out';\\n      case 'elastic':\\n        return 'ease-out';\\n      default:\\n        return 'ease-out';\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID,\\n  OnInit\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Hover Lift Directive\\n * Adds a subtle scale + shadow effect on hover.\\n *\\n * Useful for cards, buttons, and tiles.\\n *\\n * @example\\n * <div ngxHoverLift [liftScale]=\\\"1.03\\\" [shadowStrength]=\\\"0.25\\\">Card</div>\\n */\\n@Directive({\\n  selector: '[ngxHoverLift]',\\n  standalone: true\\n})\\nexport class HoverLiftDirective implements OnInit {\\n  /** Scale factor on hover (1 = no scale) */\\n  @Input() liftScale: number = 1.03;\\n\\n  /** Shadow strength 0‚Äì1 */\\n  @Input() shadowStrength: number = 0.25;\\n\\n  /** Transition duration in ms */\\n  @Input() hoverDuration: number = 200;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private originalTransform = '';\\n  private originalBoxShadow = '';\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    const style = getComputedStyle(element);\\n    this.originalTransform = style.transform === 'none' ? '' : style.transform;\\n    this.originalBoxShadow = style.boxShadow || 'none';\\n\\n    element.style.transition =\\n      element.style.transition ||\\n      `transform ${this.hoverDuration}ms ease-out, box-shadow ${this.hoverDuration}ms ease-out`;\\n    element.style.willChange = 'transform, box-shadow';\\n  }\\n\\n  @HostListener('mouseenter')\\n  onEnter(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n    const element = this.el.nativeElement;\\n\\n    const shadowAlpha = this.shadowStrength;\\n    const shadow = `0 12px 25px rgba(0, 0, 0, ${shadowAlpha})`;\\n\\n    element.style.transform = `${this.originalTransform} scale(${this.liftScale})`.trim();\\n    element.style.boxShadow = shadow;\\n  }\\n\\n  @HostListener('mouseleave')\\n  onLeave(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n    const element = this.el.nativeElement;\\n    element.style.transform = this.originalTransform || 'none';\\n    element.style.boxShadow = this.originalBoxShadow;\\n  }\\n}\\n\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Count Up Directive\\n * Animates numbers from a start value to an end value.\\n *\\n * @example\\n * <span ngxCountUp [end]=\\\"2500\\\" [duration]=\\\"1200\\\"></span>\\n */\\n@Directive({\\n  selector: '[ngxCountUp]',\\n  standalone: true\\n})\\nexport class CountUpDirective implements OnInit, OnDestroy {\\n  /** Starting value */\\n  @Input() start: number = 0;\\n\\n  /** Final value */\\n  @Input() end: number = 100;\\n\\n  /** Duration in ms */\\n  @Input() duration: number = 1000;\\n\\n  /** Decimal places */\\n  @Input() decimals: number = 0;\\n\\n  /** Optional prefix (e.g. '$') */\\n  @Input() prefix: string = '';\\n\\n  /** Optional suffix (e.g. '%') */\\n  @Input() suffix: string = '';\\n\\n  /** Whether to animate on scroll into view */\\n  @Input() triggerOnScroll: boolean = true;\\n\\n  /** Intersection threshold */\\n  @Input() threshold: number = 0.2;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private observer?: IntersectionObserver;\\n  private startTime = 0;\\n  private rafId?: number;\\n  private hasAnimated = false;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      this.render(this.end);\\n      return;\\n    }\\n\\n    if (this.triggerOnScroll) {\\n      this.setupObserver();\\n    } else {\\n      this.startAnimation();\\n    }\\n  }\\n\\n  private setupObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            if (!this.hasAnimated) {\\n              this.startAnimation();\\n              this.hasAnimated = true;\\n            }\\n          } else {\\n            // Reset so animation can play again on next scroll into view\\n            this.hasAnimated = false;\\n            this.render(this.start);\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private startAnimation(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n    this.startTime = performance.now();\\n    this.animate();\\n  }\\n\\n  private animate = (): void => {\\n    const now = performance.now();\\n    const elapsed = now - this.startTime;\\n    const progress = Math.min(elapsed / this.duration, 1);\\n\\n    const currentValue = this.start + (this.end - this.start) * progress;\\n    this.render(currentValue);\\n\\n    if (progress < 1) {\\n      this.rafId = requestAnimationFrame(this.animate);\\n    }\\n  };\\n\\n  private render(value: number): void {\\n    const formatted = this.prefix +\\n      value.toFixed(this.decimals).replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, ',') +\\n      this.suffix;\\n    this.el.nativeElement.textContent = formatted;\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n    if (this.rafId) cancelAnimationFrame(this.rafId);\\n  }\\n}\\n\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID,\\n  OnInit\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Magnetic Directive\\n * Creates a magnetic pull effect on hover (GSAP-inspired)\\n * Elements follow the mouse cursor when hovering\\n * \\n * @example\\n * <button ngxMagnetic [strength]=\\\"0.5\\\">Magnetic Button</button>\\n */\\n@Directive({\\n  selector: '[ngxMagnetic]',\\n  standalone: true\\n})\\nexport class MagneticDirective implements OnInit {\\n  @Input() strength: number = 0.4; // 0-1, how strong the magnetic effect is\\n  @Input() speed: number = 0.3; // 0-1, how fast it follows\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private rect?: DOMRect;\\n  private isHovering = false;\\n  private currentX = 0;\\n  private currentY = 0;\\n  private targetX = 0;\\n  private targetY = 0;\\n  private rafId?: number;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n    \\n    const element = this.el.nativeElement;\\n    element.style.transition = 'transform 0.1s ease-out';\\n    element.style.willChange = 'transform';\\n  }\\n\\n  @HostListener('mouseenter')\\n  onMouseEnter(): void {\\n    this.isHovering = true;\\n    this.rect = this.el.nativeElement.getBoundingClientRect();\\n    this.animate();\\n  }\\n\\n  @HostListener('mouseleave')\\n  onMouseLeave(): void {\\n    this.isHovering = false;\\n    this.targetX = 0;\\n    this.targetY = 0;\\n    \\n    if (this.rafId) {\\n      cancelAnimationFrame(this.rafId);\\n    }\\n    \\n    // Reset to center\\n    this.el.nativeElement.style.transform = 'translate(0px, 0px)';\\n  }\\n\\n  @HostListener('mousemove', ['$event'])\\n  onMouseMove(event: MouseEvent): void {\\n    if (!this.isHovering || !this.rect) return;\\n\\n    const x = event.clientX - this.rect.left - this.rect.width / 2;\\n    const y = event.clientY - this.rect.top - this.rect.height / 2;\\n\\n    this.targetX = x * this.strength;\\n    this.targetY = y * this.strength;\\n  }\\n\\n  private animate(): void {\\n    if (!this.isHovering) return;\\n\\n    // Smooth lerp (linear interpolation)\\n    this.currentX += (this.targetX - this.currentX) * this.speed;\\n    this.currentY += (this.targetY - this.currentY) * this.speed;\\n\\n    this.el.nativeElement.style.transform = \\n      `translate(${this.currentX}px, ${this.currentY}px)`;\\n\\n    this.rafId = requestAnimationFrame(() => this.animate());\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID,\\n  OnInit\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * 3D Tilt Directive\\n * Creates a 3D tilt effect following mouse movement (GSAP-inspired)\\n * Perfect for cards and interactive elements\\n * \\n * @example\\n * <div ngxTilt3d [maxTilt]=\\\"15\\\" [perspective]=\\\"1000\\\">3D Card</div>\\n */\\n@Directive({\\n  selector: '[ngxTilt3d]',\\n  standalone: true\\n})\\nexport class Tilt3dDirective implements OnInit {\\n  @Input() maxTilt: number = 20; // Maximum tilt angle in degrees\\n  @Input() perspective: number = 1000; // Perspective value\\n  @Input() scale: number = 1.05; // Scale on hover\\n  @Input() speed: number = 400; // Transition speed in ms\\n  @Input() glare: boolean = false; // Add glare effect\\n\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    element.style.transformStyle = 'preserve-3d';\\n    element.style.transition = `transform ${this.speed}ms cubic-bezier(0.03, 0.98, 0.52, 0.99)`;\\n    element.style.willChange = 'transform';\\n\\n    if (this.glare) {\\n      this.addGlareEffect();\\n    }\\n  }\\n\\n  private addGlareEffect(): void {\\n    const glare = document.createElement('div');\\n    glare.className = 'tilt-glare';\\n    glare.style.cssText = `\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n      background: linear-gradient(135deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%);\\n      opacity: 0;\\n      pointer-events: none;\\n      transition: opacity ${this.speed}ms;\\n      border-radius: inherit;\\n    `;\\n    this.el.nativeElement.appendChild(glare);\\n    this.el.nativeElement.style.position = 'relative';\\n    this.el.nativeElement.style.overflow = 'hidden';\\n  }\\n\\n  @HostListener('mouseenter')\\n  onMouseEnter(): void {\\n    const element = this.el.nativeElement;\\n    element.style.transform = `perspective(${this.perspective}px) scale(${this.scale})`;\\n    \\n    if (this.glare) {\\n      const glare = element.querySelector('.tilt-glare') as HTMLElement;\\n      if (glare) glare.style.opacity = '1';\\n    }\\n  }\\n\\n  @HostListener('mousemove', ['$event'])\\n  onMouseMove(event: MouseEvent): void {\\n    const element = this.el.nativeElement;\\n    const rect = element.getBoundingClientRect();\\n    \\n    const x = event.clientX - rect.left;\\n    const y = event.clientY - rect.top;\\n    \\n    const centerX = rect.width / 2;\\n    const centerY = rect.height / 2;\\n    \\n    const rotateX = ((y - centerY) / centerY) * this.maxTilt;\\n    const rotateY = ((centerX - x) / centerX) * this.maxTilt;\\n    \\n    element.style.transform = \\n      `perspective(${this.perspective}px) scale(${this.scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\\n    \\n    if (this.glare) {\\n      const glare = element.querySelector('.tilt-glare') as HTMLElement;\\n      if (glare) {\\n        const angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);\\n        glare.style.background = \\n          `linear-gradient(${angle}deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%)`;\\n      }\\n    }\\n  }\\n\\n  @HostListener('mouseleave')\\n  onMouseLeave(): void {\\n    const element = this.el.nativeElement;\\n    element.style.transform = `perspective(${this.perspective}px) rotateX(0deg) rotateY(0deg) scale(1)`;\\n    \\n    if (this.glare) {\\n      const glare = element.querySelector('.tilt-glare') as HTMLElement;\\n      if (glare) glare.style.opacity = '0';\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  Output,\\n  EventEmitter,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Scroll Progress Directive\\n * Animates elements based on scroll progress (GSAP ScrollTrigger-inspired)\\n * Perfect for parallax and scroll-driven animations\\n * \\n * @example\\n * <div ngxScrollProgress [startProgress]=\\\"0\\\" [endProgress]=\\\"100\\\">Content</div>\\n */\\n@Directive({\\n  selector: '[ngxScrollProgress]',\\n  standalone: true\\n})\\nexport class ScrollProgressDirective implements OnInit, OnDestroy {\\n  @Input() startProgress: number = 0; // Start at this scroll percentage\\n  @Input() endProgress: number = 100; // End at this scroll percentage\\n  @Input() animateOpacity: boolean = true;\\n  @Input() animateScale: boolean = false;\\n  @Input() animateX: number = 0; // Translate X distance\\n  @Input() animateY: number = 0; // Translate Y distance\\n  @Input() animateRotate: number = 0; // Rotation degrees\\n\\n  @Output() progressChange = new EventEmitter<number>();\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private scrollHandler?: () => void;\\n  private rafId?: number;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    element.style.willChange = 'transform, opacity';\\n\\n    this.scrollHandler = () => {\\n      if (this.rafId) {\\n        cancelAnimationFrame(this.rafId);\\n      }\\n      this.rafId = requestAnimationFrame(() => this.updateProgress());\\n    };\\n\\n    window.addEventListener('scroll', this.scrollHandler, { passive: true });\\n    this.updateProgress();\\n  }\\n\\n  private updateProgress(): void {\\n    const element = this.el.nativeElement;\\n    const rect = element.getBoundingClientRect();\\n    const windowHeight = window.innerHeight;\\n\\n    // Calculate progress (0 to 1)\\n    const elementTop = rect.top;\\n    const elementHeight = rect.height;\\n    const scrollProgress = (windowHeight - elementTop) / (windowHeight + elementHeight);\\n    const clampedProgress = Math.max(0, Math.min(1, scrollProgress));\\n\\n    // Map to start/end range\\n    const rangeStart = this.startProgress / 100;\\n    const rangeEnd = this.endProgress / 100;\\n    const normalizedProgress = (clampedProgress - rangeStart) / (rangeEnd - rangeStart);\\n    const progress = Math.max(0, Math.min(1, normalizedProgress));\\n\\n    this.progressChange.emit(progress);\\n\\n    // Apply transformations\\n    const transforms: string[] = [];\\n    \\n    if (this.animateX !== 0) {\\n      const x = this.animateX * (1 - progress);\\n      transforms.push(`translateX(${x}px)`);\\n    }\\n    \\n    if (this.animateY !== 0) {\\n      const y = this.animateY * (1 - progress);\\n      transforms.push(`translateY(${y}px)`);\\n    }\\n    \\n    if (this.animateScale) {\\n      const scale = 0.5 + (progress * 0.5);\\n      transforms.push(`scale(${scale})`);\\n    }\\n    \\n    if (this.animateRotate !== 0) {\\n      const rotate = this.animateRotate * progress;\\n      transforms.push(`rotate(${rotate}deg)`);\\n    }\\n\\n    element.style.transform = transforms.join(' ');\\n\\n    if (this.animateOpacity) {\\n      element.style.opacity = progress.toString();\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.scrollHandler) {\\n      window.removeEventListener('scroll', this.scrollHandler);\\n    }\\n    if (this.rafId) {\\n      cancelAnimationFrame(this.rafId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  Input,\\n  HostListener,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Morph Directive\\n * Creates smooth morphing transitions between shapes (GSAP MorphSVG-inspired)\\n * Works with border-radius to create organic shape changes\\n * \\n * @example\\n * <div ngxMorph [morphOnHover]=\\\"true\\\">Morphing element</div>\\n */\\n@Directive({\\n  selector: '[ngxMorph]',\\n  standalone: true\\n})\\nexport class MorphDirective {\\n  @Input() morphOnHover: boolean = true;\\n  @Input() morphOnClick: boolean = false;\\n  @Input() duration: number = 600;\\n  @Input() continuous: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private intervalId?: ReturnType<typeof setInterval>;\\n  private originalBorderRadius?: string;\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const element = this.el.nativeElement;\\n    this.originalBorderRadius = getComputedStyle(element).borderRadius || '0px';\\n    element.style.transition = `border-radius ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\\n\\n    if (this.continuous) {\\n      this.startContinuousMorph();\\n    }\\n  }\\n\\n  @HostListener('mouseenter')\\n  onMouseEnter(): void {\\n    if (this.morphOnHover && !this.continuous) {\\n      this.morph();\\n    }\\n  }\\n\\n  @HostListener('mouseleave')\\n  onMouseLeave(): void {\\n    if (this.morphOnHover && !this.continuous) {\\n      this.reset();\\n    }\\n  }\\n\\n  @HostListener('click')\\n  onClick(): void {\\n    if (this.morphOnClick) {\\n      this.morph();\\n      setTimeout(() => this.reset(), this.duration);\\n    }\\n  }\\n\\n  private morph(): void {\\n    const element = this.el.nativeElement;\\n    const shapes = this.getRandomShape();\\n    element.style.borderRadius = shapes;\\n  }\\n\\n  private reset(): void {\\n    const element = this.el.nativeElement;\\n    element.style.borderRadius = this.originalBorderRadius || '0px';\\n  }\\n\\n  private getRandomShape(): string {\\n    const shapes = [\\n      '60% 40% 30% 70% / 60% 30% 70% 40%',\\n      '30% 60% 70% 40% / 50% 60% 30% 60%',\\n      '60% 40% 60% 40% / 70% 50% 50% 60%',\\n      '40% 60% 70% 30% / 40% 50% 60% 50%',\\n      '80% 20% 50% 50% / 60% 70% 30% 40%',\\n      '50% 50% 30% 70% / 30% 60% 40% 60%'\\n    ];\\n    return shapes[Math.floor(Math.random() * shapes.length)];\\n  }\\n\\n  private startContinuousMorph(): void {\\n    this.morph();\\n    this.intervalId = setInterval(() => {\\n      this.morph();\\n    }, this.duration + 500);\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.intervalId) {\\n      clearInterval(this.intervalId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  Output,\\n  EventEmitter,\\n  OnInit,\\n  OnDestroy,\\n  ElementRef,\\n  ViewChild,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type RevealAnimation = 'fade' | 'slide-up' | 'slide-down' | 'slide-left' | 'slide-right' | 'scale' | 'rotate';\\n\\n/**\\n * Scroll Reveal Component\\n * Reveals content when it comes into viewport\\n * \\n * @example\\n * <ngx-scroll-reveal animation=\\\"slide-up\\\">\\n *   <h1>Content to reveal</h1>\\n * </ngx-scroll-reveal>\\n */\\n@Component({\\n  selector: 'ngx-scroll-reveal',\\n  standalone: true,\\n  template: `\\n    <div #container [class.revealed]=\\\"isRevealed()\\\" [style]=\\\"containerStyle()\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      display: block;\\n    }\\n    \\n    div {\\n      transition-property: opacity, transform;\\n      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n    }\\n    \\n    .revealed {\\n      opacity: 1 !important;\\n      transform: translate(0, 0) scale(1) rotate(0) !important;\\n    }\\n  `]\\n})\\nexport class ScrollRevealComponent implements OnInit, OnDestroy {\\n  @Input() animation: RevealAnimation = 'fade';\\n  @Input() duration: number = 600;\\n  @Input() delay: number = 0;\\n  @Input() threshold: number = 0.1;\\n  @Input() once: boolean = true;\\n  @Input() distance: number = 50;\\n\\n  @Output() revealed = new EventEmitter<void>();\\n  @Output() hidden = new EventEmitter<void>();\\n\\n  @ViewChild('container', { static: true }) container!: ElementRef<HTMLElement>;\\n\\n  protected isRevealed = signal(false);\\n  private observer?: IntersectionObserver;\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      this.isRevealed.set(true);\\n      return;\\n    }\\n\\n    this.setupIntersectionObserver();\\n  }\\n\\n  protected containerStyle(): string {\\n    const styles = [\\n      `transition-duration: ${this.duration}ms`,\\n      `transition-delay: ${this.delay}ms`\\n    ];\\n\\n    if (!this.isRevealed()) {\\n      styles.push('opacity: 0');\\n      styles.push(this.getInitialTransform());\\n    }\\n\\n    return styles.join('; ');\\n  }\\n\\n  private getInitialTransform(): string {\\n    switch (this.animation) {\\n      case 'fade':\\n        return 'transform: none';\\n      case 'slide-up':\\n        return `transform: translateY(${this.distance}px)`;\\n      case 'slide-down':\\n        return `transform: translateY(-${this.distance}px)`;\\n      case 'slide-left':\\n        return `transform: translateX(${this.distance}px)`;\\n      case 'slide-right':\\n        return `transform: translateX(-${this.distance}px)`;\\n      case 'scale':\\n        return 'transform: scale(0.8)';\\n      case 'rotate':\\n        return 'transform: rotate(10deg)';\\n      default:\\n        return 'transform: none';\\n    }\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.isRevealed.set(true);\\n            this.revealed.emit();\\n            \\n            if (this.once) {\\n              this.observer?.unobserve(entry.target);\\n            }\\n          } else if (!this.once) {\\n            this.isRevealed.set(false);\\n            this.hidden.emit();\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  Output,\\n  EventEmitter,\\n  OnInit,\\n  ContentChildren,\\n  QueryList,\\n  AfterContentInit,\\n  ElementRef,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type StaggerAnimation = 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate';\\n\\n/**\\n * Stagger List Component\\n * Animates child elements with staggered delays\\n * \\n * @example\\n * <ngx-stagger-list animation=\\\"slide-up\\\" [staggerDelay]=\\\"100\\\">\\n *   <div class=\\\"item\\\">Item 1</div>\\n *   <div class=\\\"item\\\">Item 2</div>\\n *   <div class=\\\"item\\\">Item 3</div>\\n * </ngx-stagger-list>\\n */\\n@Component({\\n  selector: 'ngx-stagger-list',\\n  standalone: true,\\n  template: `\\n    <div class=\\\"stagger-container\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      display: block;\\n    }\\n    \\n    .stagger-container {\\n      display: contents;\\n    }\\n  `]\\n})\\nexport class StaggerListComponent implements OnInit, AfterContentInit {\\n  @Input() animation: StaggerAnimation = 'fade';\\n  @Input() duration: number = 600;\\n  @Input() staggerDelay: number = 100;\\n  @Input() initialDelay: number = 0;\\n  @Input() triggerOnScroll: boolean = true;\\n  @Input() threshold: number = 0.1;\\n  @Input() reverse: boolean = false;\\n\\n  @Output() animationStart = new EventEmitter<number>();\\n  @Output() animationComplete = new EventEmitter<void>();\\n\\n  private observer?: IntersectionObserver;\\n  private hasAnimated = false;\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor(private el: ElementRef<HTMLElement>) {}\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    if (this.triggerOnScroll) {\\n      this.setupIntersectionObserver();\\n    } else {\\n      setTimeout(() => this.animateChildren(), this.initialDelay);\\n    }\\n  }\\n\\n  ngAfterContentInit(): void {\\n    // Animation will be triggered by intersection observer or immediately\\n  }\\n\\n  private setupIntersectionObserver(): void {\\n    this.observer = new IntersectionObserver(\\n      (entries) => {\\n        entries.forEach((entry) => {\\n          if (entry.isIntersecting) {\\n            this.animateChildren();\\n            this.hasAnimated = true;\\n          } else {\\n            this.hasAnimated = false;\\n          }\\n        });\\n      },\\n      { threshold: this.threshold }\\n    );\\n\\n    this.observer.observe(this.el.nativeElement);\\n  }\\n\\n  private animateChildren(): void {\\n    const container = this.el.nativeElement.querySelector('.stagger-container');\\n    if (!container) return;\\n\\n    const children = Array.from(container.children) as HTMLElement[];\\n    const itemsToAnimate = this.reverse ? children.reverse() : children;\\n\\n    itemsToAnimate.forEach((child, index) => {\\n      // Set initial state\\n      this.setInitialState(child);\\n\\n      // Animate with stagger\\n      const delay = this.initialDelay + (index * this.staggerDelay);\\n      \\n      setTimeout(() => {\\n        this.animationStart.emit(index);\\n        this.animateElement(child);\\n      }, delay);\\n\\n      // Emit complete event after last animation\\n      if (index === itemsToAnimate.length - 1) {\\n        setTimeout(() => {\\n          this.animationComplete.emit();\\n        }, delay + this.duration);\\n      }\\n    });\\n  }\\n\\n  private setInitialState(element: HTMLElement): void {\\n    element.style.transition = `all ${this.duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;\\n    \\n    switch (this.animation) {\\n      case 'fade':\\n        element.style.opacity = '0';\\n        break;\\n      case 'slide-up':\\n        element.style.opacity = '0';\\n        element.style.transform = 'translateY(30px)';\\n        break;\\n      case 'slide-down':\\n        element.style.opacity = '0';\\n        element.style.transform = 'translateY(-30px)';\\n        break;\\n      case 'scale':\\n        element.style.opacity = '0';\\n        element.style.transform = 'scale(0.8)';\\n        break;\\n      case 'rotate':\\n        element.style.opacity = '0';\\n        element.style.transform = 'rotate(-10deg)';\\n        break;\\n    }\\n  }\\n\\n  private animateElement(element: HTMLElement): void {\\n    requestAnimationFrame(() => {\\n      element.style.opacity = '1';\\n      element.style.transform = 'translate(0, 0) scale(1) rotate(0)';\\n    });\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.observer?.disconnect();\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  Output,\\n  EventEmitter,\\n  OnInit,\\n  OnDestroy,\\n  signal,\\n  effect,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Typewriter Component\\n * Types out text character by character with RTL support\\n * \\n * @example\\n * <ngx-typewriter [text]=\\\"'Hello World!'\\\" [speed]=\\\"50\\\"></ngx-typewriter>\\n */\\n@Component({\\n  selector: 'ngx-typewriter',\\n  standalone: true,\\n  template: `\\n    <span [class.rtl]=\\\"rtl\\\" [style]=\\\"containerStyle()\\\">\\n      {{ displayedText() }}<span class=\\\"cursor\\\" [class.blink]=\\\"showCursor\\\">|</span>\\n    </span>\\n  `,\\n  styles: [`\\n    :host {\\n      display: inline-block;\\n    }\\n    \\n    span {\\n      font-family: inherit;\\n      font-size: inherit;\\n      line-height: inherit;\\n    }\\n    \\n    .rtl {\\n      direction: rtl;\\n      unicode-bidi: bidi-override;\\n    }\\n    \\n    .cursor {\\n      opacity: 1;\\n      animation: none;\\n    }\\n    \\n    .cursor.blink {\\n      animation: blink 1s step-end infinite;\\n    }\\n    \\n    @keyframes blink {\\n      0%, 50% { opacity: 1; }\\n      51%, 100% { opacity: 0; }\\n    }\\n  `]\\n})\\nexport class TypewriterComponent implements OnInit, OnDestroy {\\n  @Input() text: string = '';\\n  @Input() speed: number = 50; // milliseconds per character\\n  @Input() delay: number = 0;\\n  @Input() showCursor: boolean = true;\\n  @Input() loop: boolean = false;\\n  @Input() deleteSpeed: number = 30;\\n  @Input() pauseBeforeDelete: number = 2000;\\n  @Input() rtl: boolean = false;\\n\\n  @Output() typingStart = new EventEmitter<void>();\\n  @Output() typingComplete = new EventEmitter<void>();\\n  @Output() deletingStart = new EventEmitter<void>();\\n  @Output() deletingComplete = new EventEmitter<void>();\\n\\n  protected displayedText = signal('');\\n  private currentIndex = 0;\\n  private isDeleting = false;\\n  private timeoutId?: ReturnType<typeof setTimeout>;\\n  private platformId = inject(PLATFORM_ID);\\n\\n  constructor() {\\n    // Watch for text changes\\n    effect(() => {\\n      const newText = this.text;\\n      if (newText && isPlatformBrowser(this.platformId)) {\\n        this.restart();\\n      }\\n    });\\n  }\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      this.displayedText.set(this.text);\\n      return;\\n    }\\n\\n    this.start();\\n  }\\n\\n  protected containerStyle(): string {\\n    return this.rtl ? 'direction: rtl; text-align: right;' : '';\\n  }\\n\\n  private start(): void {\\n    if (this.delay > 0) {\\n      this.timeoutId = setTimeout(() => this.type(), this.delay);\\n    } else {\\n      this.type();\\n    }\\n  }\\n\\n  private type(): void {\\n    if (!this.isDeleting && this.currentIndex === 0) {\\n      this.typingStart.emit();\\n    }\\n\\n    if (!this.isDeleting) {\\n      // Typing forward\\n      if (this.currentIndex < this.text.length) {\\n        const nextChar = this.text.charAt(this.currentIndex);\\n        this.displayedText.update(current => current + nextChar);\\n        this.currentIndex++;\\n        this.timeoutId = setTimeout(() => this.type(), this.speed);\\n      } else {\\n        // Finished typing\\n        this.typingComplete.emit();\\n        \\n        if (this.loop) {\\n          this.timeoutId = setTimeout(() => {\\n            this.isDeleting = true;\\n            this.deletingStart.emit();\\n            this.type();\\n          }, this.pauseBeforeDelete);\\n        }\\n      }\\n    } else {\\n      // Deleting backward\\n      if (this.currentIndex > 0) {\\n        this.currentIndex--;\\n        this.displayedText.set(this.text.substring(0, this.currentIndex));\\n        this.timeoutId = setTimeout(() => this.type(), this.deleteSpeed);\\n      } else {\\n        // Finished deleting\\n        this.deletingComplete.emit();\\n        this.isDeleting = false;\\n        this.timeoutId = setTimeout(() => this.type(), this.speed);\\n      }\\n    }\\n  }\\n\\n  private restart(): void {\\n    this.stop();\\n    this.currentIndex = 0;\\n    this.isDeleting = false;\\n    this.displayedText.set('');\\n    this.start();\\n  }\\n\\n  private stop(): void {\\n    if (this.timeoutId) {\\n      clearTimeout(this.timeoutId);\\n      this.timeoutId = undefined;\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.stop();\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  inject,\\n  PLATFORM_ID,\\n  signal\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type MarqueeDirection = 'left' | 'right' | 'up' | 'down';\\n\\n/**\\n * Marquee Component\\n * Continuous scrolling text/content with RTL support\\n * \\n * @example\\n * <ngx-marquee [speed]=\\\"50\\\" direction=\\\"left\\\">\\n *   Scrolling text content here...\\n * </ngx-marquee>\\n */\\n@Component({\\n  selector: 'ngx-marquee',\\n  standalone: true,\\n  styleUrls: ['./marquee.component.scss'],\\n  template: `\\n    <div class=\\\"marquee-container\\\" [class.vertical]=\\\"isVertical()\\\" [class.rtl]=\\\"rtl\\\">\\n      <div class=\\\"marquee-content\\\" [style]=\\\"animationStyle()\\\">\\n        <div class=\\\"marquee-item\\\">\\n          <ng-content></ng-content>\\n        </div>\\n        <div class=\\\"marquee-item\\\" aria-hidden=\\\"true\\\">\\n          <ng-content></ng-content>\\n        </div>\\n      </div>\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      display: block;\\n      overflow: hidden;\\n    }\\n    \\n    .marquee-container {\\n      position: relative;\\n      width: 100%;\\n      height: 100%;\\n      overflow: hidden;\\n    }\\n    \\n    .marquee-container.rtl {\\n      direction: rtl;\\n    }\\n    \\n    .marquee-content {\\n      display: flex;\\n      width: fit-content;\\n      animation-timing-function: linear;\\n      animation-iteration-count: infinite;\\n    }\\n    \\n    .marquee-container.vertical .marquee-content {\\n      flex-direction: column;\\n    }\\n    \\n    .marquee-item {\\n      display: flex;\\n      align-items: center;\\n      white-space: nowrap;\\n      padding-right: 2rem;\\n    }\\n    \\n    .marquee-container.vertical .marquee-item {\\n      padding-right: 0;\\n      padding-bottom: 2rem;\\n    }\\n    \\n    .marquee-container.rtl .marquee-item {\\n      padding-right: 0;\\n      padding-left: 2rem;\\n    }\\n  `]\\n})\\nexport class MarqueeComponent implements OnInit {\\n  @Input() speed: number = 50; // pixels per second\\n  @Input() direction: MarqueeDirection = 'left';\\n  @Input() pauseOnHover: boolean = true;\\n  @Input() rtl: boolean = false;\\n  @Input() gap: number = 32; // gap between items in pixels\\n\\n  protected isVertical = signal(false);\\n  private platformId = inject(PLATFORM_ID);\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    this.isVertical.set(this.direction === 'up' || this.direction === 'down');\\n  }\\n\\n  protected animationStyle(): string {\\n    const duration = this.calculateDuration();\\n    const animationName = this.getAnimationName();\\n    const playState = this.pauseOnHover ? 'running' : 'running';\\n    \\n    const styles = [\\n      `animation-name: ${animationName}`,\\n      `animation-duration: ${duration}s`,\\n      `animation-play-state: ${playState}`,\\n      `gap: ${this.gap}px`\\n    ];\\n\\n    if (this.pauseOnHover) {\\n      styles.push('&:hover { animation-play-state: paused; }');\\n    }\\n\\n    return styles.join('; ');\\n  }\\n\\n  private calculateDuration(): number {\\n    // Duration based on speed (slower speed = longer duration)\\n    return 100 / this.speed;\\n  }\\n\\n  private getAnimationName(): string {\\n    if (this.isVertical()) {\\n      return this.direction === 'up' ? 'marquee-up' : 'marquee-down';\\n    }\\n    \\n    // For RTL, we might want to reverse the direction\\n    if (this.rtl) {\\n      return this.direction === 'left' ? 'marquee-right' : 'marquee-left';\\n    }\\n    \\n    return this.direction === 'left' ? 'marquee-left' : 'marquee-right';\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\nexport type OrbitDirection = 'clockwise' | 'counterclockwise';\\n\\n/**\\n * Orbit Animation Component\\n * Rotates content in circular orbit around center point\\n * \\n * @example\\n * <ngx-orbit-animation [radius]=\\\"100\\\" [speed]=\\\"5\\\">\\n *   <div class=\\\"planet\\\">üåç</div>\\n * </ngx-orbit-animation>\\n */\\n@Component({\\n  selector: 'ngx-orbit-animation',\\n  standalone: true,\\n  template: `\\n    <div class=\\\"orbit-container\\\" [style]=\\\"containerStyle()\\\">\\n      <div class=\\\"orbit-path\\\" [style]=\\\"orbitPathStyle()\\\">\\n        <div class=\\\"orbit-item\\\" [style]=\\\"orbitItemStyle()\\\">\\n          <ng-content></ng-content>\\n        </div>\\n      </div>\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      display: inline-block;\\n    }\\n    \\n    .orbit-container {\\n      position: relative;\\n      display: flex;\\n      align-items: center;\\n      justify-content: center;\\n    }\\n    \\n    .orbit-path {\\n      position: relative;\\n      border-radius: 50%;\\n      animation-timing-function: linear;\\n      animation-iteration-count: infinite;\\n    }\\n    \\n    .orbit-item {\\n      position: absolute;\\n      top: 50%;\\n      left: 50%;\\n      transform-origin: center;\\n    }\\n    \\n    @keyframes orbit-clockwise {\\n      0% {\\n        transform: rotate(0deg);\\n      }\\n      100% {\\n        transform: rotate(360deg);\\n      }\\n    }\\n    \\n    @keyframes orbit-counterclockwise {\\n      0% {\\n        transform: rotate(0deg);\\n      }\\n      100% {\\n        transform: rotate(-360deg);\\n      }\\n    }\\n  `]\\n})\\nexport class OrbitAnimationComponent implements OnInit {\\n  @Input() radius: number = 100; // orbit radius in pixels\\n  @Input() speed: number = 5; // seconds per revolution\\n  @Input() direction: OrbitDirection = 'clockwise';\\n  @Input() startAngle: number = 0; // starting angle in degrees\\n  @Input() pauseOnHover: boolean = false;\\n  @Input() showPath: boolean = false;\\n\\n  private platformId = inject(PLATFORM_ID);\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n  }\\n\\n  protected containerStyle(): string {\\n    const size = this.radius * 2;\\n    return `width: ${size}px; height: ${size}px;`;\\n  }\\n\\n  protected orbitPathStyle(): string {\\n    const size = this.radius * 2;\\n    const animationName = this.direction === 'clockwise' ? 'orbit-clockwise' : 'orbit-counterclockwise';\\n    const playState = this.pauseOnHover ? 'paused' : 'running';\\n    \\n    const styles = [\\n      `width: ${size}px`,\\n      `height: ${size}px`,\\n      `animation-name: ${animationName}`,\\n      `animation-duration: ${this.speed}s`,\\n      `animation-play-state: ${playState}`\\n    ];\\n\\n    if (this.showPath) {\\n      styles.push('border: 2px dashed rgba(0, 0, 0, 0.1)');\\n    }\\n\\n    return styles.join('; ');\\n  }\\n\\n  protected orbitItemStyle(): string {\\n    const offset = -this.radius;\\n    const counterRotation = this.direction === 'clockwise' ? 'orbit-counterclockwise' : 'orbit-clockwise';\\n    \\n    return [\\n      `transform: translate(-50%, -50%) rotate(${this.startAngle}deg) translateX(${this.radius}px)`,\\n      `animation: ${counterRotation} ${this.speed}s linear infinite`\\n    ].join('; ');\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  ElementRef,\\n  ViewChild,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\ninterface Particle {\\n  x: number;\\n  y: number;\\n  vx: number;\\n  vy: number;\\n  rotation: number;\\n  rotationSpeed: number;\\n  color: string;\\n  size: number;\\n  opacity: number;\\n}\\n\\n/**\\n * Confetti Component\\n * Creates a celebratory confetti explosion effect\\n * \\n * @example\\n * <ngx-confetti [particleCount]=\\\"100\\\" [duration]=\\\"3000\\\"></ngx-confetti>\\n */\\n@Component({\\n  selector: 'ngx-confetti',\\n  standalone: true,\\n  template: `\\n    <canvas #canvas [style.width.px]=\\\"width\\\" [style.height.px]=\\\"height\\\"></canvas>\\n  `,\\n  styles: [`\\n    :host {\\n      display: block;\\n      position: fixed;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n      pointer-events: none;\\n      z-index: 9999;\\n    }\\n    \\n    canvas {\\n      width: 100%;\\n      height: 100%;\\n    }\\n  `]\\n})\\nexport class ConfettiComponent implements OnInit, OnDestroy {\\n  @Input() particleCount: number = 150;\\n  @Input() duration: number = 3000;\\n  @Input() colors: string[] = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];\\n  @Input() autoStart: boolean = true;\\n\\n  @ViewChild('canvas', { static: true }) canvas!: ElementRef<HTMLCanvasElement>;\\n\\n  protected width = signal(window.innerWidth);\\n  protected height = signal(window.innerHeight);\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private ctx?: CanvasRenderingContext2D;\\n  private particles: Particle[] = [];\\n  private animationId?: number;\\n  private startTime?: number;\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    const canvasEl = this.canvas.nativeElement;\\n    canvasEl.width = window.innerWidth;\\n    canvasEl.height = window.innerHeight;\\n    \\n    this.ctx = canvasEl.getContext('2d')!;\\n\\n    window.addEventListener('resize', () => this.onResize());\\n\\n    if (this.autoStart) {\\n      this.start();\\n    }\\n  }\\n\\n  private onResize(): void {\\n    const canvasEl = this.canvas.nativeElement;\\n    canvasEl.width = window.innerWidth;\\n    canvasEl.height = window.innerHeight;\\n    this.width.set(window.innerWidth);\\n    this.height.set(window.innerHeight);\\n  }\\n\\n  start(): void {\\n    this.createParticles();\\n    this.startTime = Date.now();\\n    this.animate();\\n  }\\n\\n  private createParticles(): void {\\n    this.particles = [];\\n    const centerX = window.innerWidth / 2;\\n    const centerY = window.innerHeight / 2;\\n\\n    for (let i = 0; i < this.particleCount; i++) {\\n      const angle = (Math.PI * 2 * i) / this.particleCount;\\n      const velocity = 5 + Math.random() * 10;\\n\\n      this.particles.push({\\n        x: centerX,\\n        y: centerY,\\n        vx: Math.cos(angle) * velocity,\\n        vy: Math.sin(angle) * velocity - Math.random() * 5,\\n        rotation: Math.random() * 360,\\n        rotationSpeed: (Math.random() - 0.5) * 10,\\n        color: this.colors[Math.floor(Math.random() * this.colors.length)],\\n        size: 8 + Math.random() * 8,\\n        opacity: 1\\n      });\\n    }\\n  }\\n\\n  private animate(): void {\\n    if (!this.ctx || !this.startTime) return;\\n\\n    const elapsed = Date.now() - this.startTime;\\n    if (elapsed > this.duration) {\\n      this.stop();\\n      return;\\n    }\\n\\n    this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\\n\\n    this.particles.forEach((particle) => {\\n      // Update position\\n      particle.x += particle.vx;\\n      particle.y += particle.vy;\\n      particle.vy += 0.5; // gravity\\n      particle.rotation += particle.rotationSpeed;\\n\\n      // Fade out towards end\\n      const fadeStart = this.duration * 0.7;\\n      if (elapsed > fadeStart) {\\n        particle.opacity = 1 - (elapsed - fadeStart) / (this.duration - fadeStart);\\n      }\\n\\n      // Draw particle\\n      if (this.ctx) {\\n        this.ctx.save();\\n        this.ctx.translate(particle.x, particle.y);\\n        this.ctx.rotate((particle.rotation * Math.PI) / 180);\\n        this.ctx.globalAlpha = particle.opacity;\\n        this.ctx.fillStyle = particle.color;\\n        \\n        // Draw rectangle confetti\\n        this.ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);\\n        \\n        this.ctx.restore();\\n      }\\n    });\\n\\n    this.animationId = requestAnimationFrame(() => this.animate());\\n  }\\n\\n  stop(): void {\\n    if (this.animationId) {\\n      cancelAnimationFrame(this.animationId);\\n      this.animationId = undefined;\\n    }\\n    if (this.ctx) {\\n      this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\\n    }\\n  }\\n\\n  ngOnDestroy(): void {\\n    this.stop();\\n    window.removeEventListener('resize', () => this.onResize());\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  Output,\\n  EventEmitter,\\n  signal,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Text Scramble Component\\n * Creates a cool text scrambling effect (GSAP/Matrix-inspired)\\n * Text appears to decode/unscramble character by character\\n * \\n * @example\\n * <ngx-text-scramble [text]=\\\"'Hello World'\\\" [speed]=\\\"50\\\"></ngx-text-scramble>\\n */\\n@Component({\\n  selector: 'ngx-text-scramble',\\n  standalone: true,\\n  template: `\\n    <span [class]=\\\"customClass\\\">{{ displayedText() }}</span>\\n  `,\\n  styles: [`\\n    :host {\\n      display: inline-block;\\n      font-family: 'Courier New', monospace;\\n    }\\n  `]\\n})\\nexport class TextScrambleComponent implements OnInit {\\n  @Input() text: string = '';\\n  @Input() speed: number = 50; // ms per character\\n  @Input() scrambleChars: string = '!<>-_\\\\\\\\/[]{}‚Äî=+*^?#________';\\n  @Input() delay: number = 0;\\n  @Input() customClass: string = '';\\n\\n  @Output() complete = new EventEmitter<void>();\\n\\n  protected displayedText = signal('');\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private frame = 0;\\n  private queue: Array<{ from: string; to: string; start: number; end: number }> = [];\\n  private rafId?: number;\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) {\\n      this.displayedText.set(this.text);\\n      return;\\n    }\\n\\n    setTimeout(() => this.scramble(), this.delay);\\n  }\\n\\n  private scramble(): void {\\n    const length = this.text.length;\\n    this.queue = [];\\n\\n    for (let i = 0; i < length; i++) {\\n      const from = this.randomChar();\\n      const to = this.text[i];\\n      const start = Math.floor(Math.random() * 40);\\n      const end = start + Math.floor(Math.random() * 40);\\n      \\n      this.queue.push({ from, to, start, end });\\n    }\\n\\n    this.update();\\n  }\\n\\n  private update(): void {\\n    let output = '';\\n    let complete = 0;\\n\\n    for (let i = 0; i < this.queue.length; i++) {\\n      const { from, to, start, end } = this.queue[i];\\n\\n      if (this.frame >= end) {\\n        complete++;\\n        output += to;\\n      } else if (this.frame >= start) {\\n        output += this.randomChar();\\n      } else {\\n        output += '';\\n      }\\n    }\\n\\n    this.displayedText.set(output);\\n\\n    if (complete === this.queue.length) {\\n      this.complete.emit();\\n    } else {\\n      this.frame++;\\n      this.rafId = requestAnimationFrame(() => this.update());\\n    }\\n  }\\n\\n  private randomChar(): string {\\n    return this.scrambleChars[Math.floor(Math.random() * this.scrambleChars.length)];\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.rafId) {\\n      cancelAnimationFrame(this.rafId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  OnDestroy,\\n  inject,\\n  PLATFORM_ID,\\n  signal\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\n\\n/**\\n * Mouse Follower Component\\n * Creates a custom cursor that follows the mouse (GSAP-inspired)\\n * Adds a premium feel to any website\\n * \\n * @example\\n * <ngx-mouse-follower [size]=\\\"20\\\" [color]=\\\"'#667eea'\\\"></ngx-mouse-follower>\\n */\\n@Component({\\n  selector: 'ngx-mouse-follower',\\n  standalone: true,\\n  template: `\\n    <div class=\\\"mouse-follower\\\" \\n         [style.width.px]=\\\"size\\\"\\n         [style.height.px]=\\\"size\\\"\\n         [style.background]=\\\"color\\\"\\n         [style.transform]=\\\"transform()\\\"\\n         [style.opacity]=\\\"opacity()\\\">\\n    </div>\\n    <div class=\\\"mouse-follower-dot\\\"\\n         [style.width.px]=\\\"dotSize\\\"\\n         [style.height.px]=\\\"dotSize\\\"\\n         [style.background]=\\\"dotColor\\\"\\n         [style.transform]=\\\"dotTransform()\\\">\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      pointer-events: none;\\n      position: fixed;\\n      top: 0;\\n      left: 0;\\n      z-index: 9999;\\n      mix-blend-mode: difference;\\n    }\\n    \\n    .mouse-follower {\\n      position: fixed;\\n      border-radius: 50%;\\n      pointer-events: none;\\n      transition: transform 0.2s ease-out, opacity 0.3s;\\n      will-change: transform;\\n    }\\n    \\n    .mouse-follower-dot {\\n      position: fixed;\\n      border-radius: 50%;\\n      pointer-events: none;\\n      transition: transform 0.1s ease-out;\\n      will-change: transform;\\n    }\\n  `]\\n})\\nexport class MouseFollowerComponent implements OnInit, OnDestroy {\\n  @Input() size: number = 40;\\n  @Input() dotSize: number = 8;\\n  @Input() color: string = 'rgba(255, 255, 255, 0.5)';\\n  @Input() dotColor: string = 'rgba(255, 255, 255, 0.8)';\\n  @Input() speed: number = 0.15;\\n\\n  protected transform = signal('translate(-50%, -50%)');\\n  protected dotTransform = signal('translate(-50%, -50%)');\\n  protected opacity = signal(0);\\n\\n  private platformId = inject(PLATFORM_ID);\\n  private mouseX = 0;\\n  private mouseY = 0;\\n  private currentX = 0;\\n  private currentY = 0;\\n  private dotX = 0;\\n  private dotY = 0;\\n  private rafId?: number;\\n  private mouseMoveHandler?: (e: MouseEvent) => void;\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n\\n    this.mouseMoveHandler = (e: MouseEvent) => {\\n      this.mouseX = e.clientX;\\n      this.mouseY = e.clientY;\\n      this.opacity.set(1);\\n    };\\n\\n    window.addEventListener('mousemove', this.mouseMoveHandler);\\n    this.animate();\\n  }\\n\\n  private animate(): void {\\n    // Smooth follow with lerp\\n    this.currentX += (this.mouseX - this.currentX) * this.speed;\\n    this.currentY += (this.mouseY - this.currentY) * this.speed;\\n\\n    // Dot follows instantly\\n    this.dotX = this.mouseX;\\n    this.dotY = this.mouseY;\\n\\n    this.transform.set(`translate(${this.currentX}px, ${this.currentY}px) translate(-50%, -50%)`);\\n    this.dotTransform.set(`translate(${this.dotX}px, ${this.dotY}px) translate(-50%, -50%)`);\\n\\n    this.rafId = requestAnimationFrame(() => this.animate());\\n  }\\n\\n  ngOnDestroy(): void {\\n    if (this.mouseMoveHandler) {\\n      window.removeEventListener('mousemove', this.mouseMoveHandler);\\n    }\\n    if (this.rafId) {\\n      cancelAnimationFrame(this.rafId);\\n    }\\n  }\\n}\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\nimport { CommonModule } from '@angular/common';\\nimport { Tilt3dDirective } from '../../directives/tilt-3d.directive';\\nimport { MagneticDirective } from '../../directives/magnetic.directive';\\n\\n// Export interface for use in other components\\nexport interface ProfileCardData {\\n  id?: string | number;\\n  name: string; // Arabic name\\n  username: string; // English username\\n  jobTitle: string; // Arabic job title\\n  gradient: string; // CSS gradient\\n  icon?: string; // Emoji or icon\\n  iconSvg?: string; // SVG path for custom icons\\n  stats?: {\\n    documents?: number;\\n    views?: number;\\n    links?: number;\\n  };\\n}\\n\\n/**\\n * Profile Card Component\\n * Creates an interactive profile card with gradient background and hover effects\\n * Perfect for team showcases, portfolios, and user grids\\n * \\n * @example\\n * <ngx-profile-card\\n *   [name]=\\\"'ÿ≥ÿßÿ±ÿ© ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä'\\\"\\n *   [username]=\\\"'sara_zahrani@'\\\"\\n *   [jobTitle]=\\\"'ÿπÿßŸÑŸÖÿ© ÿ®ŸäÿßŸÜÿßÿ™'\\\"\\n *   [gradient]=\\\"'linear-gradient(135deg, #FF5D36, #763CBC)'\\\"\\n *   icon=\\\"üìä\\\">\\n * </ngx-profile-card>\\n */\\n@Component({\\n  selector: 'ngx-profile-card',\\n  standalone: true,\\n  imports: [CommonModule, Tilt3dDirective, MagneticDirective],\\n  templateUrl: './profile-card.component.html',\\n  styleUrls: ['./profile-card.component.css']\\n})\\nexport class ProfileCardComponent implements OnInit {\\n  @Input() name: string = '';\\n  @Input() username: string = '';\\n  @Input() jobTitle: string = '';\\n  @Input() gradient: string = 'linear-gradient(135deg, #763CBC, #FF5D36)';\\n  @Input() icon: string = 'üë§';\\n  @Input() iconSvg?: string;\\n  @Input() stats?: { documents?: number; views?: number; links?: number };\\n  @Input() showStats: boolean = true;\\n  @Input() enableTilt: boolean = true;\\n  @Input() enableMagnetic: boolean = false;\\n  @Input() magneticStrength: number = 0.3;\\n  @Input() tiltMax: number = 15;\\n  @Input() tiltGlare: boolean = true;\\n\\n  private platformId = inject(PLATFORM_ID);\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n  }\\n\\n  get cardClasses(): string {\\n    const classes = ['profile-card'];\\n    if (this.enableTilt) classes.push('tilt-enabled');\\n    if (this.enableMagnetic) classes.push('magnetic-enabled');\\n    return classes.join(' ');\\n  }\\n}\\n\\n\",\"<div \\n  class=\\\"profile-card\\\"\\n  [ngClass]=\\\"cardClasses\\\"\\n  [style.--profile-gradient]=\\\"gradient\\\">\\n  \\n  <div class=\\\"card-content\\\">\\n    <!-- Icon -->\\n    <div class=\\\"card-icon\\\" [style.background]=\\\"gradient\\\">\\n      @if (iconSvg) {\\n        <svg class=\\\"icon-svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\">\\n          <path [attr.d]=\\\"iconSvg\\\" fill=\\\"currentColor\\\"/>\\n        </svg>\\n      } @else {\\n        <span class=\\\"icon-emoji\\\">{{ icon }}</span>\\n      }\\n    </div>\\n\\n    <!-- Name (Arabic) -->\\n    <h3 class=\\\"card-name\\\">{{ name }}</h3>\\n\\n    <!-- Username (English) -->\\n    <p class=\\\"card-username\\\">{{ username }}</p>\\n\\n    <!-- Job Title (Arabic) -->\\n    <p class=\\\"card-job\\\">{{ jobTitle }}</p>\\n\\n    <!-- Stats -->\\n    @if (showStats && stats) {\\n      <div class=\\\"card-stats\\\">\\n        @if (stats.documents !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">üìÑ</span>\\n            <span class=\\\"stat-value\\\">{{ stats.documents }}</span>\\n          </div>\\n        }\\n        @if (stats.views !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">üëÅÔ∏è</span>\\n            <span class=\\\"stat-value\\\">{{ stats.views }}</span>\\n          </div>\\n        }\\n        @if (stats.links !== undefined) {\\n          <div class=\\\"stat-item\\\">\\n            <span class=\\\"stat-icon\\\">üîó</span>\\n            <span class=\\\"stat-value\\\">{{ stats.links }}</span>\\n          </div>\\n        }\\n      </div>\\n    }\\n  </div>\\n</div>\\n\\n\",\"import {\\n  Component,\\n  Input,\\n  OnInit,\\n  inject,\\n  PLATFORM_ID\\n} from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\nimport { CommonModule } from '@angular/common';\\nimport { ProfileCardComponent } from '../profile-card/profile-card.component';\\nimport { ProfileCardData } from '../profile-card/profile-card.component';\\nimport { StaggerListComponent } from '../stagger-list/stagger-list.component';\\nimport { ScrollRevealComponent } from '../scroll-reveal/scroll-reveal.component';\\n\\n/**\\n * Profile Grid Component\\n * Displays a grid of profile cards with stagger animations\\n * Perfect for team showcases, user directories, and portfolio grids\\n * \\n * @example\\n * <ngx-profile-grid\\n *   [profiles]=\\\"profileData\\\"\\n *   [columns]=\\\"4\\\"\\n *   [staggerDelay]=\\\"100\\\">\\n * </ngx-profile-grid>\\n */\\n@Component({\\n  selector: 'ngx-profile-grid',\\n  standalone: true,\\n  imports: [\\n    CommonModule,\\n    ProfileCardComponent,\\n    StaggerListComponent,\\n    ScrollRevealComponent\\n  ],\\n  templateUrl: './profile-grid.component.html',\\n  styleUrls: ['./profile-grid.component.css']\\n})\\nexport class ProfileGridComponent implements OnInit {\\n  @Input() profiles: ProfileCardData[] = [];\\n  @Input() columns: number = 4; // Number of columns in grid\\n  @Input() staggerDelay: number = 100; // Delay between each card animation\\n  @Input() staggerAnimation: 'fade' | 'slide-up' | 'slide-down' | 'scale' | 'rotate' = 'slide-up';\\n  @Input() enableStagger: boolean = true;\\n  @Input() enableScrollReveal: boolean = false;\\n  @Input() gap: number = 1.5; // Gap in rem units\\n  @Input() cardHeight: string = 'auto'; // Card height\\n\\n  private platformId = inject(PLATFORM_ID);\\n\\n  ngOnInit(): void {\\n    if (!isPlatformBrowser(this.platformId)) return;\\n  }\\n\\n  get gridStyle(): string {\\n    return `\\n      grid-template-columns: repeat(${this.columns}, 1fr);\\n      gap: ${this.gap}rem;\\n    `;\\n  }\\n}\\n\\n\",\"<div class=\\\"profile-grid-container\\\">\\n  @if (enableStagger && !enableScrollReveal) {\\n    <ngx-stagger-list\\n      [animation]=\\\"staggerAnimation\\\"\\n      [staggerDelay]=\\\"staggerDelay\\\"\\n      [triggerOnScroll]=\\\"true\\\">\\n      <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n        @for (profile of profiles; track profile.id || $index) {\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || 'üë§'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        }\\n      </div>\\n    </ngx-stagger-list>\\n  } @else if (enableScrollReveal) {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-scroll-reveal\\n          animation=\\\"scale\\\"\\n          [delay]=\\\"$index * 50\\\">\\n          <ngx-profile-card\\n            [name]=\\\"profile.name\\\"\\n            [username]=\\\"profile.username\\\"\\n            [jobTitle]=\\\"profile.jobTitle\\\"\\n            [gradient]=\\\"profile.gradient\\\"\\n            [icon]=\\\"profile.icon || 'üë§'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n          </ngx-profile-card>\\n        </ngx-scroll-reveal>\\n      }\\n    </div>\\n  } @else {\\n    <div class=\\\"profile-grid\\\" [style]=\\\"gridStyle\\\">\\n      @for (profile of profiles; track profile.id || $index) {\\n        <ngx-profile-card\\n          [name]=\\\"profile.name\\\"\\n          [username]=\\\"profile.username\\\"\\n          [jobTitle]=\\\"profile.jobTitle\\\"\\n          [gradient]=\\\"profile.gradient\\\"\\n          [icon]=\\\"profile.icon || 'üë§'\\\"\\n            [iconSvg]=\\\"profile.iconSvg\\\"\\n            [stats]=\\\"profile.stats\\\">\\n        </ngx-profile-card>\\n      }\\n    </div>\\n  }\\n</div>\\n\\n\",\"import { Component, Input, HostBinding, HostListener } from '@angular/core';\\n\\n@Component({\\n  selector: 'ngx-glass-card',\\n  standalone: true,\\n  template: `\\n    <div class=\\\"glass-card-inner\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  `,\\n  styles: [`\\n    :host {\\n      display: block;\\n      border-radius: 16px;\\n      overflow: hidden;\\n      position: relative;\\n      cursor: default;\\n      will-change: transform, box-shadow;\\n      transition: transform 200ms ease, box-shadow 200ms ease;\\n    }\\n\\n    .glass-card-inner {\\n      position: relative;\\n      padding: 1.5rem;\\n      border-radius: inherit;\\n      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.02));\\n      backdrop-filter: blur(18px);\\n      -webkit-backdrop-filter: blur(18px);\\n      border: 1px solid rgba(255, 255, 255, 0.08);\\n      box-shadow:\\n        0 18px 45px rgba(0, 0, 0, 0.45),\\n        0 0 0 1px rgba(255, 255, 255, 0.03);\\n      color: #f7fafc;\\n    }\\n\\n    :host(.elevated) {\\n      box-shadow:\\n        0 24px 60px rgba(0, 0, 0, 0.6),\\n        0 0 0 1px rgba(255, 255, 255, 0.06);\\n    }\\n\\n    :host(.hoverable:hover) {\\n      transform: translateY(-6px);\\n    }\\n\\n    :host(.accent-border) .glass-card-inner {\\n      border: 1px solid rgba(255, 93, 54, 0.75);\\n      box-shadow:\\n        0 22px 55px rgba(255, 93, 54, 0.45),\\n        0 0 0 1px rgba(255, 255, 255, 0.08);\\n    }\\n  `]\\n})\\nexport class GlassCardComponent {\\n  /** Slightly larger radius for very rounded cards */\\n  @Input() borderRadius: string = '16px';\\n\\n  /** Hover lift effect */\\n  @Input() hover: boolean = true;\\n\\n  /** Stronger shadow preset */\\n  @Input() elevated: boolean = false;\\n\\n  /** Accent border using the primary color */\\n  @Input() accent: boolean = false;\\n\\n  @HostBinding('style.borderRadius')\\n  get hostRadius() {\\n    return this.borderRadius;\\n  }\\n\\n  @HostBinding('class.hoverable')\\n  get hoverClass() {\\n    return this.hover;\\n  }\\n\\n  @HostBinding('class.elevated')\\n  get elevatedClass() {\\n    return this.elevated;\\n  }\\n\\n  @HostBinding('class.accent-border')\\n  get accentClass() {\\n    return this.accent;\\n  }\\n\\n  // Small tilt-on-hover effect for extra motion\\n  @HostBinding('style.transform')\\n  transform: string | null = null;\\n\\n  @HostListener('mousemove', ['$event'])\\n  onMouseMove(event: MouseEvent) {\\n    if (!this.hover) return;\\n    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect();\\n    const x = (event.clientX - rect.left) / rect.width - 0.5;\\n    const y = (event.clientY - rect.top) / rect.height - 0.5;\\n    const rotateX = y * -6;\\n    const rotateY = x * 6;\\n    this.transform = `perspective(700px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-4px)`;\\n  }\\n\\n  @HostListener('mouseleave')\\n  onMouseLeave() {\\n    this.transform = null;\\n  }\\n}\\n\\n\\n\",\"import { Injectable, ElementRef } from '@angular/core';\\n\\nexport interface TimelineStep {\\n  element: HTMLElement | ElementRef<HTMLElement>;\\n  properties: Partial<CSSStyleDeclaration>;\\n  duration: number;\\n  delay?: number;\\n  easing?: string;\\n}\\n\\nexport interface TimelineOptions {\\n  repeat?: boolean;\\n  repeatDelay?: number;\\n  onComplete?: () => void;\\n  onStart?: () => void;\\n  onRepeat?: () => void;\\n}\\n\\n/**\\n * Timeline Service\\n * Chain multiple animations in sequence or parallel\\n * Similar to GSAP Timeline but Angular-friendly\\n * \\n * @example\\n * const timeline = this.timelineService.create();\\n * timeline\\n *   .to(element1, { opacity: '1', transform: 'translateX(0)' }, 500)\\n *   .to(element2, { opacity: '1' }, 300, 100)\\n *   .play();\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class TimelineService {\\n  createTimeline(options?: TimelineOptions): Timeline {\\n    return new Timeline(options);\\n  }\\n\\n  // Convenience method\\n  create(options?: TimelineOptions): Timeline {\\n    return this.createTimeline(options);\\n  }\\n}\\n\\nexport class Timeline {\\n  private steps: TimelineStep[] = [];\\n  private parallelSteps: TimelineStep[][] = [];\\n  private currentStep = 0;\\n  private isPlaying = false;\\n  private isPaused = false;\\n  private options: TimelineOptions;\\n  private currentTimeouts: ReturnType<typeof setTimeout>[] = [];\\n\\n  constructor(options: TimelineOptions = {}) {\\n    this.options = options;\\n  }\\n\\n  /**\\n   * Add animation step to timeline\\n   */\\n  to(\\n    element: HTMLElement | ElementRef<HTMLElement>,\\n    properties: Partial<CSSStyleDeclaration>,\\n    duration: number,\\n    delay: number = 0,\\n    easing: string = 'cubic-bezier(0.4, 0, 0.2, 1)'\\n  ): this {\\n    const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\\n    \\n    this.steps.push({\\n      element: htmlElement,\\n      properties,\\n      duration,\\n      delay,\\n      easing\\n    });\\n\\n    return this;\\n  }\\n\\n  /**\\n   * Add animation step that starts from current properties\\n   */\\n  from(\\n    element: HTMLElement | ElementRef<HTMLElement>,\\n    properties: Partial<CSSStyleDeclaration>,\\n    duration: number,\\n    delay: number = 0,\\n    easing: string = 'cubic-bezier(0.4, 0, 0.2, 1)'\\n  ): this {\\n    const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\\n    \\n    // Set initial properties\\n    Object.assign(htmlElement.style, properties);\\n\\n    // Then animate to normal state\\n    const finalProperties: Partial<CSSStyleDeclaration> = {};\\n    Object.keys(properties).forEach(key => {\\n      finalProperties[key as any] = '';\\n    });\\n\\n    return this.to(htmlElement, finalProperties, duration, delay, easing);\\n  }\\n\\n  /**\\n   * Add animation step relative to current state\\n   */\\n  fromTo(\\n    element: HTMLElement | ElementRef<HTMLElement>,\\n    fromProperties: Partial<CSSStyleDeclaration>,\\n    toProperties: Partial<CSSStyleDeclaration>,\\n    duration: number,\\n    delay: number = 0,\\n    easing: string = 'cubic-bezier(0.4, 0, 0.2, 1)'\\n  ): this {\\n    const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\\n    \\n    // Set from properties\\n    Object.assign(htmlElement.style, fromProperties);\\n\\n    // Animate to properties\\n    return this.to(htmlElement, toProperties, duration, delay, easing);\\n  }\\n\\n  /**\\n   * Add multiple animations to run in parallel\\n   */\\n  parallel(callback: (timeline: Timeline) => void): this {\\n    const parallelTimeline = new Timeline();\\n    callback(parallelTimeline);\\n    this.parallelSteps.push(parallelTimeline.steps);\\n    return this;\\n  }\\n\\n  /**\\n   * Add a delay in the timeline\\n   */\\n  wait(duration: number): this {\\n    this.steps.push({\\n      element: document.createElement('div'),\\n      properties: {},\\n      duration,\\n      delay: 0\\n    });\\n    return this;\\n  }\\n\\n  /**\\n   * Add a label for positioning\\n   */\\n  addLabel(label: string): this {\\n    // Labels can be implemented for more complex timelines\\n    return this;\\n  }\\n\\n  /**\\n   * Play the timeline\\n   */\\n  play(): Promise<void> {\\n    if (this.isPlaying && !this.isPaused) return Promise.resolve();\\n\\n    this.isPlaying = true;\\n    this.isPaused = false;\\n\\n    if (this.options.onStart) {\\n      this.options.onStart();\\n    }\\n\\n    return this.playSteps();\\n  }\\n\\n  /**\\n   * Pause the timeline\\n   */\\n  pause(): this {\\n    this.isPaused = true;\\n    this.clearTimeouts();\\n    return this;\\n  }\\n\\n  /**\\n   * Resume the timeline\\n   */\\n  resume(): this {\\n    if (!this.isPaused) return this;\\n    \\n    this.isPaused = false;\\n    this.playSteps();\\n    return this;\\n  }\\n\\n  /**\\n   * Stop and reset the timeline\\n   */\\n  stop(): this {\\n    this.isPlaying = false;\\n    this.isPaused = false;\\n    this.currentStep = 0;\\n    this.clearTimeouts();\\n    return this;\\n  }\\n\\n  /**\\n   * Restart the timeline from beginning\\n   */\\n  restart(): Promise<void> {\\n    this.stop();\\n    return this.play();\\n  }\\n\\n  /**\\n   * Reverse the timeline\\n   */\\n  reverse(): this {\\n    this.steps.reverse();\\n    return this;\\n  }\\n\\n  private async playSteps(): Promise<void> {\\n    while (this.currentStep < this.steps.length && this.isPlaying && !this.isPaused) {\\n      const step = this.steps[this.currentStep];\\n      await this.animateStep(step);\\n      this.currentStep++;\\n    }\\n\\n    // Play parallel steps\\n    if (this.parallelSteps.length > 0 && this.isPlaying && !this.isPaused) {\\n      await this.playParallelSteps();\\n    }\\n\\n    if (this.currentStep >= this.steps.length && this.isPlaying) {\\n      this.onComplete();\\n    }\\n  }\\n\\n  private async playParallelSteps(): Promise<void> {\\n    const promises = this.parallelSteps[0].map(step => this.animateStep(step));\\n    await Promise.all(promises);\\n    this.parallelSteps.shift();\\n  }\\n\\n  private animateStep(step: TimelineStep): Promise<void> {\\n    return new Promise((resolve) => {\\n      const { element, properties, duration, delay = 0, easing = 'ease' } = step;\\n      const htmlElement = element instanceof ElementRef ? element.nativeElement : element;\\n\\n      // Set transition\\n      const transitionProperties = Object.keys(properties).join(', ');\\n      htmlElement.style.transition = `${transitionProperties} ${duration}ms ${easing}`;\\n\\n      const timeoutId = setTimeout(() => {\\n        // Apply properties\\n        Object.assign(htmlElement.style, properties);\\n\\n        // Resolve after animation completes\\n        const completeTimeoutId = setTimeout(() => {\\n          resolve();\\n        }, duration);\\n\\n        this.currentTimeouts.push(completeTimeoutId);\\n      }, delay);\\n\\n      this.currentTimeouts.push(timeoutId);\\n    });\\n  }\\n\\n  private onComplete(): void {\\n    this.isPlaying = false;\\n    this.currentStep = 0;\\n\\n    if (this.options.onComplete) {\\n      this.options.onComplete();\\n    }\\n\\n    if (this.options.repeat) {\\n      const delay = this.options.repeatDelay || 0;\\n      setTimeout(() => {\\n        if (this.options.onRepeat) {\\n          this.options.onRepeat();\\n        }\\n        this.play();\\n      }, delay);\\n    }\\n  }\\n\\n  private clearTimeouts(): void {\\n    this.currentTimeouts.forEach(timeout => clearTimeout(timeout));\\n    this.currentTimeouts = [];\\n  }\\n}\\n\\n\",\"import { Injectable, effect, inject, PLATFORM_ID } from '@angular/core';\\nimport { isPlatformBrowser } from '@angular/common';\\nimport { signal, computed } from '@angular/core';\\n\\n/**\\n * RTL & Language Service\\n * Provides runtime toggle between LTR/RTL and EN/AR.\\n *\\n * This is intentionally simple ‚Äì you can use it or plug it into your own i18n layer.\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class RtlLanguageService {\\n  private platformId = inject(PLATFORM_ID);\\n\\n  /** Current locale: 'en' or 'ar'. Default 'en'. */\\n  readonly locale = signal<'en' | 'ar'>('en');\\n\\n  /** Text direction derived from locale. */\\n  readonly direction = computed<'ltr' | 'rtl'>(() =>\\n    this.locale() === 'ar' ? 'rtl' : 'ltr'\\n  );\\n\\n  /** True when current direction is RTL. */\\n  readonly isRtl = computed(() => this.direction() === 'rtl');\\n\\n  constructor() {\\n    // Keep <html> dir/lang in sync with current locale (browser only).\\n    effect(() => {\\n      if (!isPlatformBrowser(this.platformId)) return;\\n\\n      const dir = this.direction();\\n      const lang = this.locale();\\n\\n      document.documentElement.setAttribute('dir', dir);\\n      document.documentElement.setAttribute('lang', lang);\\n    });\\n  }\\n\\n  setLocale(locale: 'en' | 'ar'): void {\\n    this.locale.set(locale);\\n  }\\n\\n  toggleLocale(): void {\\n    this.locale.update((current) => (current === 'en' ? 'ar' : 'en'));\\n  }\\n}\\n\\n\\n\",\"/*\\n * Public API Surface of @elm/ngx-animations\\n */\\n\\n// Directives - Basic\\nexport * from './lib/directives/fade-in.directive';\\nexport * from './lib/directives/slide-in.directive';\\nexport * from './lib/directives/scale-in.directive';\\nexport * from './lib/directives/rotate-in.directive';\\nexport * from './lib/directives/parallax-scroll.directive';\\nexport * from './lib/directives/ripple-click.directive';\\n\\n// Directives - Advanced\\nexport * from './lib/directives/bounce-in.directive';\\nexport * from './lib/directives/flip-in.directive';\\nexport * from './lib/directives/shake.directive';\\nexport * from './lib/directives/pulse.directive';\\nexport * from './lib/directives/glitch.directive';\\nexport * from './lib/directives/zoom-in.directive';\\nexport * from './lib/directives/hover-lift.directive';\\nexport * from './lib/directives/count-up.directive';\\n\\n// Directives - GSAP-Inspired (Premium Effects)\\nexport * from './lib/directives/magnetic.directive';\\nexport * from './lib/directives/tilt-3d.directive';\\nexport * from './lib/directives/scroll-progress.directive';\\nexport * from './lib/directives/morph.directive';\\n\\n// Components\\nexport * from './lib/components/scroll-reveal/scroll-reveal.component';\\nexport * from './lib/components/stagger-list/stagger-list.component';\\nexport * from './lib/components/typewriter/typewriter.component';\\nexport * from './lib/components/marquee/marquee.component';\\nexport * from './lib/components/orbit-animation/orbit-animation.component';\\nexport * from './lib/components/confetti/confetti.component';\\nexport * from './lib/components/text-scramble/text-scramble.component';\\nexport * from './lib/components/mouse-follower/mouse-follower.component';\\nexport * from './lib/components/profile-card/profile-card.component';\\nexport * from './lib/components/profile-grid/profile-grid.component';\\nexport * from './lib/components/glass-card/glass-card.component';\\n\\n// Export types\\nexport type { ProfileCardData } from './lib/components/profile-card/profile-card.component';\\n\\n// Services\\nexport * from './lib/services/timeline.service';\\nexport * from './lib/services/rtl-language.service';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}